{"task": "Create_an_object_at_a_given_address", "blocks": [{"lang": "6502 Assembly", "loc": 3, "block": "<pre class=\"text highlighted_source\">        sta $1900<br/>        stx $1901<br/>        sty $1902</pre>"}, {"lang": "Ada", "loc": 5, "block": "<pre class=\"ada highlighted_source\">\u00a0<br/><span class=\"kw3\">type</span> IO_Port <span class=\"kw1\">is</span> <span class=\"kw2\">mod</span> <span class=\"nu0\">2</span>**<span class=\"nu0\">8</span>; <span class=\"co1\">-- One byte</span><br/>Device_Port\u00a0: <span class=\"kw3\">type</span> IO_Port;<br/><span class=\"kw1\">for</span> Device_Port'Address <span class=\"kw3\">use</span> <span class=\"nu0\">16</span>#FFFF_F000#;<br/>\u00a0</pre>"}, {"lang": "Aikido", "loc": 13, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>\u00a0<br/>var portaddr = 0x80<br/>var v = peek (portaddr, 1)   // 1 byte<br/>v |= 0x40<br/>poke (portaddr, v, 1) // 1 byte back again<br/>\u00a0<br/>var addr = malloc (16)<br/>poke (addr, 1234, 4)<br/>poke (addr+4, 0, 2)<br/>poke (addr+6, 12, 2)<br/>\u00a0<br/>\u00a0</pre>"}, {"lang": "AutoHotkey", "loc": 9, "block": "<pre class=\"autohotkey highlighted_source\"><span class=\"co1\">; Create a variable with 4 bytes size and show it's machine address.</span><br/><a href=\"http://www.autohotkey.com/docs/commands/VarSetCapacity.htm\"><span class=\"kw3\">VarSetCapacity</span></a><span class=\"br0\">(</span>var<span class=\"sy0\">,</span> <span class=\"nu0\">4</span><span class=\"sy0\">,</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><br/>pAddress <span class=\"sy0\">:=</span> <span class=\"sy0\">&amp;</span>var<br/><a href=\"http://www.autohotkey.com/docs/commands/MsgBox.htm\"><span class=\"kw3\">MsgBox</span></a> Machine <span class=\"re2\">address: </span><span class=\"re0\">%pAddress%</span><br/>\u00a0<br/><span class=\"co1\">; pAddress contains the memory address.</span><br/><span class=\"co1\">; Write a number and read it back.</span><br/><a href=\"http://www.autohotkey.com/docs/Functions.htm#BuiltIn\"><span class=\"kw4\">NumPut</span></a><span class=\"br0\">(</span><span class=\"nu0\">123456</span><span class=\"sy0\">,</span> pAddress<span class=\"sy0\">+</span><span class=\"nu0\">0</span><span class=\"sy0\">,</span> <span class=\"nu0\">0</span><span class=\"sy0\">,</span> <span class=\"st0\">\"UInt\"</span><span class=\"br0\">)</span>                               <br/><a href=\"http://www.autohotkey.com/docs/commands/MsgBox.htm\"><span class=\"kw3\">MsgBox</span></a>\u00a0% <span class=\"st0\">\"Contents of *pAddress: \"</span> <span class=\"sy0\">.</span> <a href=\"http://www.autohotkey.com/docs/Functions.htm#BuiltIn\"><span class=\"kw4\">NumGet</span></a><span class=\"br0\">(</span>pAddress<span class=\"sy0\">+</span><span class=\"nu0\">0</span><span class=\"sy0\">,</span> <span class=\"nu0\">0</span><span class=\"sy0\">,</span> <span class=\"st0\">\"UInt\"</span><span class=\"br0\">)</span></pre>"}, {"lang": "BBC BASIC", "loc": 20, "block": "<pre class=\"text highlighted_source\">      REM Create an integer object:<br/>      anInteger% = 12345678<br/>      PRINT \"Original value =\", anInteger%<br/>\u00a0<br/>      REM Print the machine address of the object:<br/>      address% = ^anInteger%<br/>      PRINT \"Hexadecimal address =   \";~address%<br/>\u00a0<br/>      REM Take the address of the object and create<br/>      REM another integer object at this address:<br/>     \u00a0!address% = 87654321<br/>\u00a0<br/>      REM Print the value of this object to verify<br/>      REM that it is same as one of the origin:<br/>      PRINT \"New value =\", anInteger%<br/>\u00a0<br/>      REM Change the value and verify it again:<br/>      anInteger% = 55555555<br/>      PRINT \"Final value =\",\u00a0!address%<br/>\u00a0</pre>"}, {"lang": "C", "loc": 19, "block": "<pre class=\"c highlighted_source\"><span class=\"co2\">#include &lt;stdio.h&gt;</span><br/>\u00a0<br/><span class=\"kw4\">int</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>  <span class=\"kw4\">int</span> intspace<span class=\"sy0\">;</span><br/>  <span class=\"kw4\">int</span> <span class=\"sy0\">*</span>address<span class=\"sy0\">;</span><br/>\u00a0<br/>  address <span class=\"sy0\">=</span> <span class=\"sy0\">&amp;</span>intspace<span class=\"sy0\">;</span> <span class=\"co1\">// address = 0x100;</span><br/>  <span class=\"sy0\">*</span>address <span class=\"sy0\">=</span> <span class=\"nu0\">65535</span><span class=\"sy0\">;</span><br/>  <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/printf.html\"><span class=\"kw3\">printf</span></a><span class=\"br0\">(</span><span class=\"st0\">\"%p:\u00a0%08x (=%08x)<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span> address<span class=\"sy0\">,</span> <span class=\"sy0\">*</span>address<span class=\"sy0\">,</span> intspace<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>  <span class=\"co1\">// likely we must be worried about endianness, e.g.</span><br/>  <span class=\"sy0\">*</span><span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"kw4\">char</span><span class=\"sy0\">*</span><span class=\"br0\">)</span>address<span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"nu12\">0x00</span><span class=\"sy0\">;</span><br/>  <span class=\"sy0\">*</span><span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"kw4\">char</span><span class=\"sy0\">*</span><span class=\"br0\">)</span>address<span class=\"sy0\">+</span><span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"nu12\">0x00</span><span class=\"sy0\">;</span><br/>  <span class=\"sy0\">*</span><span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"kw4\">char</span><span class=\"sy0\">*</span><span class=\"br0\">)</span>address<span class=\"sy0\">+</span><span class=\"nu0\">2</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"nu12\">0xff</span><span class=\"sy0\">;</span><br/>  <span class=\"sy0\">*</span><span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"kw4\">char</span><span class=\"sy0\">*</span><span class=\"br0\">)</span>address<span class=\"sy0\">+</span><span class=\"nu0\">3</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"nu12\">0xff</span><span class=\"sy0\">;</span> <span class=\"co1\">// if sizeof(int) == 4!</span><br/>  <span class=\"co1\">// which maybe is not the best way of writing 32 bit values...</span><br/>  <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/printf.html\"><span class=\"kw3\">printf</span></a><span class=\"br0\">(</span><span class=\"st0\">\"%p:\u00a0%08x (=%08x)<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span> address<span class=\"sy0\">,</span> <span class=\"sy0\">*</span>address<span class=\"sy0\">,</span> intspace<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>  <span class=\"kw1\">return</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "C++", "loc": 24, "block": "<pre class=\"cpp highlighted_source\"><span class=\"co2\">#include &lt;string&gt;</span><br/><span class=\"co2\">#include &lt;iostream&gt;</span><br/>\u00a0<br/><span class=\"kw4\">int</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>    <span class=\"co1\">// Allocate enough memory to hold an instance of std::string</span><br/>    <span class=\"kw4\">char</span><span class=\"sy2\">*</span> data <span class=\"sy1\">=</span> <span class=\"kw3\">new</span> <span class=\"kw4\">char</span><span class=\"br0\">[</span><span class=\"kw3\">sizeof</span><span class=\"br0\">(</span>std<span class=\"sy4\">::</span><span class=\"me2\">string</span><span class=\"br0\">)</span><span class=\"br0\">]</span><span class=\"sy4\">;</span><br/>\u00a0<br/>    <span class=\"co1\">// use placement new to construct a std::string in the memory we allocated previously</span><br/>    std<span class=\"sy4\">::</span><span class=\"me2\">string</span><span class=\"sy2\">*</span> stringPtr <span class=\"sy1\">=</span> <span class=\"kw3\">new</span> <span class=\"br0\">(</span>data<span class=\"br0\">)</span> std<span class=\"sy4\">::</span><span class=\"me2\">string</span><span class=\"br0\">(</span><span class=\"st0\">\"ABCD\"</span><span class=\"br0\">)</span><span class=\"sy4\">;</span><br/>\u00a0<br/>    std<span class=\"sy4\">::</span><span class=\"kw3\">cout</span> <span class=\"sy1\">&lt;&lt;</span> <span class=\"sy2\">*</span>stringPtr <span class=\"sy1\">&lt;&lt;</span> <span class=\"st0\">\" 0x\"</span> <span class=\"sy1\">&lt;&lt;</span> stringPtr <span class=\"sy1\">&lt;&lt;</span> std<span class=\"sy4\">::</span><span class=\"me2\">endl</span><span class=\"sy4\">;</span><br/>\u00a0<br/>    <span class=\"co1\">// use placement new to construct a new string object in the same memory location</span><br/>    <span class=\"co1\">// remember to manually call destructor</span><br/>    stringPtr<span class=\"sy2\">-</span><span class=\"sy1\">&gt;</span>~basic_string<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy4\">;</span><br/>    stringPtr <span class=\"sy1\">=</span> <span class=\"kw3\">new</span> <span class=\"br0\">(</span>data<span class=\"br0\">)</span> std<span class=\"sy4\">::</span><span class=\"me2\">string</span><span class=\"br0\">(</span><span class=\"st0\">\"123456\"</span><span class=\"br0\">)</span><span class=\"sy4\">;</span><br/>\u00a0<br/>    std<span class=\"sy4\">::</span><span class=\"kw3\">cout</span> <span class=\"sy1\">&lt;&lt;</span> <span class=\"sy2\">*</span>stringPtr <span class=\"sy1\">&lt;&lt;</span> <span class=\"st0\">\" 0x\"</span> <span class=\"sy1\">&lt;&lt;</span> stringPtr <span class=\"sy1\">&lt;&lt;</span> std<span class=\"sy4\">::</span><span class=\"me2\">endl</span><span class=\"sy4\">;</span><br/>\u00a0<br/>    <span class=\"co1\">// clean up</span><br/>    stringPtr<span class=\"sy2\">-</span><span class=\"sy1\">&gt;</span>~basic_string<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy4\">;</span><br/>    <span class=\"kw3\">delete</span><span class=\"br0\">[</span><span class=\"br0\">]</span> data<span class=\"sy4\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "COBOL", "loc": 21, "block": "<pre class=\"cobol highlighted_source\">       <span class=\"kw3\">IDENTIFICATION</span> <span class=\"kw3\">DIVISION</span><span class=\"sy0\">.</span><br/>       <span class=\"kw3\">PROGRAM-ID</span><span class=\"sy0\">.</span> object-address-<span class=\"kw3\">test</span><span class=\"sy0\">.</span><br/>       <span class=\"kw3\">DATA</span> <span class=\"kw3\">DIVISION</span><span class=\"sy0\">.</span><br/>       LOCAL-STORAGE <span class=\"kw1\">SECTION</span><span class=\"sy0\">.</span><br/>       <span class=\"nu0\">01</span> int-<span class=\"kw3\">space</span><span class=\"sy0\">.</span><br/>          <span class=\"nu0\">05</span> val <span class=\"kw3\">PICTURE</span> <span class=\"nu0\">9</span><span class=\"br0\">(</span><span class=\"nu0\">5</span><span class=\"br0\">)</span> <span class=\"kw3\">VALUE</span> <span class=\"nu0\">12345</span><span class=\"sy0\">.</span><br/>       <span class=\"nu0\">01</span> addr BASED<span class=\"sy0\">.</span><br/>          <span class=\"nu0\">05</span> val <span class=\"kw3\">PICTURE</span> <span class=\"nu0\">9</span><span class=\"br0\">(</span><span class=\"nu0\">5</span><span class=\"br0\">)</span> <span class=\"kw3\">VALUE</span> <span class=\"kw3\">ZERO</span><span class=\"sy0\">.</span><br/>       <span class=\"nu0\">01</span> point <span class=\"kw3\">USAGE</span> <span class=\"kw3\">POINTER</span><span class=\"sy0\">.</span><br/>       <span class=\"kw3\">PROCEDURE</span> <span class=\"kw3\">DIVISION</span><span class=\"sy0\">.</span><br/>         <span class=\"kw2\">DISPLAY</span> val <span class=\"kw3\">OF</span> int-<span class=\"kw3\">space</span> END-<span class=\"kw2\">DISPLAY</span><br/>         <span class=\"kw3\">SET</span> point <span class=\"kw2\">TO</span> <span class=\"kw3\">ADDRESS</span> <span class=\"kw3\">OF</span> int-<span class=\"kw3\">space</span><br/>         <span class=\"kw2\">DISPLAY</span> point END-<span class=\"kw2\">DISPLAY</span><br/>         <span class=\"kw3\">SET</span> <span class=\"kw3\">ADDRESS</span> <span class=\"kw3\">OF</span> addr <span class=\"kw2\">TO</span> point<br/>         <span class=\"kw2\">DISPLAY</span> val <span class=\"kw3\">OF</span> addr END-<span class=\"kw2\">DISPLAY</span><br/>         <span class=\"kw2\">MOVE</span> <span class=\"nu0\">65535</span> <span class=\"kw2\">TO</span> val <span class=\"kw3\">OF</span> addr<br/>         <span class=\"kw2\">DISPLAY</span> val <span class=\"kw3\">OF</span> addr END-<span class=\"kw2\">DISPLAY</span><br/>         <span class=\"kw2\">DISPLAY</span> val <span class=\"kw3\">OF</span> int-<span class=\"kw3\">space</span> END-<span class=\"kw2\">DISPLAY</span><br/>         <span class=\"kw3\">STOP</span> <span class=\"kw3\">RUN</span><span class=\"sy0\">.</span><br/>       <span class=\"kw3\">END</span> <span class=\"kw3\">PROGRAM</span> object-address-<span class=\"kw3\">test</span><span class=\"sy0\">.</span><br/>\u00a0</pre>"}, {"lang": "D", "loc": 34, "block": "<pre class=\"d highlighted_source\"><span class=\"kw2\">import</span> std.<span class=\"me1\">stdio</span> <span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"kw4\">void</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <span class=\"kw4\">int</span><span class=\"br0\">[</span><span class=\"br0\">]</span> arr <span class=\"sy0\">;</span><br/>    <span class=\"kw1\">foreach</span><span class=\"br0\">(</span>i<span class=\"sy0\">;</span> <span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"sy0\">,</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span><span class=\"nu0\">2</span><span class=\"sy0\">,</span><span class=\"nu0\">3</span><span class=\"br0\">]</span><span class=\"br0\">)</span><br/>        arr <span class=\"sy0\">~=</span> i<span class=\"sy0\">*</span><span class=\"br0\">(</span><span class=\"nu0\">1</span> <span class=\"sy0\">&lt;&lt;</span> <span class=\"nu0\">24</span><span class=\"br0\">)</span> <span class=\"sy0\">+</span> <span class=\"nu12\">0x417e7e7e</span> <span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"kw4\">struct</span> X <span class=\"br0\">{</span><br/>        <span class=\"kw4\">char</span><span class=\"br0\">[</span><span class=\"nu0\">16</span><span class=\"br0\">]</span> msg <span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    X<span class=\"sy0\">*</span> xPtr <span class=\"sy0\">;</span><br/>    <span class=\"kw4\">int</span><span class=\"sy0\">*</span> iPtr <span class=\"sy0\">;</span><br/>    <span class=\"kw4\">float</span><span class=\"sy0\">*</span> fPtr <span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"kw4\">int</span> adrSpace <span class=\"sy0\">=</span> <span class=\"kw2\">cast</span><span class=\"br0\">(</span><span class=\"kw4\">int</span><span class=\"br0\">)</span> arr.<span class=\"me1\">ptr</span> <span class=\"sy0\">;</span><br/>    <span class=\"co1\">// get address of an existing object arr</span><br/>\u00a0<br/>    xPtr <span class=\"sy0\">=</span> <span class=\"kw2\">cast</span><span class=\"br0\">(</span>X<span class=\"sy0\">*</span><span class=\"br0\">)</span> adrSpace <span class=\"sy0\">;</span><br/>    <span class=\"co1\">// xPtr now point to arr, as a struct X</span><br/>    writefln<span class=\"br0\">(</span><span class=\"st0\">\"arr(as X)'s msg = '%s' (len\u00a0%d) @ 0x%08x\"</span><span class=\"sy0\">,</span><br/>        xPtr.<span class=\"me1\">msg</span><span class=\"sy0\">,</span> xPtr.<span class=\"me1\">msg</span>.<span class=\"me1\">length</span><span class=\"sy0\">,</span> xPtr<span class=\"br0\">)</span> <span class=\"sy0\">;</span><br/>\u00a0<br/>    iPtr <span class=\"sy0\">=</span> <span class=\"kw2\">cast</span><span class=\"br0\">(</span><span class=\"kw4\">int</span><span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>adrSpace <span class=\"sy0\">+</span> <span class=\"nu0\">1</span> <span class=\"sy0\">*</span> <span class=\"nu0\">4</span> <span class=\"coMULTI\">/*bytes*/</span><span class=\"br0\">)</span> <span class=\"sy0\">;</span><br/>    fPtr <span class=\"sy0\">=</span> <span class=\"kw2\">cast</span><span class=\"br0\">(</span><span class=\"kw4\">float</span><span class=\"sy0\">*</span><span class=\"br0\">)</span> iPtr <span class=\"sy0\">;</span><br/>    <span class=\"co1\">// pointers now point to arr[1]</span><br/>    writefln<span class=\"br0\">(</span><span class=\"st0\">\"arr[1] = 0x%8x (%9.4f) @ 0x%08X\"</span><span class=\"sy0\">,</span> <span class=\"sy0\">*</span>iPtr<span class=\"sy0\">,</span> <span class=\"sy0\">*</span>fPtr<span class=\"sy0\">,</span> iPtr<span class=\"br0\">)</span> <span class=\"sy0\">;</span><br/>    iPtr <span class=\"sy0\">=</span> <span class=\"kw2\">cast</span><span class=\"br0\">(</span><span class=\"kw4\">int</span><span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>adrSpace <span class=\"sy0\">+</span> <span class=\"nu0\">3</span> <span class=\"sy0\">*</span> <span class=\"nu0\">4</span> <span class=\"coMULTI\">/*bytes*/</span><span class=\"br0\">)</span> <span class=\"sy0\">;</span><br/>    fPtr <span class=\"sy0\">=</span> <span class=\"kw2\">cast</span><span class=\"br0\">(</span><span class=\"kw4\">float</span><span class=\"sy0\">*</span><span class=\"br0\">)</span> iPtr <span class=\"sy0\">;</span><br/>    <span class=\"co1\">// pointers now point to arr[3]</span><br/>    writefln<span class=\"br0\">(</span><span class=\"st0\">\"arr[3] = 0x%8x (%9.4f) @ 0x%08X\"</span><span class=\"sy0\">,</span> <span class=\"sy0\">*</span>iPtr<span class=\"sy0\">,</span> <span class=\"sy0\">*</span>fPtr<span class=\"sy0\">,</span> iPtr<span class=\"br0\">)</span> <span class=\"sy0\">;</span><br/>    <span class=\"sy0\">*</span>fPtr <span class=\"sy0\">=</span> <span class=\"nu17\">0.5f</span> <span class=\"sy0\">;</span> <span class=\"co1\">// change value</span><br/>    writefln<span class=\"br0\">(</span><span class=\"st0\">\"arr[3] = 0x%8x (%9.4f) @ 0x%08X\"</span><span class=\"sy0\">,</span> <span class=\"sy0\">*</span>iPtr<span class=\"sy0\">,</span> <span class=\"sy0\">*</span>fPtr<span class=\"sy0\">,</span> iPtr<span class=\"br0\">)</span> <span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Forth", "loc": 6, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>$3f8 constant LPT1:<br/>\u00a0<br/>LPT1: <a class=\"__cf_email__\" data-cfemail=\"b1d2f1\" href=\"/cdn-cgi/l/email-protection\">[email\u00a0protected]</a> .<br/>$3f LPT1: c!<br/>\u00a0</pre>"}, {"lang": "FreeBASIC", "loc": 34, "block": "<pre class=\"freebasic highlighted_source\"><span class=\"co1\">' FB 1.05.0</span><br/>\u00a0<br/><span class=\"kw1\">Type</span> Person<br/>  <span class=\"kw1\">As</span> <span class=\"kw1\">String</span> <span class=\"kw1\">name</span><br/>  <span class=\"kw1\">As</span> <span class=\"kw1\">Integer</span> age<br/>  <span class=\"kw1\">Declare</span> Constructor<span class=\"br0\">(</span><span class=\"kw1\">name</span> <span class=\"kw1\">As</span> <span class=\"kw1\">String</span>, age <span class=\"kw1\">As</span> <span class=\"kw1\">Integer</span><span class=\"br0\">)</span><br/><span class=\"kw1\">End</span> <span class=\"kw1\">Type</span><br/>\u00a0<br/>Constructor Person<span class=\"br0\">(</span><span class=\"kw1\">name</span> <span class=\"kw1\">As</span> <span class=\"kw1\">String</span>, age <span class=\"kw1\">As</span> <span class=\"kw1\">Integer</span><span class=\"br0\">)</span><br/>  This.<span class=\"kw1\">name</span> = <span class=\"kw1\">name</span><br/>  This.<span class=\"me1\">age</span> = age<br/><span class=\"kw1\">End</span> Constructor<br/>\u00a0<br/><span class=\"kw1\">Dim</span> ap <span class=\"kw1\">As</span> Any <span class=\"kw1\">Ptr</span> = <span class=\"kw1\">CAllocate</span><span class=\"br0\">(</span><span class=\"kw1\">SizeOf</span><span class=\"br0\">(</span>Person<span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"co1\">' allocate memory to store a Person object</span><br/>\u00a0<br/><span class=\"co1\">'create a Person object at the address of the memory we've just allocated</span><br/>\u00a0<br/><span class=\"kw1\">Dim</span> p <span class=\"kw1\">As</span> Person <span class=\"kw1\">Ptr</span> = New<span class=\"br0\">(</span>ap<span class=\"br0\">)</span> Person<span class=\"br0\">(</span><span class=\"st0\">\"Teresa\"</span>, <span class=\"nu0\">60</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">'check addresses are same</span><br/><span class=\"kw1\">Print</span> ap, p<br/>\u00a0<br/><span class=\"co1\">'check data is not corrupt</span><br/><span class=\"kw1\">Print</span> p -&gt; <span class=\"kw1\">name</span>, p -&gt; age<br/>\u00a0<br/><span class=\"co1\">'call implicit destructor</span><br/>p -&gt; Destructor<br/>\u00a0<br/><span class=\"co1\">'free memory</span><br/><span class=\"kw1\">Deallocate</span><span class=\"br0\">(</span>ap<span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"kw1\">Print</span><br/><span class=\"kw1\">Print</span> <span class=\"st0\">\"Press any key to quit\"</span><br/><span class=\"kw1\">Sleep</span></pre>"}, {"lang": "Go", "loc": 58, "block": "<pre class=\"go highlighted_source\"><span class=\"kw1\">package</span> main<br/>\u00a0<br/><span class=\"kw1\">import</span><span class=\"sy1\">(</span><br/>\t<span class=\"st0\">\"fmt\"</span><br/>\t<span class=\"st0\">\"unsafe\"</span><br/>\t<span class=\"st0\">\"reflect\"</span><br/><span class=\"sy1\">)</span><br/>\u00a0<br/><span class=\"kw4\">func</span> pointer<span class=\"sy1\">()</span> <span class=\"sy1\">{</span><br/>\tfmt<span class=\"sy3\">.</span>Printf<span class=\"sy1\">(</span><span class=\"st0\">\"Pointer:<span class=\"es1\">\\n</span>\"</span><span class=\"sy1\">)</span><br/>\u00a0<br/>\t<span class=\"co1\">// Create a *int and store the address of 'i' in it. To create a pointer to</span><br/>\t<span class=\"co1\">// an arbitrary memory location, use something like the following:</span><br/>\t<span class=\"co1\">//    p\u00a0:= (*int)(unsafe.Pointer(uintptr(0x100)))</span><br/>\t<span class=\"co1\">// And replace '0x100' with the desired address.</span><br/>\t<span class=\"kw1\">var</span> <span class=\"nu2\">i</span> <span class=\"kw4\">int</span><br/>\tp <span class=\"sy2\">:=</span> &amp;<span class=\"nu2\">i</span><br/>\u00a0<br/>\tfmt<span class=\"sy3\">.</span>Printf<span class=\"sy1\">(</span><span class=\"st0\">\"Before:<span class=\"es1\">\\n</span><span class=\"es1\">\\t</span>%v:\u00a0%v,\u00a0%v<span class=\"es1\">\\n</span>\"</span><span class=\"sy1\">,</span> p<span class=\"sy1\">,</span> <span class=\"sy3\">*</span>p<span class=\"sy1\">,</span> <span class=\"nu2\">i</span><span class=\"sy1\">)</span><br/>\u00a0<br/>\t<span class=\"sy3\">*</span>p <span class=\"sy2\">=</span> <span class=\"nu0\">3</span><br/>\u00a0<br/>\tfmt<span class=\"sy3\">.</span>Printf<span class=\"sy1\">(</span><span class=\"st0\">\"After:<span class=\"es1\">\\n</span><span class=\"es1\">\\t</span>%v:\u00a0%v,\u00a0%v<span class=\"es1\">\\n</span>\"</span><span class=\"sy1\">,</span> p<span class=\"sy1\">,</span> <span class=\"sy3\">*</span>p<span class=\"sy1\">,</span> <span class=\"nu2\">i</span><span class=\"sy1\">)</span><br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"kw4\">func</span> slice<span class=\"sy1\">()</span> <span class=\"sy1\">{</span><br/>\tfmt<span class=\"sy3\">.</span>Printf<span class=\"sy1\">(</span><span class=\"st0\">\"Slice:<span class=\"es1\">\\n</span>\"</span><span class=\"sy1\">)</span><br/>\u00a0<br/>\t<span class=\"kw1\">var</span> a <span class=\"sy1\">[</span><span class=\"nu0\">10</span><span class=\"sy1\">]</span><span class=\"kw4\">byte</span><br/>\u00a0<br/>\t<span class=\"co1\">// reflect.SliceHeader is a runtime representation of the internal workings</span><br/>\t<span class=\"co1\">// of a slice. To make it point to a specific address, use something like</span><br/>\t<span class=\"co1\">// the following:</span><br/>\t<span class=\"co1\">//    h.Data = uintptr(0x100)</span><br/>\t<span class=\"co1\">// And replace '0x100' with the desired address.</span><br/>\t<span class=\"kw1\">var</span> h <a href=\"http://golang.org/search?q=reflect.SliceHeader\"><span class=\"kw5\">reflect.<span class=\"me1\">SliceHeader</span></span></a><br/>\th<span class=\"sy3\">.</span>Data <span class=\"sy2\">=</span> <span class=\"kw4\">uintptr</span><span class=\"sy1\">(</span>unsafe<span class=\"sy3\">.</span>Pointer<span class=\"sy1\">(</span>&amp;a<span class=\"sy1\">))</span> <span class=\"co1\">// The address of the first element of the underlying array.</span><br/>\th<span class=\"sy3\">.</span>Len <span class=\"sy2\">=</span> <span class=\"kw3\">len</span><span class=\"sy1\">(</span>a<span class=\"sy1\">)</span><br/>\th<span class=\"sy3\">.</span>Cap <span class=\"sy2\">=</span> <span class=\"kw3\">len</span><span class=\"sy1\">(</span>a<span class=\"sy1\">)</span><br/>\u00a0<br/>\t<span class=\"co1\">// Create an actual slice from the SliceHeader.</span><br/>\ts <span class=\"sy2\">:=</span> <span class=\"sy3\">*</span><span class=\"sy1\">(</span><span class=\"sy3\">*</span><span class=\"sy1\">[]</span><span class=\"kw4\">byte</span><span class=\"sy1\">)(</span>unsafe<span class=\"sy3\">.</span>Pointer<span class=\"sy1\">(</span>&amp;h<span class=\"sy1\">))</span><br/>\u00a0<br/>\tfmt<span class=\"sy3\">.</span>Printf<span class=\"sy1\">(</span><span class=\"st0\">\"Before:<span class=\"es1\">\\n</span><span class=\"es1\">\\t</span>s:\u00a0%v<span class=\"es1\">\\n</span><span class=\"es1\">\\t</span>a:\u00a0%v<span class=\"es1\">\\n</span>\"</span><span class=\"sy1\">,</span> s<span class=\"sy1\">,</span> a<span class=\"sy1\">)</span><br/>\u00a0<br/>\t<span class=\"co1\">// Copy a string into the slice. This fills the underlying array, which in</span><br/>\t<span class=\"co1\">// this case has been manually set to 'a'.</span><br/>\t<span class=\"kw3\">copy</span><span class=\"sy1\">(</span>s<span class=\"sy1\">,</span> <span class=\"st0\">\"A string.\"</span><span class=\"sy1\">)</span><br/>\u00a0<br/>\tfmt<span class=\"sy3\">.</span><span class=\"me1\">Printf</span><span class=\"sy1\">(</span><span class=\"st0\">\"After:<span class=\"es1\">\\n</span><span class=\"es1\">\\t</span>s:\u00a0%v<span class=\"es1\">\\n</span><span class=\"es1\">\\t</span>a:\u00a0%v<span class=\"es1\">\\n</span>\"</span><span class=\"sy1\">,</span> s<span class=\"sy1\">,</span> a<span class=\"sy1\">)</span><br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"kw4\">func</span> main<span class=\"sy1\">()</span> <span class=\"sy1\">{</span><br/>\tpointer<span class=\"sy1\">()</span><br/>\tfmt<span class=\"sy3\">.</span>Println<span class=\"sy1\">()</span><br/>\u00a0<br/>\tslice<span class=\"sy1\">()</span><br/><span class=\"sy1\">}</span></pre>"}, {"lang": "Julia", "loc": 15, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>function unsafepointers()<br/>    intspace = [42]<br/>    address = pointer_from_objref(intspace)<br/>    println(\"The address of intspace is $address\")<br/>    anotherint = unsafe_pointer_to_objref(address)<br/>    println(\"intspace is $(intspace[1]), memory at $address, reference value $(anotherint[1])\")<br/>    intspace[1] = 123456<br/>    println(\"Now, intspace is $(intspace[1]), memory at $address, reference value $(anotherint[1])\")<br/>    anotherint[1] = 7890<br/>    println(\"Now, intspace is $(intspace[1]), memory at $(pointer_from_objref(anotherint)), reference value $(anotherint[1])\")<br/>end<br/>\u00a0<br/>unsafepointers()<br/>\u00a0</pre>"}, {"lang": "Kotlin", "loc": 11, "block": "<pre class=\"scala highlighted_source\"><span class=\"co1\">// Kotlin/Native Technology Preview</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">import</span></a> kotlinx.<span class=\"me1\">cinterop</span>.<span class=\"sy0\">*</span><br/>\u00a0<br/>fun main<span class=\"br0\">(</span>args<span class=\"sy0\">:</span> Array<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> intVar <span class=\"sy0\">=</span> nativeHeap.<span class=\"me1\">alloc</span><span class=\"sy0\">&lt;</span>IntVar<span class=\"sy0\">&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span>.<span class=\"me1\">apply</span> <span class=\"br0\">{</span> value <span class=\"sy0\">=</span> <span class=\"nu0\">42</span> <span class=\"br0\">}</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">with</span></a><span class=\"br0\">(</span>intVar<span class=\"br0\">)</span> <span class=\"br0\">{</span> println<span class=\"br0\">(</span><span class=\"st0\">\"Value is $value, address is $rawPtr\"</span><span class=\"br0\">)</span> <span class=\"br0\">}</span><br/>    intVar.<span class=\"me1\">value</span> <span class=\"sy0\">=</span> <span class=\"nu0\">52</span>  <span class=\"co1\">// create new value at this address</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">with</span></a><span class=\"br0\">(</span>intVar<span class=\"br0\">)</span> <span class=\"br0\">{</span> println<span class=\"br0\">(</span><span class=\"st0\">\"Value is $value, address is $rawPtr\"</span><span class=\"br0\">)</span> <span class=\"br0\">}</span><br/>    nativeHeap.<span class=\"me1\">free</span><span class=\"br0\">(</span>intVar<span class=\"br0\">)</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "M2000 Interpreter", "loc": 39, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>Module CheckIt {<br/>      structure  alfa {<br/>            val as long<br/>      }<br/>      Buffer Clear Beta as alfa*2<br/>      Print Beta(0)  ' return address<br/>      Return Beta, 0!val:=500 ' unsigned integer 32 bit<br/>      Print Eval(Beta, 0!val)=500<br/>      Return Beta, 0!val:=0xFFFFFFFF<br/>      Print Eval(Beta, 0!val)=4294967295<br/>      Buffer Code ExecMem as byte*1024<br/>      Offset=0<br/>      EmbLong(0xb8, 5000) ' mov eax,5100<br/>      EmbByteLong(0x3,0x5, Beta(0)) ' add eax, [Beta(0)] <br/>      EmbLong(0xa3, Beta(1)) ' mov [Beta(1)], eax<br/>      EmbByte(0x31, 0xC0) ' xor eax, eax       <br/>      Ret() ' Return<br/>      Execute Code ExecMem, 0<br/>      Print eval(Beta, 1!val)=4999<br/>      Sub Ret()<br/>            Return ExecMem, Offset:=0xC3<br/>            Offset++<br/>      End Sub<br/>      Sub EmbByte()<br/>            Return ExecMem, Offset:=Number, Offset+1:=Number<br/>            Offset+=2<br/>      End Sub<br/>      Sub EmbLong()<br/>            Return ExecMem, Offset:=Number, Offset+1:=Number as Long<br/>            Offset+=5<br/>      End Sub<br/>      Sub EmbByteLong()<br/>            Return ExecMem, Offset:=Number, Offset+1:=Number, Offset+2:=Number as Long<br/>            Offset+=6<br/>      End Sub<br/>}<br/>Checkit<br/>\u00a0</pre>"}, {"lang": "Pascal", "loc": 21, "block": "<pre class=\"pascal highlighted_source\"><span class=\"kw1\">program</span> test<span class=\"sy1\">;</span><br/><span class=\"kw1\">type</span><br/>  t8Byte <span class=\"sy3\">=</span>  <span class=\"kw4\">array</span><span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"sy1\">..</span><span class=\"nu0\">7</span><span class=\"br0\">]</span> <span class=\"kw1\">of</span> <span class=\"kw4\">byte</span><span class=\"sy1\">;</span><br/><span class=\"kw1\">var</span><br/>  I <span class=\"sy1\">:</span> <span class=\"kw4\">integer</span><span class=\"sy1\">;</span><br/>  A <span class=\"sy1\">:</span> <span class=\"kw4\">integer</span> <span class=\"kw1\">absolute</span> I<span class=\"sy1\">;</span><br/>  K <span class=\"sy1\">:</span> t8Byte<span class=\"sy1\">;</span><br/>  L <span class=\"sy1\">:</span> Int64 <span class=\"kw1\">absolute</span> K<span class=\"sy1\">;</span><br/><span class=\"kw1\">begin</span><br/>  I <span class=\"sy1\">:</span><span class=\"sy3\">=</span> <span class=\"nu0\">0</span><span class=\"sy1\">;</span><br/>  A <span class=\"sy1\">:</span><span class=\"sy3\">=</span> <span class=\"nu0\">255</span><span class=\"sy1\">;</span> <span class=\"kw3\">writeln</span><span class=\"br0\">(</span>I<span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>  I <span class=\"sy1\">:</span><span class=\"sy3\">=</span> <span class=\"nu0\">4711</span><span class=\"sy1\">;</span><span class=\"kw3\">writeln</span><span class=\"br0\">(</span>A<span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>\u00a0<br/>  <span class=\"kw1\">For</span> i <span class=\"kw1\">in</span> t8Byte <span class=\"kw1\">do</span><br/>  <span class=\"kw1\">Begin</span><br/>    K<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"sy1\">:</span><span class=\"sy3\">=</span>i<span class=\"sy1\">;</span><br/>    <span class=\"kw3\">write</span><span class=\"br0\">(</span>i<span class=\"sy1\">:</span><span class=\"nu0\">3</span><span class=\"sy1\">,</span><span class=\"st0\">' '</span><span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>  <span class=\"kw1\">end</span><span class=\"sy1\">;</span><br/>  <span class=\"kw3\">writeln</span><span class=\"br0\">(</span><span class=\"re1\">#8</span><span class=\"re1\">#32</span><span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>  <span class=\"kw3\">writeln</span><span class=\"br0\">(</span>L<span class=\"br0\">)</span><span class=\"sy1\">;</span><br/><span class=\"kw1\">end</span><span class=\"sy1\">.</span></pre>"}, {"lang": "Phix", "loc": 4, "block": "<pre class=\"text highlighted_source\">poke(0x80,or_bits(peek(0x80),0x40))<br/>#ilASM{ mov al,[0x80]<br/>        or al,0x40<br/>        mov [0x80],al}</pre>"}, {"lang": "PicoLisp", "loc": 11, "block": "<pre class=\"text highlighted_source\">: (setq IntSpace 12345)          # Integer<br/>-&gt; 12345<br/>\u00a0<br/>: (setq Address (adr 'IntSpace)) # Encoded machine address<br/>-&gt; -2969166782547<br/>\u00a0<br/>: (set (adr Address) 65535)      # Set this address to a new value<br/>-&gt; 65535<br/>\u00a0<br/>: IntSpace                       # Show the new value<br/>-&gt; 65535</pre>"}, {"lang": "PureBasic", "loc": 22, "block": "<pre class=\"purebasic highlighted_source\"><span class=\"co1\">; Allocate a 1Mb memory area work within to avoid conflicts,</span><br/><span class=\"co1\">; this address could be any number but it may then fail on some systems.</span><br/><span class=\"sy0\">*</span>a<span class=\"sy0\">=</span><span class=\"kw2\">AllocateMemory</span><span class=\"br0\">(</span><span class=\"nu0\">1024</span><span class=\"sy0\">*</span><span class=\"nu0\">1024</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">; Write a int wit value \"31415\" at address +312,</span><br/><span class=\"co1\">; using pointer '*a' with a displacement.</span><br/>PokeI<span class=\"br0\">(</span><span class=\"sy0\">*</span>a<span class=\"sy0\">+</span><span class=\"nu0\">312</span>, <span class=\"nu0\">31415</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">; Write a float with value Pi at address +316,</span><br/><span class=\"co1\">; by creating a new pointer '*b' for this address</span><br/><span class=\"sy0\">*</span>b<span class=\"sy0\">=*</span>a<span class=\"sy0\">+</span><span class=\"nu0\">316</span><br/><span class=\"kw2\">PokeF</span><span class=\"br0\">(</span><span class=\"sy0\">*</span>b, #PI<span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;Now test it</span><br/><span class=\"kw1\">For</span> i<span class=\"sy0\">=</span><span class=\"nu0\">0</span> <span class=\"kw1\">To</span> <span class=\"nu0\">1024000</span> <span class=\"kw1\">Step</span> <span class=\"nu0\">4</span><br/>  n<span class=\"sy0\">=</span>PeekI<span class=\"br0\">(</span><span class=\"sy0\">*</span>a<span class=\"sy0\">+</span>i<span class=\"br0\">)</span><br/>  <span class=\"kw1\">If</span> n<br/>    <span class=\"kw1\">Debug</span> <span class=\"st0\">\"Int at +\"</span><span class=\"sy0\">+</span><span class=\"kw2\">Str</span><span class=\"br0\">(</span>i<span class=\"br0\">)</span><span class=\"sy0\">+</span><span class=\"st0\">\"  = \"</span><span class=\"sy0\">+</span><span class=\"kw2\">Str</span><span class=\"br0\">(</span>n<span class=\"br0\">)</span><br/>    <span class=\"kw1\">Debug</span> <span class=\"st0\">\"Float at +\"</span><span class=\"sy0\">+</span><span class=\"kw2\">Str</span><span class=\"br0\">(</span>i<span class=\"br0\">)</span><span class=\"sy0\">+</span><span class=\"st0\">\"= \"</span><span class=\"sy0\">+</span><span class=\"kw2\">StrF</span><span class=\"br0\">(</span><span class=\"kw2\">PeekF</span><span class=\"br0\">(</span><span class=\"sy0\">*</span>a<span class=\"sy0\">+</span>i<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>  <span class=\"kw1\">EndIf</span><br/><span class=\"kw1\">Next</span><br/>\u00a0</pre>"}, {"lang": "Racket", "loc": 27, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>#lang racket<br/>(require ffi/unsafe)<br/>\u00a0<br/>(define x #\"Foo\")<br/>;; Get the address of the `x' object<br/>(printf \"The address of `x' is: ~s\\n\" (cast x _scheme _long))<br/>(define address (cast x _bytes _long))<br/>(printf \"The address of the bytestring it holds: ~s\\n\" address)<br/>(define y (cast address _long _bytes))<br/>(printf \"Converting this back to a bytestring: ~s\\n\" y)<br/>(bytes-set! y 0 71)<br/>(printf \"Changed the converted bytestring: ~s\\n\" y)<br/>(printf \"The original one is now: ~s\\n\" x)<br/>;; But (bytes-set! x 0 71) will throw an error since `x' is immutable,<br/>;; showing that we've really modifed the memory directly in a way that<br/>;; the runtime doesn't like.<br/>\u00a0<br/>;; Also, the above can fail at any moment if a GC happens, since<br/>;; Racket's GC moves objects.  So a proper way to do this is not to<br/>;; start from an existing object, but allocate one outside of the GC's<br/>;; reach, using raw malloc():<br/>(define buf (malloc 4 'raw))<br/>(make-sized-byte-string buf 4)<br/>;; or start with a given address of something like a memory-mapped IO<br/>;; object<br/>\u00a0</pre>"}, {"lang": "Rust", "loc": 19, "block": "<pre class=\"text highlighted_source\">use std::{mem,ptr};<br/>\u00a0<br/>fn main() {<br/>    let mut data: i32;<br/>\u00a0<br/>    // Rust does not allow us to use uninitialized memory but the STL provides an `unsafe`<br/>    // function to override this protection.<br/>    unsafe {data = mem::uninitialized()}<br/>\u00a0<br/>    // Construct a raw pointer (perfectly safe)<br/>    let address = &amp;mut data as *mut _;<br/>\u00a0<br/>    unsafe {ptr::write(address, 5)}<br/>    println!(\"{0:p}: {0}\", &amp;data);<br/>\u00a0<br/>    unsafe {ptr::write(address, 6)}<br/>    println!(\"{0:p}: {0}\", &amp;data);<br/>\u00a0<br/>}</pre>"}, {"lang": "Scala", "loc": 21, "block": "<pre class=\"tcl highlighted_source\"><span class=\"kw2\">package</span> require critcl<br/>\u00a0<br/><span class=\"co1\"># A command to 'make an integer object' and couple it to a Tcl variable</span><br/>critcl::<span class=\"me1\">cproc</span> linkvar <span class=\"br0\">{</span>Tcl_Interp<span class=\"sy0\">*</span> <span class=\"kw2\">interp</span> char<span class=\"sy0\">*</span> var1<span class=\"br0\">}</span> int <span class=\"br0\">{</span><br/>    int <span class=\"sy0\">*</span>intPtr = <span class=\"br0\">(</span>int <span class=\"sy0\">*</span><span class=\"br0\">)</span> ckalloc<span class=\"br0\">(</span>sizeof<span class=\"br0\">(</span>int<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"sy0\">*</span>intPtr = <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>    Tcl_LinkVar<span class=\"br0\">(</span><span class=\"kw2\">interp</span>, var1, <span class=\"br0\">(</span>void <span class=\"sy0\">*</span><span class=\"br0\">)</span> intPtr, TCL_LINK_INT<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">return</span> <span class=\"br0\">(</span>int<span class=\"br0\">)</span> intPtr<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"co1\"># A command to couple another Tcl variable to an 'integer object'; UNSAFE!</span><br/>critcl::<span class=\"me1\">cproc</span> linkagain<span class=\"br0\">(</span>Tcl_Interp<span class=\"sy0\">*</span> <span class=\"kw2\">interp</span> int addr char<span class=\"sy0\">*</span> var2<span class=\"br0\">}</span> void <span class=\"br0\">{</span><br/>    int <span class=\"sy0\">*</span>intPtr = <span class=\"br0\">(</span>int <span class=\"sy0\">*</span><span class=\"br0\">)</span> addr<span class=\"sy0\">;</span><br/>\u00a0<br/>    Tcl_LinkVar<span class=\"br0\">(</span><span class=\"kw2\">interp</span>, var2, <span class=\"br0\">(</span>void <span class=\"sy0\">*</span><span class=\"br0\">)</span> intPtr, TCL_LINK_INT<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"co1\"># Conventionally, programs that use critcl structure in packages</span><br/><span class=\"co1\"># This is used to prevent recompilation, especially on systems like Windows</span><br/><span class=\"kw2\">package</span> provide machAddrDemo <span class=\"nu0\">1</span></pre>"}, {"lang": "Tcl", "loc": 21, "block": "<pre class=\"tcl highlighted_source\"><span class=\"kw2\">package</span> require critcl<br/>\u00a0<br/><span class=\"co1\"># A command to 'make an integer object' and couple it to a Tcl variable</span><br/>critcl::<span class=\"me1\">cproc</span> linkvar <span class=\"br0\">{</span>Tcl_Interp<span class=\"sy0\">*</span> <span class=\"kw2\">interp</span> char<span class=\"sy0\">*</span> var1<span class=\"br0\">}</span> int <span class=\"br0\">{</span><br/>    int <span class=\"sy0\">*</span>intPtr = <span class=\"br0\">(</span>int <span class=\"sy0\">*</span><span class=\"br0\">)</span> ckalloc<span class=\"br0\">(</span>sizeof<span class=\"br0\">(</span>int<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"sy0\">*</span>intPtr = <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>    Tcl_LinkVar<span class=\"br0\">(</span><span class=\"kw2\">interp</span>, var1, <span class=\"br0\">(</span>void <span class=\"sy0\">*</span><span class=\"br0\">)</span> intPtr, TCL_LINK_INT<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">return</span> <span class=\"br0\">(</span>int<span class=\"br0\">)</span> intPtr<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"co1\"># A command to couple another Tcl variable to an 'integer object'; UNSAFE!</span><br/>critcl::<span class=\"me1\">cproc</span> linkagain<span class=\"br0\">(</span>Tcl_Interp<span class=\"sy0\">*</span> <span class=\"kw2\">interp</span> int addr char<span class=\"sy0\">*</span> var2<span class=\"br0\">}</span> void <span class=\"br0\">{</span><br/>    int <span class=\"sy0\">*</span>intPtr = <span class=\"br0\">(</span>int <span class=\"sy0\">*</span><span class=\"br0\">)</span> addr<span class=\"sy0\">;</span><br/>\u00a0<br/>    Tcl_LinkVar<span class=\"br0\">(</span><span class=\"kw2\">interp</span>, var2, <span class=\"br0\">(</span>void <span class=\"sy0\">*</span><span class=\"br0\">)</span> intPtr, TCL_LINK_INT<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"co1\"># Conventionally, programs that use critcl structure in packages</span><br/><span class=\"co1\"># This is used to prevent recompilation, especially on systems like Windows</span><br/><span class=\"kw2\">package</span> provide machAddrDemo <span class=\"nu0\">1</span></pre>"}]}