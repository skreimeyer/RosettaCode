{"task": "K-means%2B%2B_clustering", "blocks": [{"lang": "C", "loc": 183, "block": "<pre class=\"c highlighted_source\"><span class=\"co2\">#include &lt;stdio.h&gt;</span><br/><span class=\"co2\">#include &lt;stdlib.h&gt;</span><br/><span class=\"co2\">#include &lt;math.h&gt;</span><br/>\u00a0<br/><span class=\"kw4\">typedef</span> <span class=\"kw4\">struct</span> <span class=\"br0\">{</span> <span class=\"kw4\">double</span> x<span class=\"sy0\">,</span> y<span class=\"sy0\">;</span> <span class=\"kw4\">int</span> group<span class=\"sy0\">;</span> <span class=\"br0\">}</span> point_t<span class=\"sy0\">,</span> <span class=\"sy0\">*</span>point<span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"kw4\">double</span> randf<span class=\"br0\">(</span><span class=\"kw4\">double</span> m<span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>\t<span class=\"kw1\">return</span> m <span class=\"sy0\">*</span> <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/rand.html\"><span class=\"kw3\">rand</span></a><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">/</span> <span class=\"br0\">(</span>RAND_MAX <span class=\"sy0\">-</span> <span class=\"nu0\">1</span>.<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/>point gen_xy<span class=\"br0\">(</span><span class=\"kw4\">int</span> count<span class=\"sy0\">,</span> <span class=\"kw4\">double</span> radius<span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>\t<span class=\"kw4\">double</span> ang<span class=\"sy0\">,</span> r<span class=\"sy0\">;</span><br/>\tpoint p<span class=\"sy0\">,</span> pt <span class=\"sy0\">=</span> <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html\"><span class=\"kw3\">malloc</span></a><span class=\"br0\">(</span><span class=\"kw4\">sizeof</span><span class=\"br0\">(</span>point_t<span class=\"br0\">)</span> <span class=\"sy0\">*</span> count<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\t<span class=\"coMULTI\">/* note: this is not a uniform 2-d distribution */</span><br/>\t<span class=\"kw1\">for</span> <span class=\"br0\">(</span>p <span class=\"sy0\">=</span> pt <span class=\"sy0\">+</span> count<span class=\"sy0\">;</span> p<span class=\"sy0\">--</span> <span class=\"sy0\">&gt;</span> pt<span class=\"sy0\">;</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>\t\tang <span class=\"sy0\">=</span> randf<span class=\"br0\">(</span><span class=\"nu0\">2</span> <span class=\"sy0\">*</span> M_PI<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t\tr <span class=\"sy0\">=</span> randf<span class=\"br0\">(</span>radius<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t\tp<span class=\"sy0\">-&gt;</span>x <span class=\"sy0\">=</span> r <span class=\"sy0\">*</span> <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/cos.html\"><span class=\"kw3\">cos</span></a><span class=\"br0\">(</span>ang<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t\tp<span class=\"sy0\">-&gt;</span>y <span class=\"sy0\">=</span> r <span class=\"sy0\">*</span> <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/sin.html\"><span class=\"kw3\">sin</span></a><span class=\"br0\">(</span>ang<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t<span class=\"br0\">}</span><br/>\u00a0<br/>\t<span class=\"kw1\">return</span> pt<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw2\">inline</span> <span class=\"kw4\">double</span> dist2<span class=\"br0\">(</span>point a<span class=\"sy0\">,</span> point b<span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>\t<span class=\"kw4\">double</span> x <span class=\"sy0\">=</span> a<span class=\"sy0\">-&gt;</span>x <span class=\"sy0\">-</span> b<span class=\"sy0\">-&gt;</span>x<span class=\"sy0\">,</span> y <span class=\"sy0\">=</span> a<span class=\"sy0\">-&gt;</span>y <span class=\"sy0\">-</span> b<span class=\"sy0\">-&gt;</span>y<span class=\"sy0\">;</span><br/>\t<span class=\"kw1\">return</span> x<span class=\"sy0\">*</span>x <span class=\"sy0\">+</span> y<span class=\"sy0\">*</span>y<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw2\">inline</span> <span class=\"kw4\">int</span><br/>nearest<span class=\"br0\">(</span>point pt<span class=\"sy0\">,</span> point cent<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> n_cluster<span class=\"sy0\">,</span> <span class=\"kw4\">double</span> <span class=\"sy0\">*</span>d2<span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>\t<span class=\"kw4\">int</span> i<span class=\"sy0\">,</span> min_i<span class=\"sy0\">;</span><br/>\tpoint c<span class=\"sy0\">;</span><br/>\t<span class=\"kw4\">double</span> d<span class=\"sy0\">,</span> min_d<span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"co2\">#\tdefine for_n for (c = cent, i = 0; i &lt; n_cluster; i++, c++)</span><br/>\tfor_n <span class=\"br0\">{</span><br/>\t\tmin_d <span class=\"sy0\">=</span> HUGE_VAL<span class=\"sy0\">;</span><br/>\t\tmin_i <span class=\"sy0\">=</span> pt<span class=\"sy0\">-&gt;</span>group<span class=\"sy0\">;</span><br/>\t\tfor_n <span class=\"br0\">{</span><br/>\t\t\t<span class=\"kw1\">if</span> <span class=\"br0\">(</span>min_d <span class=\"sy0\">&gt;</span> <span class=\"br0\">(</span>d <span class=\"sy0\">=</span> dist2<span class=\"br0\">(</span>c<span class=\"sy0\">,</span> pt<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>\t\t\t\tmin_d <span class=\"sy0\">=</span> d<span class=\"sy0\">;</span> min_i <span class=\"sy0\">=</span> i<span class=\"sy0\">;</span><br/>\t\t\t<span class=\"br0\">}</span><br/>\t\t<span class=\"br0\">}</span><br/>\t<span class=\"br0\">}</span><br/>\t<span class=\"kw1\">if</span> <span class=\"br0\">(</span>d2<span class=\"br0\">)</span> <span class=\"sy0\">*</span>d2 <span class=\"sy0\">=</span> min_d<span class=\"sy0\">;</span><br/>\t<span class=\"kw1\">return</span> min_i<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw4\">void</span> kpp<span class=\"br0\">(</span>point pts<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> len<span class=\"sy0\">,</span> point cent<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> n_cent<span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/><span class=\"co2\">#\tdefine for_len for (j = 0, p = pts; j &lt; len; j++, p++)</span><br/>\t<span class=\"kw4\">int</span> i<span class=\"sy0\">,</span> j<span class=\"sy0\">;</span><br/>\t<span class=\"kw4\">int</span> n_cluster<span class=\"sy0\">;</span><br/>\t<span class=\"kw4\">double</span> sum<span class=\"sy0\">,</span> <span class=\"sy0\">*</span>d <span class=\"sy0\">=</span> <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html\"><span class=\"kw3\">malloc</span></a><span class=\"br0\">(</span><span class=\"kw4\">sizeof</span><span class=\"br0\">(</span><span class=\"kw4\">double</span><span class=\"br0\">)</span> <span class=\"sy0\">*</span> len<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\tpoint p<span class=\"sy0\">,</span> c<span class=\"sy0\">;</span><br/>\tcent<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> pts<span class=\"br0\">[</span> <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/rand.html\"><span class=\"kw3\">rand</span></a><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">%</span> len <span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>\t<span class=\"kw1\">for</span> <span class=\"br0\">(</span>n_cluster <span class=\"sy0\">=</span> <span class=\"nu0\">1</span><span class=\"sy0\">;</span> n_cluster <span class=\"sy0\">&lt;</span> n_cent<span class=\"sy0\">;</span> n_cluster<span class=\"sy0\">++</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>\t\tsum <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>\t\tfor_len <span class=\"br0\">{</span><br/>\t\t\tnearest<span class=\"br0\">(</span>p<span class=\"sy0\">,</span> cent<span class=\"sy0\">,</span> n_cluster<span class=\"sy0\">,</span> d <span class=\"sy0\">+</span> j<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t\t\tsum <span class=\"sy0\">+=</span> d<span class=\"br0\">[</span>j<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>\t\t<span class=\"br0\">}</span><br/>\t\tsum <span class=\"sy0\">=</span> randf<span class=\"br0\">(</span>sum<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t\tfor_len <span class=\"br0\">{</span><br/>\t\t\t<span class=\"kw1\">if</span> <span class=\"br0\">(</span><span class=\"br0\">(</span>sum <span class=\"sy0\">-=</span> d<span class=\"br0\">[</span>j<span class=\"br0\">]</span><span class=\"br0\">)</span> <span class=\"sy0\">&gt;</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span> <span class=\"kw1\">continue</span><span class=\"sy0\">;</span><br/>\t\t\tcent<span class=\"br0\">[</span>n_cluster<span class=\"br0\">]</span> <span class=\"sy0\">=</span> pts<span class=\"br0\">[</span>j<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>\t\t\t<span class=\"kw2\">break</span><span class=\"sy0\">;</span><br/>\t\t<span class=\"br0\">}</span><br/>\t<span class=\"br0\">}</span><br/>\tfor_len p<span class=\"sy0\">-&gt;</span>group <span class=\"sy0\">=</span> nearest<span class=\"br0\">(</span>p<span class=\"sy0\">,</span> cent<span class=\"sy0\">,</span> n_cluster<span class=\"sy0\">,</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t<a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/free.html\"><span class=\"kw3\">free</span></a><span class=\"br0\">(</span>d<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/>point lloyd<span class=\"br0\">(</span>point pts<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> len<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> n_cluster<span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>\t<span class=\"kw4\">int</span> i<span class=\"sy0\">,</span> j<span class=\"sy0\">,</span> min_i<span class=\"sy0\">;</span><br/>\t<span class=\"kw4\">int</span> changed<span class=\"sy0\">;</span><br/>\u00a0<br/>\tpoint cent <span class=\"sy0\">=</span> <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html\"><span class=\"kw3\">malloc</span></a><span class=\"br0\">(</span><span class=\"kw4\">sizeof</span><span class=\"br0\">(</span>point_t<span class=\"br0\">)</span> <span class=\"sy0\">*</span> n_cluster<span class=\"br0\">)</span><span class=\"sy0\">,</span> p<span class=\"sy0\">,</span> c<span class=\"sy0\">;</span><br/>\u00a0<br/>\t<span class=\"coMULTI\">/* assign init grouping randomly */</span><br/>\t<span class=\"co1\">//for_len p-&gt;group = j\u00a0% n_cluster;</span><br/>\u00a0<br/>\t<span class=\"coMULTI\">/* or call k++ init */</span><br/>\tkpp<span class=\"br0\">(</span>pts<span class=\"sy0\">,</span> len<span class=\"sy0\">,</span> cent<span class=\"sy0\">,</span> n_cluster<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\t<span class=\"kw1\">do</span> <span class=\"br0\">{</span><br/>\t\t<span class=\"coMULTI\">/* group element for centroids are used as counters */</span><br/>\t\tfor_n <span class=\"br0\">{</span> c<span class=\"sy0\">-&gt;</span>group <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> c<span class=\"sy0\">-&gt;</span>x <span class=\"sy0\">=</span> c<span class=\"sy0\">-&gt;</span>y <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> <span class=\"br0\">}</span><br/>\t\tfor_len <span class=\"br0\">{</span><br/>\t\t\tc <span class=\"sy0\">=</span> cent <span class=\"sy0\">+</span> p<span class=\"sy0\">-&gt;</span>group<span class=\"sy0\">;</span><br/>\t\t\tc<span class=\"sy0\">-&gt;</span>group<span class=\"sy0\">++;</span><br/>\t\t\tc<span class=\"sy0\">-&gt;</span>x <span class=\"sy0\">+=</span> p<span class=\"sy0\">-&gt;</span>x<span class=\"sy0\">;</span> c<span class=\"sy0\">-&gt;</span>y <span class=\"sy0\">+=</span> p<span class=\"sy0\">-&gt;</span>y<span class=\"sy0\">;</span><br/>\t\t<span class=\"br0\">}</span><br/>\t\tfor_n <span class=\"br0\">{</span> c<span class=\"sy0\">-&gt;</span>x <span class=\"sy0\">/=</span> c<span class=\"sy0\">-&gt;</span>group<span class=\"sy0\">;</span> c<span class=\"sy0\">-&gt;</span>y <span class=\"sy0\">/=</span> c<span class=\"sy0\">-&gt;</span>group<span class=\"sy0\">;</span> <span class=\"br0\">}</span><br/>\u00a0<br/>\t\tchanged <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>\t\t<span class=\"coMULTI\">/* find closest centroid of each point */</span><br/>\t\tfor_len <span class=\"br0\">{</span><br/>\t\t\tmin_i <span class=\"sy0\">=</span> nearest<span class=\"br0\">(</span>p<span class=\"sy0\">,</span> cent<span class=\"sy0\">,</span> n_cluster<span class=\"sy0\">,</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t\t\t<span class=\"kw1\">if</span> <span class=\"br0\">(</span>min_i <span class=\"sy0\">!=</span> p<span class=\"sy0\">-&gt;</span>group<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>\t\t\t\tchanged<span class=\"sy0\">++;</span><br/>\t\t\t\tp<span class=\"sy0\">-&gt;</span>group <span class=\"sy0\">=</span> min_i<span class=\"sy0\">;</span><br/>\t\t\t<span class=\"br0\">}</span><br/>\t\t<span class=\"br0\">}</span><br/>\t<span class=\"br0\">}</span> <span class=\"kw1\">while</span> <span class=\"br0\">(</span>changed <span class=\"sy0\">&gt;</span> <span class=\"br0\">(</span>len <span class=\"sy0\">&gt;&gt;</span> <span class=\"nu0\">10</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"coMULTI\">/* stop when 99.9% of points are good */</span><br/>\u00a0<br/>\tfor_n <span class=\"br0\">{</span> c<span class=\"sy0\">-&gt;</span>group <span class=\"sy0\">=</span> i<span class=\"sy0\">;</span> <span class=\"br0\">}</span><br/>\u00a0<br/>\t<span class=\"kw1\">return</span> cent<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw4\">void</span> print_eps<span class=\"br0\">(</span>point pts<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> len<span class=\"sy0\">,</span> point cent<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> n_cluster<span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/><span class=\"co2\">#\tdefine W 400</span><br/><span class=\"co2\">#\tdefine H 400</span><br/>\t<span class=\"kw4\">int</span> i<span class=\"sy0\">,</span> j<span class=\"sy0\">;</span><br/>\tpoint p<span class=\"sy0\">,</span> c<span class=\"sy0\">;</span><br/>\t<span class=\"kw4\">double</span> min_x<span class=\"sy0\">,</span> max_x<span class=\"sy0\">,</span> min_y<span class=\"sy0\">,</span> max_y<span class=\"sy0\">,</span> scale<span class=\"sy0\">,</span> cx<span class=\"sy0\">,</span> cy<span class=\"sy0\">;</span><br/>\t<span class=\"kw4\">double</span> <span class=\"sy0\">*</span>colors <span class=\"sy0\">=</span> <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/malloc.html\"><span class=\"kw3\">malloc</span></a><span class=\"br0\">(</span><span class=\"kw4\">sizeof</span><span class=\"br0\">(</span><span class=\"kw4\">double</span><span class=\"br0\">)</span> <span class=\"sy0\">*</span> n_cluster <span class=\"sy0\">*</span> <span class=\"nu0\">3</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\tfor_n <span class=\"br0\">{</span><br/>\t\tcolors<span class=\"br0\">[</span><span class=\"nu0\">3</span><span class=\"sy0\">*</span>i <span class=\"sy0\">+</span> <span class=\"nu0\">0</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"br0\">(</span><span class=\"nu0\">3</span> <span class=\"sy0\">*</span> <span class=\"br0\">(</span>i <span class=\"sy0\">+</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"sy0\">%</span> <span class=\"nu0\">11</span><span class=\"br0\">)</span><span class=\"sy0\">/</span><span class=\"nu0\">11</span>.<span class=\"sy0\">;</span><br/>\t\tcolors<span class=\"br0\">[</span><span class=\"nu0\">3</span><span class=\"sy0\">*</span>i <span class=\"sy0\">+</span> <span class=\"nu0\">1</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"br0\">(</span><span class=\"nu0\">7</span> <span class=\"sy0\">*</span> i <span class=\"sy0\">%</span> <span class=\"nu0\">11</span><span class=\"br0\">)</span><span class=\"sy0\">/</span><span class=\"nu0\">11</span>.<span class=\"sy0\">;</span><br/>\t\tcolors<span class=\"br0\">[</span><span class=\"nu0\">3</span><span class=\"sy0\">*</span>i <span class=\"sy0\">+</span> <span class=\"nu0\">2</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"br0\">(</span><span class=\"nu0\">9</span> <span class=\"sy0\">*</span> i <span class=\"sy0\">%</span> <span class=\"nu0\">11</span><span class=\"br0\">)</span><span class=\"sy0\">/</span><span class=\"nu0\">11</span>.<span class=\"sy0\">;</span><br/>\t<span class=\"br0\">}</span><br/>\u00a0<br/>\tmax_x <span class=\"sy0\">=</span> max_y <span class=\"sy0\">=</span> <span class=\"sy0\">-</span><span class=\"br0\">(</span>min_x <span class=\"sy0\">=</span> min_y <span class=\"sy0\">=</span> HUGE_VAL<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\tfor_len <span class=\"br0\">{</span><br/>\t\t<span class=\"kw1\">if</span> <span class=\"br0\">(</span>max_x <span class=\"sy0\">&lt;</span> p<span class=\"sy0\">-&gt;</span>x<span class=\"br0\">)</span> max_x <span class=\"sy0\">=</span> p<span class=\"sy0\">-&gt;</span>x<span class=\"sy0\">;</span><br/>\t\t<span class=\"kw1\">if</span> <span class=\"br0\">(</span>min_x <span class=\"sy0\">&gt;</span> p<span class=\"sy0\">-&gt;</span>x<span class=\"br0\">)</span> min_x <span class=\"sy0\">=</span> p<span class=\"sy0\">-&gt;</span>x<span class=\"sy0\">;</span><br/>\t\t<span class=\"kw1\">if</span> <span class=\"br0\">(</span>max_y <span class=\"sy0\">&lt;</span> p<span class=\"sy0\">-&gt;</span>y<span class=\"br0\">)</span> max_y <span class=\"sy0\">=</span> p<span class=\"sy0\">-&gt;</span>y<span class=\"sy0\">;</span><br/>\t\t<span class=\"kw1\">if</span> <span class=\"br0\">(</span>min_y <span class=\"sy0\">&gt;</span> p<span class=\"sy0\">-&gt;</span>y<span class=\"br0\">)</span> min_y <span class=\"sy0\">=</span> p<span class=\"sy0\">-&gt;</span>y<span class=\"sy0\">;</span><br/>\t<span class=\"br0\">}</span><br/>\tscale <span class=\"sy0\">=</span> W <span class=\"sy0\">/</span> <span class=\"br0\">(</span>max_x <span class=\"sy0\">-</span> min_x<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t<span class=\"kw1\">if</span> <span class=\"br0\">(</span>scale <span class=\"sy0\">&gt;</span> H <span class=\"sy0\">/</span> <span class=\"br0\">(</span>max_y <span class=\"sy0\">-</span> min_y<span class=\"br0\">)</span><span class=\"br0\">)</span> scale <span class=\"sy0\">=</span> H <span class=\"sy0\">/</span> <span class=\"br0\">(</span>max_y <span class=\"sy0\">-</span> min_y<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\tcx <span class=\"sy0\">=</span> <span class=\"br0\">(</span>max_x <span class=\"sy0\">+</span> min_x<span class=\"br0\">)</span> <span class=\"sy0\">/</span> <span class=\"nu0\">2</span><span class=\"sy0\">;</span><br/>\tcy <span class=\"sy0\">=</span> <span class=\"br0\">(</span>max_y <span class=\"sy0\">+</span> min_y<span class=\"br0\">)</span> <span class=\"sy0\">/</span> <span class=\"nu0\">2</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\t<a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/printf.html\"><span class=\"kw3\">printf</span></a><span class=\"br0\">(</span><span class=\"st0\">\"%%!PS-Adobe-3.0<span class=\"es1\">\\n</span>%%%%BoundingBox: -5 -5\u00a0%d\u00a0%d<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span> W <span class=\"sy0\">+</span> <span class=\"nu0\">10</span><span class=\"sy0\">,</span> H <span class=\"sy0\">+</span> <span class=\"nu0\">10</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t<a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/printf.html\"><span class=\"kw3\">printf</span></a><span class=\"br0\">(</span> <span class=\"st0\">\"/l {rlineto} def /m {rmoveto} def<span class=\"es1\">\\n</span>\"</span><br/>\t\t<span class=\"st0\">\"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def<span class=\"es1\">\\n</span>\"</span><br/>\t\t<span class=\"st0\">\"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \"</span><br/>\t\t<span class=\"st0\">\"\tgsave 1 setgray fill grestore gsave 3 setlinewidth\"</span><br/>\t\t<span class=\"st0\">\" 1 setgray stroke grestore 0 setgray stroke }def<span class=\"es1\">\\n</span>\"</span><br/>\t<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\tfor_n <span class=\"br0\">{</span><br/>\t\t<a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/printf.html\"><span class=\"kw3\">printf</span></a><span class=\"br0\">(</span><span class=\"st0\">\"%g\u00a0%g\u00a0%g setrgbcolor<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span><br/>\t\t\tcolors<span class=\"br0\">[</span><span class=\"nu0\">3</span><span class=\"sy0\">*</span>i<span class=\"br0\">]</span><span class=\"sy0\">,</span> colors<span class=\"br0\">[</span><span class=\"nu0\">3</span><span class=\"sy0\">*</span>i <span class=\"sy0\">+</span> <span class=\"nu0\">1</span><span class=\"br0\">]</span><span class=\"sy0\">,</span> colors<span class=\"br0\">[</span><span class=\"nu0\">3</span><span class=\"sy0\">*</span>i <span class=\"sy0\">+</span> <span class=\"nu0\">2</span><span class=\"br0\">]</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t\tfor_len <span class=\"br0\">{</span><br/>\t\t\t<span class=\"kw1\">if</span> <span class=\"br0\">(</span>p<span class=\"sy0\">-&gt;</span>group <span class=\"sy0\">!=</span> i<span class=\"br0\">)</span> <span class=\"kw1\">continue</span><span class=\"sy0\">;</span><br/>\t\t\t<a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/printf.html\"><span class=\"kw3\">printf</span></a><span class=\"br0\">(</span><span class=\"st0\">\"%.3f\u00a0%.3f c<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span><br/>\t\t\t\t<span class=\"br0\">(</span>p<span class=\"sy0\">-&gt;</span>x <span class=\"sy0\">-</span> cx<span class=\"br0\">)</span> <span class=\"sy0\">*</span> scale <span class=\"sy0\">+</span> W <span class=\"sy0\">/</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span><br/>\t\t\t\t<span class=\"br0\">(</span>p<span class=\"sy0\">-&gt;</span>y <span class=\"sy0\">-</span> cy<span class=\"br0\">)</span> <span class=\"sy0\">*</span> scale <span class=\"sy0\">+</span> H <span class=\"sy0\">/</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t\t<span class=\"br0\">}</span><br/>\t\t<a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/printf.html\"><span class=\"kw3\">printf</span></a><span class=\"br0\">(</span><span class=\"st0\">\"<span class=\"es1\">\\n</span>0 setgray\u00a0%g\u00a0%g s<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span><br/>\t\t\t<span class=\"br0\">(</span>c<span class=\"sy0\">-&gt;</span>x <span class=\"sy0\">-</span> cx<span class=\"br0\">)</span> <span class=\"sy0\">*</span> scale <span class=\"sy0\">+</span> W <span class=\"sy0\">/</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span><br/>\t\t\t<span class=\"br0\">(</span>c<span class=\"sy0\">-&gt;</span>y <span class=\"sy0\">-</span> cy<span class=\"br0\">)</span> <span class=\"sy0\">*</span> scale <span class=\"sy0\">+</span> H <span class=\"sy0\">/</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t<span class=\"br0\">}</span><br/>\t<a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/printf.html\"><span class=\"kw3\">printf</span></a><span class=\"br0\">(</span><span class=\"st0\">\"<span class=\"es1\">\\n</span>%%%%EOF\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t<a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/free.html\"><span class=\"kw3\">free</span></a><span class=\"br0\">(</span>colors<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"co2\">#\tundef for_n</span><br/><span class=\"co2\">#\tundef for_len</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"co2\">#define PTS 100000</span><br/><span class=\"co2\">#define K 11</span><br/><span class=\"kw4\">int</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>\t<span class=\"kw4\">int</span> i<span class=\"sy0\">;</span><br/>\tpoint v <span class=\"sy0\">=</span> gen_xy<span class=\"br0\">(</span>PTS<span class=\"sy0\">,</span> <span class=\"nu0\">10</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\tpoint c <span class=\"sy0\">=</span> lloyd<span class=\"br0\">(</span>v<span class=\"sy0\">,</span> PTS<span class=\"sy0\">,</span> K<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\tprint_eps<span class=\"br0\">(</span>v<span class=\"sy0\">,</span> PTS<span class=\"sy0\">,</span> c<span class=\"sy0\">,</span> K<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t<span class=\"co1\">// free(v); free(c);</span><br/>\t<span class=\"kw1\">return</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "D", "loc": 247, "block": "<pre class=\"d highlighted_source\"><span class=\"kw2\">import</span> std.<span class=\"me1\">stdio</span><span class=\"sy0\">,</span> std.<span class=\"me1\">math</span><span class=\"sy0\">,</span> std.<span class=\"me1\">random</span><span class=\"sy0\">,</span> std.<span class=\"me1\">typecons</span><span class=\"sy0\">,</span> std.<span class=\"me1\">algorithm</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"co1\">// On Windows this uses the printf from the Microsoft C runtime,</span><br/><span class=\"co1\">// that doesn't handle real type and some of the C99 format</span><br/><span class=\"co1\">// specifiers, but it's faster for bulk printing.</span><br/><span class=\"kw2\">extern</span><span class=\"br0\">(</span>C<span class=\"br0\">)</span> <span class=\"kw4\">nothrow</span> <span class=\"kw4\">int</span> printf<span class=\"br0\">(</span><span class=\"kw4\">const</span> <span class=\"kw4\">char</span><span class=\"sy0\">*,</span> <span class=\"sy0\">...</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"kw4\">struct</span> Point <span class=\"br0\">{</span><br/>    <span class=\"kw4\">immutable</span> <span class=\"kw4\">double</span> x<span class=\"sy0\">,</span> y<span class=\"sy0\">;</span> <span class=\"co1\">// Or float.</span><br/>    <span class=\"kw4\">size_t</span> cluster<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/>Point<span class=\"br0\">[</span><span class=\"br0\">]</span> generatePoints<span class=\"br0\">(</span><span class=\"kw2\">in</span> <span class=\"kw4\">size_t</span> nPoints<span class=\"sy0\">,</span><br/>                       <span class=\"kw2\">in</span> <span class=\"kw4\">double</span> radius<span class=\"sy0\">,</span><br/>                       <span class=\"kw2\">ref</span> Xorshift rnd<span class=\"br0\">)</span><br/><span class=\"kw2\">in</span> <span class=\"br0\">{</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>nPoints <span class=\"sy0\">&gt;</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>radius <span class=\"sy0\">&gt;</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span> <span class=\"kw2\">out</span><span class=\"br0\">(</span>result<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>result.<span class=\"me1\">length</span> <span class=\"sy0\">==</span> nPoints<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">const</span> <span class=\"kw2\">ref</span> p<span class=\"sy0\">;</span> result<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw2\">assert</span><span class=\"br0\">(</span>p.<span class=\"me1\">cluster</span> <span class=\"sy0\">==</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"kw2\">assert</span><span class=\"br0\">(</span><span class=\"sy0\">!</span>p.<span class=\"me1\">x</span>.<span class=\"me1\">isNaN</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"sy0\">!</span>p.<span class=\"me1\">y</span>.<span class=\"me1\">isNaN</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/><span class=\"br0\">}</span> <span class=\"kw2\">body</span> <span class=\"br0\">{</span><br/>    Point<span class=\"br0\">[</span><span class=\"br0\">]</span> points<span class=\"sy0\">;</span><br/>    points.<span class=\"me1\">reserve</span><span class=\"br0\">(</span>nPoints<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"co1\">// This is not a uniform 2D distribution.</span><br/>    <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">immutable</span> i<span class=\"sy0\">;</span> <span class=\"nu0\">0</span> <span class=\"sy0\">..</span> <span class=\"me1\">nPoints</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw4\">immutable</span> r <span class=\"sy0\">=</span> uniform<span class=\"br0\">(</span><span class=\"nu16\">0.0</span><span class=\"sy0\">,</span> radius<span class=\"sy0\">,</span> rnd<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"kw4\">immutable</span> ang <span class=\"sy0\">=</span> uniform<span class=\"br0\">(</span><span class=\"nu16\">0.0</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span> <span class=\"sy0\">*</span> PI<span class=\"sy0\">,</span> rnd<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        points <span class=\"sy0\">~=</span> Point<span class=\"br0\">(</span>r <span class=\"sy0\">*</span> ang.<span class=\"me1\">cos</span><span class=\"sy0\">,</span> r <span class=\"sy0\">*</span> ang.<span class=\"me1\">sin</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">// Sincos?</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"kw1\">return</span> points<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/>\u00a0<br/><span class=\"kw4\">struct</span> ClusterCenter <span class=\"br0\">{</span><br/>    <span class=\"kw4\">double</span> x<span class=\"sy0\">,</span> y<span class=\"sy0\">;</span><br/>    <span class=\"kw4\">void</span> opAssign<span class=\"br0\">(</span><span class=\"kw2\">in</span> <span class=\"kw2\">ref</span> Point p<span class=\"br0\">)</span> <span class=\"kw4\">pure</span> <span class=\"kw4\">nothrow</span> @nogc <span class=\"br0\">{</span><br/>        <span class=\"kw2\">this</span>.<span class=\"me1\">x</span> <span class=\"sy0\">=</span> p.<span class=\"me1\">x</span><span class=\"sy0\">;</span><br/>        <span class=\"kw2\">this</span>.<span class=\"me1\">y</span> <span class=\"sy0\">=</span> p.<span class=\"me1\">y</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/>\u00a0<br/><span class=\"kw4\">const</span><span class=\"br0\">(</span>ClusterCenter<span class=\"br0\">)</span><span class=\"br0\">[</span><span class=\"br0\">]</span> lloyd<span class=\"br0\">(</span>Point<span class=\"br0\">[</span><span class=\"br0\">]</span> points<span class=\"sy0\">,</span><br/>                             <span class=\"kw2\">in</span> <span class=\"kw4\">size_t</span> nclusters<span class=\"sy0\">,</span><br/>                             <span class=\"kw2\">ref</span> Xorshift rnd<span class=\"br0\">)</span><br/><span class=\"kw2\">in</span> <span class=\"br0\">{</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>points.<span class=\"me1\">length</span> <span class=\"sy0\">&gt;=</span> nclusters<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>nclusters <span class=\"sy0\">&gt;</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">const</span> <span class=\"kw2\">ref</span> p<span class=\"sy0\">;</span> points<span class=\"br0\">)</span><br/>        <span class=\"kw2\">assert</span><span class=\"br0\">(</span><span class=\"sy0\">!</span>p.<span class=\"me1\">x</span>.<span class=\"me1\">isNaN</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"sy0\">!</span>p.<span class=\"me1\">y</span>.<span class=\"me1\">isNaN</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span> <span class=\"kw2\">out</span><span class=\"br0\">(</span>result<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>result.<span class=\"me1\">length</span> <span class=\"sy0\">==</span> nclusters<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">const</span> <span class=\"kw2\">ref</span> cc<span class=\"sy0\">;</span> result<span class=\"br0\">)</span><br/>        <span class=\"kw2\">assert</span><span class=\"br0\">(</span><span class=\"sy0\">!</span>cc.<span class=\"me1\">x</span>.<span class=\"me1\">isNaN</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"sy0\">!</span>cc.<span class=\"me1\">y</span>.<span class=\"me1\">isNaN</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span> <span class=\"kw2\">body</span> <span class=\"br0\">{</span><br/>    <span class=\"co2\">/// Distance and index of the closest cluster center.</span><br/>    <span class=\"kw4\">static</span> Tuple<span class=\"sy0\">!</span><span class=\"br0\">(</span><span class=\"kw4\">size_t</span><span class=\"sy0\">,</span> <span class=\"kw4\">double</span><span class=\"br0\">)</span><br/>    nearestClusterCenter<span class=\"br0\">(</span><span class=\"kw2\">in</span> <span class=\"kw2\">ref</span> Point point<span class=\"sy0\">,</span><br/>                         <span class=\"kw2\">in</span> ClusterCenter<span class=\"br0\">[</span><span class=\"br0\">]</span> centers<span class=\"br0\">)</span> <span class=\"kw4\">pure</span> <span class=\"kw4\">nothrow</span> @nogc<br/>    <span class=\"kw2\">in</span> <span class=\"br0\">{</span><br/>        <span class=\"kw2\">assert</span><span class=\"br0\">(</span>centers.<span class=\"me1\">length</span> <span class=\"sy0\">&gt;</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span> <span class=\"kw2\">out</span><span class=\"br0\">(</span>result<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw2\">assert</span><span class=\"br0\">(</span>result<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span> <span class=\"sy0\">&lt;</span> centers.<span class=\"me1\">length</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"kw4\">immutable</span> ClusterCenter c <span class=\"sy0\">=</span> centers<span class=\"br0\">[</span>result<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>        <span class=\"kw4\">immutable</span> d <span class=\"sy0\">=</span> <span class=\"br0\">(</span>c.<span class=\"me1\">x</span> <span class=\"sy0\">-</span> point.<span class=\"me1\">x</span><span class=\"br0\">)</span> <span class=\"sy0\">^^</span> <span class=\"nu0\">2</span>  <span class=\"sy0\">+</span>  <span class=\"br0\">(</span>c.<span class=\"me1\">y</span> <span class=\"sy0\">-</span> point.<span class=\"me1\">y</span><span class=\"br0\">)</span> <span class=\"sy0\">^^</span> <span class=\"nu0\">2</span><span class=\"sy0\">;</span><br/>        <span class=\"kw2\">assert</span><span class=\"br0\">(</span>feqrel<span class=\"br0\">(</span>result<span class=\"br0\">[</span><span class=\"nu0\">1</span><span class=\"br0\">]</span><span class=\"sy0\">,</span> d<span class=\"br0\">)</span> <span class=\"sy0\">&gt;</span> <span class=\"nu0\">45</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">// Arbitrary.</span><br/>    <span class=\"br0\">}</span> <span class=\"kw2\">body</span> <span class=\"br0\">{</span><br/>        <span class=\"kw4\">static</span> <span class=\"kw4\">double</span> sqrDistance2D<span class=\"br0\">(</span><span class=\"kw2\">in</span> <span class=\"kw2\">ref</span> ClusterCenter a<span class=\"sy0\">,</span><br/>                                    <span class=\"kw2\">in</span> <span class=\"kw2\">ref</span> Point b<span class=\"br0\">)</span> <span class=\"kw4\">pure</span> <span class=\"kw4\">nothrow</span> @nogc<span class=\"br0\">{</span><br/>            <span class=\"kw1\">return</span> <span class=\"br0\">(</span>a.<span class=\"me1\">x</span> <span class=\"sy0\">-</span> b.<span class=\"me1\">x</span><span class=\"br0\">)</span> <span class=\"sy0\">^^</span> <span class=\"nu0\">2</span> <span class=\"sy0\">+</span> <span class=\"br0\">(</span>a.<span class=\"me1\">y</span> <span class=\"sy0\">-</span> b.<span class=\"me1\">y</span><span class=\"br0\">)</span> <span class=\"sy0\">^^</span> <span class=\"nu0\">2</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw4\">size_t</span> minIndex <span class=\"sy0\">=</span> point.<span class=\"me1\">cluster</span><span class=\"sy0\">;</span><br/>        <span class=\"kw4\">double</span> minDist <span class=\"sy0\">=</span> <span class=\"kw4\">double</span>.<span class=\"me1\">max</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">immutable</span> i<span class=\"sy0\">,</span> <span class=\"kw4\">const</span> <span class=\"kw2\">ref</span> cc<span class=\"sy0\">;</span> centers<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw4\">immutable</span> d <span class=\"sy0\">=</span> sqrDistance2D<span class=\"br0\">(</span>cc<span class=\"sy0\">,</span> point<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>minDist <span class=\"sy0\">&gt;</span> d<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                minDist <span class=\"sy0\">=</span> d<span class=\"sy0\">;</span><br/>                minIndex <span class=\"sy0\">=</span> i<span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">return</span> tuple<span class=\"br0\">(</span>minIndex<span class=\"sy0\">,</span> minDist<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>\u00a0<br/>    <span class=\"kw4\">static</span> <span class=\"kw4\">void</span> kMeansPP<span class=\"br0\">(</span>Point<span class=\"br0\">[</span><span class=\"br0\">]</span> points<span class=\"sy0\">,</span><br/>                         ClusterCenter<span class=\"br0\">[</span><span class=\"br0\">]</span> centers<span class=\"sy0\">,</span><br/>                         <span class=\"kw2\">ref</span> Xorshift rnd<span class=\"br0\">)</span><br/>    <span class=\"kw2\">in</span> <span class=\"br0\">{</span><br/>        <span class=\"kw2\">assert</span><span class=\"br0\">(</span>points.<span class=\"me1\">length</span> <span class=\"sy0\">&gt;=</span> centers.<span class=\"me1\">length</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"kw2\">assert</span><span class=\"br0\">(</span>centers.<span class=\"me1\">length</span> <span class=\"sy0\">&gt;</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span> <span class=\"kw2\">body</span> <span class=\"br0\">{</span><br/>        centers<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> points<span class=\"br0\">[</span>uniform<span class=\"br0\">(</span><span class=\"nu0\">0</span><span class=\"sy0\">,</span> $<span class=\"sy0\">,</span> rnd<span class=\"br0\">)</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>        <span class=\"kw4\">auto</span> d <span class=\"sy0\">=</span> <span class=\"kw2\">new</span> <span class=\"kw4\">double</span><span class=\"br0\">[</span>points.<span class=\"me1\">length</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">immutable</span> i<span class=\"sy0\">;</span> <span class=\"nu0\">1</span> <span class=\"sy0\">..</span> <span class=\"me1\">centers</span>.<span class=\"me1\">length</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw4\">double</span> sum <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">immutable</span> j<span class=\"sy0\">,</span> <span class=\"kw4\">const</span> <span class=\"kw2\">ref</span> p<span class=\"sy0\">;</span> points<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                d<span class=\"br0\">[</span>j<span class=\"br0\">]</span> <span class=\"sy0\">=</span> nearestClusterCenter<span class=\"br0\">(</span>p<span class=\"sy0\">,</span> centers<span class=\"br0\">[</span><span class=\"nu0\">0</span> <span class=\"sy0\">..</span> <span class=\"me1\">i</span><span class=\"br0\">]</span><span class=\"br0\">)</span><span class=\"br0\">[</span><span class=\"nu0\">1</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>                sum <span class=\"sy0\">+=</span> d<span class=\"br0\">[</span>j<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>\u00a0<br/>            sum <span class=\"sy0\">=</span> uniform<span class=\"br0\">(</span><span class=\"nu16\">0.0</span><span class=\"sy0\">,</span> sum<span class=\"sy0\">,</span> rnd<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>            <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">immutable</span> j<span class=\"sy0\">,</span> <span class=\"kw4\">immutable</span> dj<span class=\"sy0\">;</span> d<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                sum <span class=\"sy0\">-=</span> dj<span class=\"sy0\">;</span><br/>                <span class=\"kw1\">if</span> <span class=\"br0\">(</span>sum <span class=\"sy0\">&gt;</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><br/>                    <span class=\"kw1\">continue</span><span class=\"sy0\">;</span><br/>                centers<span class=\"br0\">[</span>i<span class=\"br0\">]</span> <span class=\"sy0\">=</span> points<span class=\"br0\">[</span>j<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>                <span class=\"kw1\">break</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw2\">ref</span> p<span class=\"sy0\">;</span> points<span class=\"br0\">)</span><br/>            <span class=\"co1\">// Implicit cast of Hconst!ClusterCenter</span><br/>            <span class=\"co1\">// to ClusterCenter[].</span><br/>            p.<span class=\"me1\">cluster</span> <span class=\"sy0\">=</span> nearestClusterCenter<span class=\"br0\">(</span>p<span class=\"sy0\">,</span> centers<span class=\"br0\">)</span><span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>\u00a0<br/>    <span class=\"kw4\">auto</span> centers <span class=\"sy0\">=</span> <span class=\"kw2\">new</span> ClusterCenter<span class=\"br0\">[</span>nclusters<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>    kMeansPP<span class=\"br0\">(</span>points<span class=\"sy0\">,</span> centers<span class=\"sy0\">,</span> rnd<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw4\">auto</span> clusterSizes <span class=\"sy0\">=</span> <span class=\"kw2\">new</span> <span class=\"kw4\">size_t</span><span class=\"br0\">[</span>centers.<span class=\"me1\">length</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"kw4\">size_t</span> changed<span class=\"sy0\">;</span><br/>    <span class=\"kw1\">do</span> <span class=\"br0\">{</span><br/>        <span class=\"co1\">// Find clusters centroids.</span><br/>        centers<span class=\"br0\">[</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> ClusterCenter<span class=\"br0\">(</span><span class=\"nu0\">0</span><span class=\"sy0\">,</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        clusterSizes<span class=\"br0\">[</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">immutable</span> i<span class=\"sy0\">,</span> <span class=\"kw4\">const</span> <span class=\"kw2\">ref</span> p<span class=\"sy0\">;</span> points<span class=\"br0\">)</span><br/>            <span class=\"kw2\">with</span> <span class=\"br0\">(</span>centers<span class=\"br0\">[</span>p.<span class=\"me1\">cluster</span><span class=\"br0\">]</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                clusterSizes<span class=\"br0\">[</span>p.<span class=\"me1\">cluster</span><span class=\"br0\">]</span><span class=\"sy0\">++;</span><br/>                x <span class=\"sy0\">+=</span> p.<span class=\"me1\">x</span><span class=\"sy0\">;</span><br/>                y <span class=\"sy0\">+=</span> p.<span class=\"me1\">y</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">immutable</span> i<span class=\"sy0\">,</span> <span class=\"kw2\">ref</span> cc<span class=\"sy0\">;</span> centers<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            cc.<span class=\"me1\">x</span> <span class=\"sy0\">/=</span> clusterSizes<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>            cc.<span class=\"me1\">y</span> <span class=\"sy0\">/=</span> clusterSizes<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"co1\">// Find closest centroid of each point.</span><br/>        changed <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw2\">ref</span> p<span class=\"sy0\">;</span> points<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw4\">immutable</span> minI <span class=\"sy0\">=</span> nearestClusterCenter<span class=\"br0\">(</span>p<span class=\"sy0\">,</span> centers<span class=\"br0\">)</span><span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>minI <span class=\"sy0\">!=</span> p.<span class=\"me1\">cluster</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                changed<span class=\"sy0\">++;</span><br/>                p.<span class=\"me1\">cluster</span> <span class=\"sy0\">=</span> minI<span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>        <span class=\"br0\">}</span><br/>    <span class=\"co1\">// Stop when 99.9% of points are good.</span><br/>    <span class=\"br0\">}</span> <span class=\"kw1\">while</span> <span class=\"br0\">(</span>changed <span class=\"sy0\">&gt;</span> <span class=\"br0\">(</span>points.<span class=\"me1\">length</span> <span class=\"sy0\">&gt;&gt;</span> <span class=\"nu0\">10</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"kw1\">return</span> centers<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/>\u00a0<br/><span class=\"kw4\">void</span> printEps<span class=\"br0\">(</span><span class=\"kw2\">in</span> Point<span class=\"br0\">[</span><span class=\"br0\">]</span> points<span class=\"sy0\">,</span> <span class=\"kw2\">in</span> ClusterCenter<span class=\"br0\">[</span><span class=\"br0\">]</span> centers<span class=\"sy0\">,</span><br/>              <span class=\"kw2\">in</span> <span class=\"kw4\">size_t</span> W <span class=\"sy0\">=</span> <span class=\"nu0\">400</span><span class=\"sy0\">,</span> <span class=\"kw2\">in</span> <span class=\"kw4\">size_t</span> H <span class=\"sy0\">=</span> <span class=\"nu0\">400</span><span class=\"br0\">)</span> <span class=\"kw4\">nothrow</span><br/><span class=\"kw2\">in</span> <span class=\"br0\">{</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>points.<span class=\"me1\">length</span> <span class=\"sy0\">&gt;=</span> centers.<span class=\"me1\">length</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>centers.<span class=\"me1\">length</span> <span class=\"sy0\">&gt;</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>W <span class=\"sy0\">&gt;</span> <span class=\"nu0\">0</span> <span class=\"sy0\">&amp;&amp;</span> H <span class=\"sy0\">&gt;</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">const</span> <span class=\"kw2\">ref</span> p<span class=\"sy0\">;</span> points<span class=\"br0\">)</span><br/>        <span class=\"kw2\">assert</span><span class=\"br0\">(</span><span class=\"sy0\">!</span>p.<span class=\"me1\">x</span>.<span class=\"me1\">isNaN</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"sy0\">!</span>p.<span class=\"me1\">y</span>.<span class=\"me1\">isNaN</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">const</span> <span class=\"kw2\">ref</span> cc<span class=\"sy0\">;</span> centers<span class=\"br0\">)</span><br/>        <span class=\"kw2\">assert</span><span class=\"br0\">(</span><span class=\"sy0\">!</span>cc.<span class=\"me1\">x</span>.<span class=\"me1\">isNaN</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"sy0\">!</span>cc.<span class=\"me1\">y</span>.<span class=\"me1\">isNaN</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span> <span class=\"kw2\">body</span> <span class=\"br0\">{</span><br/>    <span class=\"kw4\">auto</span> findBoundingBox<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw4\">nothrow</span> @nogc <span class=\"br0\">{</span><br/>        <span class=\"kw4\">double</span> min_x<span class=\"sy0\">,</span> max_x<span class=\"sy0\">,</span> min_y<span class=\"sy0\">,</span> max_y<span class=\"sy0\">;</span><br/>        max_x <span class=\"sy0\">=</span> max_y <span class=\"sy0\">=</span> <span class=\"sy0\">-</span><span class=\"kw4\">double</span>.<span class=\"me1\">max</span><span class=\"sy0\">;</span><br/>        min_x <span class=\"sy0\">=</span> min_y <span class=\"sy0\">=</span> <span class=\"kw4\">double</span>.<span class=\"me1\">max</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">const</span> <span class=\"kw2\">ref</span> p<span class=\"sy0\">;</span> points<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>max_x <span class=\"sy0\">&lt;</span> p.<span class=\"me1\">x</span><span class=\"br0\">)</span> max_x <span class=\"sy0\">=</span> p.<span class=\"me1\">x</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>min_x <span class=\"sy0\">&gt;</span> p.<span class=\"me1\">x</span><span class=\"br0\">)</span> min_x <span class=\"sy0\">=</span> p.<span class=\"me1\">x</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>max_y <span class=\"sy0\">&lt;</span> p.<span class=\"me1\">y</span><span class=\"br0\">)</span> max_y <span class=\"sy0\">=</span> p.<span class=\"me1\">y</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>min_y <span class=\"sy0\">&gt;</span> p.<span class=\"me1\">y</span><span class=\"br0\">)</span> min_y <span class=\"sy0\">=</span> p.<span class=\"me1\">y</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>        <span class=\"kw2\">assert</span><span class=\"br0\">(</span>max_x <span class=\"sy0\">&gt;</span> min_x <span class=\"sy0\">&amp;&amp;</span> max_y <span class=\"sy0\">&gt;</span> min_y<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"kw1\">return</span> tuple<span class=\"br0\">(</span>min<span class=\"br0\">(</span>W <span class=\"sy0\">/</span> <span class=\"br0\">(</span>max_x <span class=\"sy0\">-</span> min_x<span class=\"br0\">)</span><span class=\"sy0\">,</span> H <span class=\"sy0\">/</span> <span class=\"br0\">(</span>max_y <span class=\"sy0\">-</span> min_y<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">,</span><br/>                     <span class=\"br0\">(</span>max_x <span class=\"sy0\">+</span> min_x<span class=\"br0\">)</span> <span class=\"sy0\">/</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"br0\">(</span>max_y <span class=\"sy0\">+</span> min_y<span class=\"br0\">)</span> <span class=\"sy0\">/</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"co1\">//immutable (scale, cx, cy) = findBoundingBox();</span><br/>    <span class=\"kw4\">immutable</span> sc_cx_cy <span class=\"sy0\">=</span> findBoundingBox<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw4\">immutable</span> <span class=\"kw4\">double</span> scale <span class=\"sy0\">=</span> sc_cx_cy<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>    <span class=\"kw4\">immutable</span> <span class=\"kw4\">double</span> cx <span class=\"sy0\">=</span> sc_cx_cy<span class=\"br0\">[</span><span class=\"nu0\">1</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>    <span class=\"kw4\">immutable</span> <span class=\"kw4\">double</span> cy <span class=\"sy0\">=</span> sc_cx_cy<span class=\"br0\">[</span><span class=\"nu0\">2</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"kw4\">static</span> <span class=\"kw4\">immutable</span> <span class=\"kw4\">struct</span> Color <span class=\"br0\">{</span> <span class=\"kw4\">immutable</span> <span class=\"kw4\">double</span> r<span class=\"sy0\">,</span> g<span class=\"sy0\">,</span> b<span class=\"sy0\">;</span> <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"kw4\">immutable</span> <span class=\"kw4\">size_t</span> k <span class=\"sy0\">=</span> centers.<span class=\"me1\">length</span><span class=\"sy0\">;</span><br/>    Color<span class=\"br0\">[</span><span class=\"br0\">]</span> colors<span class=\"sy0\">;</span><br/>    colors.<span class=\"me1\">reserve</span><span class=\"br0\">(</span>centers.<span class=\"me1\">length</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">immutable</span> i<span class=\"sy0\">;</span> <span class=\"nu0\">0</span> <span class=\"sy0\">..</span> <span class=\"me1\">centers</span>.<span class=\"me1\">length</span><span class=\"br0\">)</span><br/>        colors <span class=\"sy0\">~=</span> Color<span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"nu0\">3</span> <span class=\"sy0\">*</span> <span class=\"br0\">(</span>i <span class=\"sy0\">+</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"sy0\">%</span> k<span class=\"br0\">)</span> <span class=\"sy0\">/</span> <span class=\"kw4\">double</span><span class=\"br0\">(</span>k<span class=\"br0\">)</span><span class=\"sy0\">,</span><br/>                        <span class=\"br0\">(</span><span class=\"nu0\">7</span> <span class=\"sy0\">*</span> i <span class=\"sy0\">%</span> k<span class=\"br0\">)</span> <span class=\"sy0\">/</span> <span class=\"kw4\">double</span><span class=\"br0\">(</span>k<span class=\"br0\">)</span><span class=\"sy0\">,</span><br/>                        <span class=\"br0\">(</span><span class=\"nu0\">9</span> <span class=\"sy0\">*</span> i <span class=\"sy0\">%</span> k<span class=\"br0\">)</span> <span class=\"sy0\">/</span> <span class=\"kw4\">double</span><span class=\"br0\">(</span>k<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    printf<span class=\"br0\">(</span><span class=\"st0\">\"%%!PS-Adobe-3.0<span class=\"es1\">\\n</span>%%%%BoundingBox: -5 -5\u00a0%d\u00a0%d<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span><br/>           W <span class=\"sy0\">+</span> <span class=\"nu0\">10</span><span class=\"sy0\">,</span> H <span class=\"sy0\">+</span> <span class=\"nu0\">10</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    printf<span class=\"br0\">(</span><span class=\"st0\">\"/l {rlineto} def /m {rmoveto} def<span class=\"es1\">\\n</span>\"</span> <span class=\"sy0\">~</span><br/>           <span class=\"st0\">\"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def<span class=\"es1\">\\n</span>\"</span> <span class=\"sy0\">~</span><br/>           <span class=\"st0\">\"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \"</span> <span class=\"sy0\">~</span><br/>           <span class=\"st0\">\"   gsave 1 setgray fill grestore gsave 3 setlinewidth\"</span> <span class=\"sy0\">~</span><br/>           <span class=\"st0\">\" 1 setgray stroke grestore 0 setgray stroke }def<span class=\"es1\">\\n</span>\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">immutable</span> i<span class=\"sy0\">,</span> <span class=\"kw4\">const</span> <span class=\"kw2\">ref</span> cc<span class=\"sy0\">;</span> centers<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        printf<span class=\"br0\">(</span><span class=\"st0\">\"%g\u00a0%g\u00a0%g setrgbcolor<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span> colors<span class=\"br0\">[</span>i<span class=\"br0\">]</span>.<span class=\"me1\">tupleof</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">const</span> <span class=\"kw2\">ref</span> p<span class=\"sy0\">;</span> points<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>p.<span class=\"me1\">cluster</span> <span class=\"sy0\">!=</span> i<span class=\"br0\">)</span><br/>                <span class=\"kw1\">continue</span><span class=\"sy0\">;</span><br/>            printf<span class=\"br0\">(</span><span class=\"st0\">\"%.3f\u00a0%.3f c<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span><br/>                   <span class=\"br0\">(</span>p.<span class=\"me1\">x</span> <span class=\"sy0\">-</span> cx<span class=\"br0\">)</span> <span class=\"sy0\">*</span> scale <span class=\"sy0\">+</span> W <span class=\"sy0\">/</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span><br/>                   <span class=\"br0\">(</span>p.<span class=\"me1\">y</span> <span class=\"sy0\">-</span> cy<span class=\"br0\">)</span> <span class=\"sy0\">*</span> scale <span class=\"sy0\">+</span> H <span class=\"sy0\">/</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        printf<span class=\"br0\">(</span><span class=\"st0\">\"<span class=\"es1\">\\n</span>0 setgray\u00a0%g\u00a0%g s<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span><br/>               <span class=\"br0\">(</span>cc.<span class=\"me1\">x</span> <span class=\"sy0\">-</span> cx<span class=\"br0\">)</span> <span class=\"sy0\">*</span> scale <span class=\"sy0\">+</span> W <span class=\"sy0\">/</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span><br/>               <span class=\"br0\">(</span>cc.<span class=\"me1\">y</span> <span class=\"sy0\">-</span> cy<span class=\"br0\">)</span> <span class=\"sy0\">*</span> scale <span class=\"sy0\">+</span> H <span class=\"sy0\">/</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"st0\">\"<span class=\"es1\">\\n</span>%%%%EOF\"</span>.<span class=\"me1\">printf</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/>\u00a0<br/><span class=\"kw4\">void</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <span class=\"kw4\">enum</span> <span class=\"kw4\">size_t</span> nPoints <span class=\"sy0\">=</span> <span class=\"nu0\">100</span>_000<span class=\"sy0\">;</span><br/>    <span class=\"kw4\">enum</span> <span class=\"kw4\">size_t</span> nClusters <span class=\"sy0\">=</span> <span class=\"nu0\">11</span><span class=\"sy0\">;</span> <span class=\"co1\">// k.</span><br/>    <span class=\"kw4\">auto</span> rnd <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>.<span class=\"me1\">Xorshift</span><span class=\"sy0\">;</span> <span class=\"co1\">// For speed and repeatability.</span><br/>\u00a0<br/>    <span class=\"kw4\">auto</span> points <span class=\"sy0\">=</span> generatePoints<span class=\"br0\">(</span>nPoints<span class=\"sy0\">,</span> <span class=\"nu0\">10</span><span class=\"sy0\">,</span> rnd<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw4\">const</span> clusterCenters <span class=\"sy0\">=</span> lloyd<span class=\"br0\">(</span>points<span class=\"sy0\">,</span> nClusters<span class=\"sy0\">,</span> rnd<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    printEps<span class=\"br0\">(</span>points<span class=\"sy0\">,</span> clusterCenters<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Euler Math Toolbox", "loc": 31, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>&gt;type kmeanscluster<br/> function kmeanscluster (x: numerical, k: index)<br/>     n=rows(x); m=cols(x);<br/>     i=floor((0:k)/k*(n-1))+1;<br/>     means=zeros(k,m);<br/>     loop 1 to k;<br/>         means[#]=sum(x[i[#]:(i[#+1]-1)]')'/(i[#+1]-i[#]);<br/>     end;<br/>     j=1:n;<br/>     loop 1 to n;<br/>         d=sum((x[#]-means)^2);<br/>         j[#]=extrema(d')[2];<br/>     end;<br/>     repeat<br/>         loop 1 to k;<br/>             i=nonzeros(j==#);<br/>             if cols(i)==0 then means[#]=1;<br/>             else means[#]=(sum(x[i]')/cols(i))';<br/>             endif;<br/>         end;<br/>         jold=j;<br/>         loop 1 to n;<br/>             d=sum((x[#]-means)^2);<br/>             j[#]=extrema(d')[2];<br/>         end;<br/>         if all(jold==j) then break; endif;<br/>     end<br/>     return j<br/> endfunction<br/>\u00a0</pre>"}, {"lang": "Fortran", "loc": 253, "block": "<pre class=\"fortran highlighted_source\">\u00a0<br/><span class=\"sy0\">***********************************************************************</span><br/><span class=\"sy0\">*</span> KMPP <span class=\"sy0\">-</span> K<span class=\"sy0\">-</span>Means<span class=\"sy0\">++</span> <span class=\"sy0\">-</span> Traditional <span class=\"kw3\">data</span> clustering with a special initialization<br/><span class=\"sy0\">*</span> <span class=\"kw3\">Public</span> Domain <span class=\"sy0\">-</span> This <span class=\"kw1\">program</span> may be used by <span class=\"kw4\">any</span> person for <span class=\"kw4\">any</span> purpose.<br/><span class=\"sy0\">*</span><br/><span class=\"sy0\">*</span> Origin<span class=\"sy0\">:</span><br/><span class=\"sy0\">*</span>    Hugo Steinhaus, <span class=\"nu0\">1956</span><br/><span class=\"sy0\">*</span><br/><span class=\"sy0\">*</span> Refer <span class=\"kw1\">to</span><span class=\"sy0\">:</span><br/><span class=\"sy0\">*</span>    <span class=\"st0\">\"kmeans++: the advantages of careful seeding\"</span><br/><span class=\"sy0\">*</span>    David Arthur and Sergei Vassilvitskii<br/><span class=\"sy0\">*</span>    Proceedings of the eighteenth annual ACM<span class=\"sy0\">-</span>SIAM symposium <br/><span class=\"sy0\">*</span>      on Discrete algorithms, <span class=\"nu0\">2007</span><br/><span class=\"sy0\">*</span><br/><span class=\"sy0\">*</span>____Variable_______I<span class=\"sy0\">/</span>O_______Description___________________Type_______<br/><span class=\"sy0\">*</span>    X<span class=\"br0\">(</span>P,N<span class=\"br0\">)</span>         <span class=\"kw3\">In</span>        <span class=\"kw3\">Data</span> points                   <span class=\"kw3\">Real</span><br/><span class=\"sy0\">*</span>    P              <span class=\"kw3\">In</span>        <span class=\"kw3\">Dimension</span> of the <span class=\"kw3\">data</span>         <span class=\"kw3\">Integer</span><br/><span class=\"sy0\">*</span>    N              <span class=\"kw3\">In</span>        <span class=\"kw1\">Number</span> of points              <span class=\"kw3\">Integer</span><br/><span class=\"sy0\">*</span>    K              <span class=\"kw3\">In</span>        # clusters                    <span class=\"kw3\">Integer</span><br/><span class=\"sy0\">*</span>    C<span class=\"br0\">(</span>P,K<span class=\"br0\">)</span>         <span class=\"kw3\">Out</span>       Center points of clusters     <span class=\"kw3\">Real</span><br/><span class=\"sy0\">*</span>    Z<span class=\"br0\">(</span>N<span class=\"br0\">)</span>           <span class=\"kw3\">Out</span>       What cluster a point is <span class=\"kw3\">in</span>    <span class=\"kw3\">Integer</span><br/><span class=\"sy0\">*</span>    WORK<span class=\"br0\">(</span>N<span class=\"br0\">)</span>        Neither                                 <span class=\"kw3\">Real</span><br/><span class=\"sy0\">*</span>    IFAULT         <span class=\"kw3\">Out</span>       <span class=\"kw4\">Error</span> code                    <span class=\"kw3\">Integer</span><br/><span class=\"sy0\">************************************************************************</span><br/>      <span class=\"kw1\">SUBROUTINE</span> KMPP <span class=\"br0\">(</span>X, P, N, K, C, Z, WORK, IFAULT<span class=\"br0\">)</span><br/>\u00a0<br/>       <span class=\"kw3\">IMPLICIT</span> <span class=\"kw3\">NONE</span><br/>       <span class=\"kw3\">INTEGER</span> P, N, K, Z, IFAULT<br/>       <span class=\"kw3\">REAL</span> X, C, WORK<br/>       <span class=\"kw3\">DIMENSION</span> X<span class=\"br0\">(</span>P,N<span class=\"br0\">)</span>, C<span class=\"br0\">(</span>P,K<span class=\"br0\">)</span>, Z<span class=\"br0\">(</span>N<span class=\"br0\">)</span>, WORK<span class=\"br0\">(</span>N<span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"sy0\">*</span>               constants<br/>       <span class=\"kw3\">INTEGER</span> ITER                 <span class=\"co1\">! maximum iterations</span><br/>       <span class=\"kw3\">REAL</span> BIG                     <span class=\"co1\">! arbitrary large number</span><br/>       <span class=\"kw3\">PARAMETER</span> <span class=\"br0\">(</span>ITER <span class=\"sy0\">=</span> <span class=\"nu0\">1000</span>,<br/>     $            BIG <span class=\"sy0\">=</span> 1E33<span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"sy0\">*</span>                local variables<br/>       <span class=\"kw3\">INTEGER</span> <br/>     $         H,          <span class=\"co1\">! count iterations</span><br/>     $         I,          <span class=\"co1\">! count points</span><br/>     $         I1,         <span class=\"co1\">! point marked as initial center</span><br/>     $         J,          <span class=\"co1\">! count dimensions</span><br/>     $         L,          <span class=\"co1\">! count clusters</span><br/>     $         L0,         <span class=\"co1\">! present cluster ID</span><br/>     $         L1          <span class=\"co1\">! new cluster ID</span><br/>\u00a0<br/>       <span class=\"kw3\">REAL</span> <br/>     $      BEST,                 <span class=\"co1\">! shortest distance to a center</span><br/>     $      D2,                   <span class=\"co1\">! squared distance</span><br/>     $      TOT,                  <span class=\"co1\">! a total</span><br/>     $      W                     <span class=\"co1\">! temp scalar</span><br/>\u00a0<br/>       <span class=\"kw3\">LOGICAL</span> CHANGE             <span class=\"co1\">! whether any points have been reassigned</span><br/>\u00a0<br/><span class=\"sy0\">************************************************************************</span><br/><span class=\"sy0\">*</span>           Begin.<br/><span class=\"sy0\">************************************************************************</span><br/>       IFAULT <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><br/>       <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>K &lt; <span class=\"nu0\">1</span> <span class=\"kw2\">.<span class=\"me1\">OR</span>.</span> K &gt; N<span class=\"br0\">)</span> <span class=\"kw1\">THEN</span>       <span class=\"co1\">! K out of bounds</span><br/>         IFAULT <span class=\"sy0\">=</span> <span class=\"nu0\">3</span><br/>         <span class=\"kw1\">RETURN</span><br/>       <span class=\"kw1\">END</span> <span class=\"kw1\">IF</span><br/>       <span class=\"kw1\">DO</span> I <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, N                       <span class=\"co1\">! clear Z</span><br/>         Z<span class=\"br0\">(</span>I<span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><br/>       <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>\u00a0<br/><span class=\"sy0\">************************************************************************</span><br/><span class=\"sy0\">*</span>        initial centers<br/><span class=\"sy0\">************************************************************************</span><br/>       <span class=\"kw1\">DO</span> I <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, N<br/>         WORK<span class=\"br0\">(</span>I<span class=\"br0\">)</span> <span class=\"sy0\">=</span> BIG<br/>       <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>\u00a0<br/>       <span class=\"kw1\">CALL</span> <span class=\"kw4\">RANDOM_NUMBER</span> <span class=\"br0\">(</span>W<span class=\"br0\">)</span><br/>       I1 <span class=\"sy0\">=</span> <span class=\"kw4\">MIN</span><span class=\"br0\">(</span><span class=\"kw4\">INT</span><span class=\"br0\">(</span>W <span class=\"sy0\">*</span> FLOAT<span class=\"br0\">(</span>N<span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"sy0\">+</span> <span class=\"nu0\">1</span>, N<span class=\"br0\">)</span>  <span class=\"co1\">! choose first center at random</span><br/>       <span class=\"kw1\">DO</span> J <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, P<br/>         C<span class=\"br0\">(</span>J,<span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> X<span class=\"br0\">(</span>J,I1<span class=\"br0\">)</span><br/>       <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>\u00a0<br/>       <span class=\"kw1\">DO</span> L <span class=\"sy0\">=</span> <span class=\"nu0\">2</span>, K                    <span class=\"co1\">! initialize other centers</span><br/>         TOT <span class=\"sy0\">=</span> <span class=\"nu0\">0</span>.<br/>         <span class=\"kw1\">DO</span> I <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, N                     <span class=\"co1\">! measure from each point</span><br/>           BEST <span class=\"sy0\">=</span> WORK<span class=\"br0\">(</span>I<span class=\"br0\">)</span><br/>           D2 <span class=\"sy0\">=</span> <span class=\"nu0\">0</span>.                         <span class=\"co1\">! to prior center</span><br/>           <span class=\"kw1\">DO</span> J <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, P<br/>             D2 <span class=\"sy0\">=</span> D2 <span class=\"sy0\">+</span> <span class=\"br0\">(</span>X<span class=\"br0\">(</span>J,I<span class=\"br0\">)</span> <span class=\"sy0\">-</span> C<span class=\"br0\">(</span>J,L<span class=\"sy0\">-</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"sy0\">**</span><span class=\"nu0\">2</span>  <span class=\"co1\">! Squared Euclidean distance</span><br/>             <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>D2 <span class=\"kw2\">.<span class=\"me1\">GE</span>.</span> BEST<span class=\"br0\">)</span> <span class=\"kw1\">GO</span> <span class=\"kw1\">TO</span> <span class=\"nu0\">10</span>               <span class=\"co1\">! needless to add to D2</span><br/>           <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span>                          <span class=\"co1\">! next J</span><br/>           <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>D2 &lt; BEST<span class=\"br0\">)</span> BEST <span class=\"sy0\">=</span> D2          <span class=\"co1\">! shortest squared distance </span><br/>           WORK<span class=\"br0\">(</span>I<span class=\"br0\">)</span> <span class=\"sy0\">=</span> BEST <br/>  <span class=\"nu0\">10</span>       TOT <span class=\"sy0\">=</span> TOT <span class=\"sy0\">+</span> BEST             <span class=\"co1\">! cumulative squared distance</span><br/>         <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span>                      <span class=\"co1\">! next data point</span><br/>\u00a0<br/><span class=\"sy0\">************************************************************************</span><br/><span class=\"sy0\">*</span> Choose center with probability proportional <span class=\"kw1\">to</span> its squared distance<br/><span class=\"sy0\">*</span>     from existing centers.<br/><span class=\"sy0\">************************************************************************</span><br/>         <span class=\"kw1\">CALL</span> <span class=\"kw4\">RANDOM_NUMBER</span> <span class=\"br0\">(</span>W<span class=\"br0\">)</span><br/>         W <span class=\"sy0\">=</span> W <span class=\"sy0\">*</span> TOT    <span class=\"co1\">! uniform at random over cumulative distance</span><br/>         TOT <span class=\"sy0\">=</span> <span class=\"nu0\">0</span>.<br/>         <span class=\"kw1\">DO</span> I <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, N<br/>           I1 <span class=\"sy0\">=</span> I<br/>           TOT <span class=\"sy0\">=</span> TOT <span class=\"sy0\">+</span> WORK<span class=\"br0\">(</span>I<span class=\"br0\">)</span><br/>           <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>TOT &gt; W<span class=\"br0\">)</span> <span class=\"kw1\">GO</span> <span class=\"kw1\">TO</span> <span class=\"nu0\">20</span><br/>         <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span>                <span class=\"co1\">! next I</span><br/>  <span class=\"nu0\">20</span>     <span class=\"kw1\">CONTINUE</span><br/>         <span class=\"kw1\">DO</span> J <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, P         <span class=\"co1\">! assign center</span><br/>           C<span class=\"br0\">(</span>J,L<span class=\"br0\">)</span> <span class=\"sy0\">=</span> X<span class=\"br0\">(</span>J,I1<span class=\"br0\">)</span><br/>         <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>       <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span>               <span class=\"co1\">! next center to initialize</span><br/>\u00a0<br/><span class=\"sy0\">************************************************************************</span><br/><span class=\"sy0\">*</span>                      main loop<br/><span class=\"sy0\">************************************************************************</span><br/>       <span class=\"kw1\">DO</span> H <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, ITER<br/>         CHANGE <span class=\"sy0\">=</span> <span class=\"kw2\">.<span class=\"me1\">FALSE</span>.</span><br/>\u00a0<br/><span class=\"sy0\">*</span>             find <span class=\"kw4\">nearest</span> center for each point <br/>         <span class=\"kw1\">DO</span> I <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, N<br/>           L0 <span class=\"sy0\">=</span> Z<span class=\"br0\">(</span>I<span class=\"br0\">)</span><br/>           L1 <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><br/>           BEST <span class=\"sy0\">=</span> BIG<br/>           <span class=\"kw1\">DO</span> L <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, K<br/>             D2 <span class=\"sy0\">=</span> <span class=\"nu0\">0</span>.<br/>             <span class=\"kw1\">DO</span> J <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, P<br/>               D2 <span class=\"sy0\">=</span> D2 <span class=\"sy0\">+</span> <span class=\"br0\">(</span>X<span class=\"br0\">(</span>J,I<span class=\"br0\">)</span> <span class=\"sy0\">-</span> C<span class=\"br0\">(</span>J,L<span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"sy0\">**</span><span class=\"nu0\">2</span><br/>               <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>D2 <span class=\"kw2\">.<span class=\"me1\">GE</span>.</span> BEST<span class=\"br0\">)</span> <span class=\"kw1\">GO</span> <span class=\"kw1\">TO</span> <span class=\"nu0\">30</span><br/>             <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>  <span class=\"nu0\">30</span>         <span class=\"kw1\">CONTINUE</span><br/>             <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>D2 &lt; BEST<span class=\"br0\">)</span> <span class=\"kw1\">THEN</span>           <span class=\"co1\">! new nearest center</span><br/>               BEST <span class=\"sy0\">=</span> D2<br/>               L1 <span class=\"sy0\">=</span> L<br/>             <span class=\"kw1\">END</span> <span class=\"kw1\">IF</span>             <br/>           <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span>        <span class=\"co1\">! next L</span><br/>\u00a0<br/>           <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>L0 <span class=\"kw2\">.<span class=\"me1\">NE</span>.</span> L1<span class=\"br0\">)</span> <span class=\"kw1\">THEN</span><br/>             Z<span class=\"br0\">(</span>I<span class=\"br0\">)</span> <span class=\"sy0\">=</span> L1                   <span class=\"co1\">!  reassign point </span><br/>             CHANGE <span class=\"sy0\">=</span> <span class=\"kw2\">.<span class=\"me1\">TRUE</span>.</span><br/>           <span class=\"kw1\">END</span> <span class=\"kw1\">IF</span><br/>         <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span>         <span class=\"co1\">! next I</span><br/>         <span class=\"kw1\">IF</span> <span class=\"br0\">(</span><span class=\"kw2\">.<span class=\"kw4\">NOT</span>.</span> CHANGE<span class=\"br0\">)</span> <span class=\"kw1\">RETURN</span>      <span class=\"co1\">! success</span><br/>\u00a0<br/><span class=\"sy0\">************************************************************************</span><br/><span class=\"sy0\">*</span>           find cluster centers<br/><span class=\"sy0\">************************************************************************</span><br/>         <span class=\"kw1\">DO</span> L <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, K              <span class=\"co1\">! zero population</span><br/>           WORK<span class=\"br0\">(</span>L<span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span>.<br/>         <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>         <span class=\"kw1\">DO</span> L <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, K               <span class=\"co1\">! zero centers</span><br/>           <span class=\"kw1\">DO</span> J <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, P<br/>             C<span class=\"br0\">(</span>J,L<span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span>.<br/>           <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>         <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>\u00a0<br/>         <span class=\"kw1\">DO</span> I <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, N<br/>           L <span class=\"sy0\">=</span> Z<span class=\"br0\">(</span>I<span class=\"br0\">)</span><br/>           WORK<span class=\"br0\">(</span>L<span class=\"br0\">)</span> <span class=\"sy0\">=</span> WORK<span class=\"br0\">(</span>L<span class=\"br0\">)</span> <span class=\"sy0\">+</span> <span class=\"nu0\">1</span>.             <span class=\"co1\">! count</span><br/>           <span class=\"kw1\">DO</span> J <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, P<br/>             C<span class=\"br0\">(</span>J,L<span class=\"br0\">)</span> <span class=\"sy0\">=</span> C<span class=\"br0\">(</span>J,L<span class=\"br0\">)</span> <span class=\"sy0\">+</span> X<span class=\"br0\">(</span>J,I<span class=\"br0\">)</span>         <span class=\"co1\">! add</span><br/>           <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>         <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>\u00a0<br/>         <span class=\"kw1\">DO</span> L <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, K<br/>           <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>WORK<span class=\"br0\">(</span>L<span class=\"br0\">)</span> &lt; <span class=\"nu0\">0.5</span><span class=\"br0\">)</span> <span class=\"kw1\">THEN</span>          <span class=\"co1\">! empty cluster check</span><br/>             IFAULT <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>                     <span class=\"co1\">! fatal error</span><br/>             <span class=\"kw1\">RETURN</span><br/>           <span class=\"kw1\">END</span> <span class=\"kw1\">IF</span><br/>           W <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>. <span class=\"sy0\">/</span> WORK<span class=\"br0\">(</span>L<span class=\"br0\">)</span><br/>           <span class=\"kw1\">DO</span> J <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, P<br/>             C<span class=\"br0\">(</span>J,L<span class=\"br0\">)</span> <span class=\"sy0\">=</span> C<span class=\"br0\">(</span>J,L<span class=\"br0\">)</span> <span class=\"sy0\">*</span> W     <span class=\"co1\">! multiplication is faster than division</span><br/>           <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>         <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>\u00a0<br/>       <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span>                   <span class=\"co1\">! next H</span><br/>       IFAULT <span class=\"sy0\">=</span> <span class=\"nu0\">2</span>                <span class=\"co1\">! too many iterations</span><br/>       <span class=\"kw1\">RETURN</span><br/>\u00a0<br/>      <span class=\"kw1\">END</span>  <span class=\"co1\">! of KMPP</span><br/>\u00a0<br/>\u00a0<br/><span class=\"sy0\">************************************************************************</span><br/><span class=\"sy0\">*</span>             test <span class=\"kw1\">program</span> <span class=\"br0\">(</span>extra credit #<span class=\"nu0\">1</span><span class=\"br0\">)</span><br/><span class=\"sy0\">************************************************************************</span><br/>      <span class=\"kw1\">PROGRAM</span> TPEC1<br/>       <span class=\"kw3\">IMPLICIT</span> <span class=\"kw3\">NONE</span><br/>       <span class=\"kw3\">INTEGER</span> N, P, K<br/>       <span class=\"kw3\">REAL</span> TWOPI<br/>       <span class=\"kw3\">PARAMETER</span> <span class=\"br0\">(</span>N <span class=\"sy0\">=</span> <span class=\"nu0\">30</span> 000,<br/>     $            P <span class=\"sy0\">=</span> <span class=\"nu0\">2</span>,<br/>     $            K <span class=\"sy0\">=</span> <span class=\"nu0\">6</span>,<br/>     $            TWOPI <span class=\"sy0\">=</span> <span class=\"nu0\">6.2831853</span><span class=\"br0\">)</span><br/>       <span class=\"kw3\">INTEGER</span> I, L, Z<span class=\"br0\">(</span>N<span class=\"br0\">)</span>, IFAULT<br/>       <span class=\"kw3\">REAL</span> X<span class=\"br0\">(</span>P,N<span class=\"br0\">)</span>, C<span class=\"br0\">(</span>P,K<span class=\"br0\">)</span>, R, THETA, W, WORK<span class=\"br0\">(</span>N<span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"sy0\">*</span>             Begin<br/>       <span class=\"kw1\">CALL</span> <span class=\"kw4\">RANDOM_SEED</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>       <span class=\"kw1\">DO</span> I <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, N                      <span class=\"co1\">! random points over unit circle</span><br/>         <span class=\"kw1\">CALL</span> <span class=\"kw4\">RANDOM_NUMBER</span> <span class=\"br0\">(</span>W<span class=\"br0\">)</span><br/>         R <span class=\"sy0\">=</span> <span class=\"kw4\">SQRT</span><span class=\"br0\">(</span>W<span class=\"br0\">)</span>                      <span class=\"co1\">! radius</span><br/>         <span class=\"kw1\">CALL</span> <span class=\"kw4\">RANDOM_NUMBER</span> <span class=\"br0\">(</span>W<span class=\"br0\">)</span><br/>         THETA <span class=\"sy0\">=</span> W <span class=\"sy0\">*</span> TWOPI                <span class=\"co1\">! angle</span><br/>         X<span class=\"br0\">(</span><span class=\"nu0\">1</span>,I<span class=\"br0\">)</span> <span class=\"sy0\">=</span> R <span class=\"sy0\">*</span> <span class=\"kw4\">COS</span><span class=\"br0\">(</span>THETA<span class=\"br0\">)</span>          <span class=\"co1\">! Cartesian coordinates</span><br/>         X<span class=\"br0\">(</span><span class=\"nu0\">2</span>,I<span class=\"br0\">)</span> <span class=\"sy0\">=</span> R <span class=\"sy0\">*</span> <span class=\"kw4\">SIN</span><span class=\"br0\">(</span>THETA<span class=\"br0\">)</span><br/>       <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>\u00a0<br/><span class=\"sy0\">*</span>             <span class=\"kw1\">Call</span> <span class=\"kw1\">subroutine</span><br/>       <span class=\"kw1\">CALL</span> KMPP <span class=\"br0\">(</span>X, P, N, K, C, Z, WORK, IFAULT<span class=\"br0\">)</span><br/>       PRINT <span class=\"sy0\">*</span>, <span class=\"st0\">'kmpp returns with error code '</span>, IFAULT<br/>\u00a0<br/><span class=\"sy0\">*</span>            Print lists of points <span class=\"kw3\">in</span> each cluster<br/>       <span class=\"kw1\">DO</span> L <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, K<br/>         PRINT <span class=\"sy0\">*</span>, <span class=\"st0\">'Cluster '</span>, L, <span class=\"st0\">' contains points: '</span><br/>  <span class=\"nu0\">10</span>     FORMAT <span class=\"br0\">(</span>I6, $<span class=\"br0\">)</span><br/>  <span class=\"nu0\">20</span>     FORMAT <span class=\"br0\">(</span><span class=\"br0\">)</span><br/>         <span class=\"kw1\">DO</span> I <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, N<br/>           <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>Z<span class=\"br0\">(</span>I<span class=\"br0\">)</span> <span class=\"kw2\">.<span class=\"me1\">EQ</span>.</span> L<span class=\"br0\">)</span> PRINT <span class=\"nu0\">10</span>, I<br/>         <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>         PRINT <span class=\"nu0\">20</span><br/>       <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>\u00a0<br/><span class=\"sy0\">*</span>         Write CSV <span class=\"kw1\">file</span> with Y<span class=\"sy0\">-</span>coordinates <span class=\"kw3\">in</span> different columns by cluster<br/>       OPEN <span class=\"br0\">(</span><span class=\"kw1\">UNIT</span><span class=\"sy0\">=</span><span class=\"nu0\">1</span>, <span class=\"kw1\">FILE</span><span class=\"sy0\">=</span><span class=\"st0\">'tpec1.csv'</span>, <span class=\"kw1\">STATUS</span><span class=\"sy0\">=</span><span class=\"st0\">'NEW'</span>, <span class=\"kw1\">IOSTAT</span><span class=\"sy0\">=</span>IFAULT<span class=\"br0\">)</span><br/>       <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>IFAULT <span class=\"kw2\">.<span class=\"me1\">NE</span>.</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span> PRINT <span class=\"sy0\">*</span>, <span class=\"st0\">'tpec1: trouble opening file'</span><br/>  <span class=\"nu0\">30</span>   FORMAT <span class=\"br0\">(</span>F8.4, $<span class=\"br0\">)</span><br/>  <span class=\"nu0\">40</span>   FORMAT <span class=\"br0\">(</span><span class=\"st0\">','</span>, $<span class=\"br0\">)</span><br/>  <span class=\"nu0\">50</span>   FORMAT <span class=\"br0\">(</span>F8.4<span class=\"br0\">)</span><br/>       <span class=\"kw1\">DO</span> I <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, N<br/>         WRITE <span class=\"br0\">(</span><span class=\"kw1\">UNIT</span><span class=\"sy0\">=</span><span class=\"nu0\">1</span>, <span class=\"kw1\">FMT</span><span class=\"sy0\">=</span><span class=\"nu0\">30</span>, <span class=\"kw1\">IOSTAT</span><span class=\"sy0\">=</span>IFAULT<span class=\"br0\">)</span> X<span class=\"br0\">(</span><span class=\"nu0\">1</span>,I<span class=\"br0\">)</span><br/>         <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>IFAULT <span class=\"kw2\">.<span class=\"me1\">NE</span>.</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span> PRINT <span class=\"sy0\">*</span>, <span class=\"st0\">'tpec1: trouble writing X-coord'</span><br/>         <span class=\"kw1\">DO</span> L <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, Z<span class=\"br0\">(</span>I<span class=\"br0\">)</span>                     <span class=\"co1\">! one comma per cluster ID</span><br/>           WRITE <span class=\"br0\">(</span><span class=\"kw1\">UNIT</span><span class=\"sy0\">=</span><span class=\"nu0\">1</span>, <span class=\"kw1\">FMT</span><span class=\"sy0\">=</span><span class=\"nu0\">40</span>, <span class=\"kw1\">IOSTAT</span><span class=\"sy0\">=</span>IFAULT<span class=\"br0\">)</span><br/>           <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>IFAULT <span class=\"kw2\">.<span class=\"me1\">NE</span>.</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span> PRINT <span class=\"sy0\">*</span>, <span class=\"st0\">'tpec1: trouble writing comma'</span><br/>         <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>         WRITE <span class=\"br0\">(</span><span class=\"kw1\">UNIT</span><span class=\"sy0\">=</span><span class=\"nu0\">1</span>, <span class=\"kw1\">FMT</span><span class=\"sy0\">=</span><span class=\"nu0\">50</span>, <span class=\"kw1\">IOSTAT</span><span class=\"sy0\">=</span>IFAULT<span class=\"br0\">)</span> X<span class=\"br0\">(</span><span class=\"nu0\">2</span>,I<span class=\"br0\">)</span><br/>         <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>IFAULT <span class=\"kw2\">.<span class=\"me1\">NE</span>.</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span> PRINT <span class=\"sy0\">*</span>, <span class=\"st0\">'tpec1: trouble writing Y-coord'</span><br/>       <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>\u00a0<br/><span class=\"sy0\">*</span>           Write the centroids <span class=\"kw3\">in</span> the far column<br/>       <span class=\"kw1\">DO</span> L <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, K<br/>         WRITE <span class=\"br0\">(</span><span class=\"kw1\">UNIT</span><span class=\"sy0\">=</span><span class=\"nu0\">1</span>, <span class=\"kw1\">FMT</span><span class=\"sy0\">=</span><span class=\"nu0\">30</span>, <span class=\"kw1\">IOSTAT</span><span class=\"sy0\">=</span>IFAULT<span class=\"br0\">)</span> C<span class=\"br0\">(</span><span class=\"nu0\">1</span>,L<span class=\"br0\">)</span><br/>         <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>IFAULT <span class=\"kw2\">.<span class=\"me1\">NE</span>.</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span> PRINT <span class=\"sy0\">*</span>, <span class=\"st0\">'tpec1: trouble writing X-coord'</span><br/>         <span class=\"kw1\">DO</span> I <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, K<span class=\"sy0\">+</span><span class=\"nu0\">1</span><br/>           WRITE <span class=\"br0\">(</span><span class=\"kw1\">UNIT</span><span class=\"sy0\">=</span><span class=\"nu0\">1</span>, <span class=\"kw1\">FMT</span><span class=\"sy0\">=</span><span class=\"nu0\">40</span>, <span class=\"kw1\">IOSTAT</span><span class=\"sy0\">=</span>IFAULT<span class=\"br0\">)</span><br/>           <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>IFAULT <span class=\"kw2\">.<span class=\"me1\">NE</span>.</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span> PRINT <span class=\"sy0\">*</span>, <span class=\"st0\">'tpec1: trouble writing comma'</span><br/>         <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>         WRITE <span class=\"br0\">(</span><span class=\"kw1\">UNIT</span><span class=\"sy0\">=</span><span class=\"nu0\">1</span>, <span class=\"kw1\">FMT</span><span class=\"sy0\">=</span><span class=\"nu0\">50</span>, <span class=\"kw1\">IOSTAT</span><span class=\"sy0\">=</span>IFAULT<span class=\"br0\">)</span> C<span class=\"br0\">(</span><span class=\"nu0\">2</span>,L<span class=\"br0\">)</span><br/>         <span class=\"kw1\">IF</span> <span class=\"br0\">(</span>IFAULT <span class=\"kw2\">.<span class=\"me1\">NE</span>.</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span> PRINT <span class=\"sy0\">*</span>, <span class=\"st0\">'tpec1: trouble writing Y-coord'</span><br/>       <span class=\"kw1\">END</span> <span class=\"kw1\">DO</span><br/>       CLOSE <span class=\"br0\">(</span><span class=\"kw1\">UNIT</span><span class=\"sy0\">=</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><br/>\u00a0<br/>      <span class=\"kw1\">END</span>  <span class=\"co1\">! of test program</span><br/>\u00a0</pre>"}, {"lang": "Go", "loc": 222, "block": "<pre class=\"go highlighted_source\"><span class=\"kw1\">package</span> main<br/>\u00a0<br/><span class=\"kw1\">import</span> <span class=\"sy1\">(</span><br/>    <span class=\"st0\">\"fmt\"</span><br/>    <span class=\"st0\">\"image\"</span><br/>    <span class=\"st0\">\"image/color\"</span><br/>    <span class=\"st0\">\"image/draw\"</span><br/>    <span class=\"st0\">\"image/png\"</span><br/>    <span class=\"st0\">\"math\"</span><br/>    <span class=\"st0\">\"math/rand\"</span><br/>    <span class=\"st0\">\"os\"</span><br/>    <span class=\"st0\">\"time\"</span><br/><span class=\"sy1\">)</span><br/>\u00a0<br/><span class=\"kw1\">type</span> r2 <span class=\"kw4\">struct</span> <span class=\"sy1\">{</span><br/>    x<span class=\"sy1\">,</span> y <span class=\"kw4\">float64</span><br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"kw1\">type</span> r2c <span class=\"kw4\">struct</span> <span class=\"sy1\">{</span><br/>    r2<br/>    c <span class=\"kw4\">int</span> <span class=\"co1\">// cluster number</span><br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"co1\">// kmpp implements K-means++, satisfying the basic task requirement</span><br/><span class=\"kw4\">func</span> kmpp<span class=\"sy1\">(</span>k <span class=\"kw4\">int</span><span class=\"sy1\">,</span> data <span class=\"sy1\">[]</span>r2c<span class=\"sy1\">)</span> <span class=\"sy1\">{</span><br/>    kMeans<span class=\"sy1\">(</span>data<span class=\"sy1\">,</span> kmppSeeds<span class=\"sy1\">(</span>k<span class=\"sy1\">,</span> data<span class=\"sy1\">))</span><br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"co1\">// kmppSeeds is the ++ part.</span><br/><span class=\"co1\">// It generates the initial means for the k-means algorithm.</span><br/><span class=\"kw4\">func</span> kmppSeeds<span class=\"sy1\">(</span>k <span class=\"kw4\">int</span><span class=\"sy1\">,</span> data <span class=\"sy1\">[]</span>r2c<span class=\"sy1\">)</span> <span class=\"sy1\">[]</span>r2 <span class=\"sy1\">{</span><br/>    s <span class=\"sy2\">:=</span> <span class=\"kw3\">make</span><span class=\"sy1\">([]</span>r2<span class=\"sy1\">,</span> k<span class=\"sy1\">)</span><br/>    s<span class=\"sy1\">[</span><span class=\"nu0\">0</span><span class=\"sy1\">]</span> <span class=\"sy2\">=</span> data<span class=\"sy1\">[</span>rand<span class=\"sy3\">.</span>Intn<span class=\"sy1\">(</span><span class=\"kw3\">len</span><span class=\"sy1\">(</span>data<span class=\"sy1\">))]</span><span class=\"sy3\">.</span>r2<br/>    d2 <span class=\"sy2\">:=</span> <span class=\"kw3\">make</span><span class=\"sy1\">([]</span><span class=\"kw4\">float64</span><span class=\"sy1\">,</span> <span class=\"kw3\">len</span><span class=\"sy1\">(</span>data<span class=\"sy1\">))</span><br/>    <span class=\"kw1\">for</span> <span class=\"nu2\">i</span> <span class=\"sy2\">:=</span> <span class=\"nu0\">1</span><span class=\"sy1\">;</span> <span class=\"nu2\">i</span> &lt; k<span class=\"sy1\">;</span> <span class=\"nu2\">i</span><span class=\"sy2\">++</span> <span class=\"sy1\">{</span><br/>        <span class=\"kw1\">var</span> sum <span class=\"kw4\">float64</span><br/>        <span class=\"kw1\">for</span> j<span class=\"sy1\">,</span> p <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> data <span class=\"sy1\">{</span><br/>            _<span class=\"sy1\">,</span> dMin <span class=\"sy2\">:=</span> nearest<span class=\"sy1\">(</span>p<span class=\"sy1\">,</span> s<span class=\"sy1\">[:</span><span class=\"nu2\">i</span><span class=\"sy1\">])</span><br/>            d2<span class=\"sy1\">[</span>j<span class=\"sy1\">]</span> <span class=\"sy2\">=</span> dMin <span class=\"sy3\">*</span> dMin<br/>            sum <span class=\"sy2\">+=</span> d2<span class=\"sy1\">[</span>j<span class=\"sy1\">]</span><br/>        <span class=\"sy1\">}</span><br/>        target <span class=\"sy2\">:=</span> rand<span class=\"sy3\">.</span>Float64<span class=\"sy1\">()</span> <span class=\"sy3\">*</span> sum<br/>        j <span class=\"sy2\">:=</span> <span class=\"nu0\">0</span><br/>        <span class=\"kw1\">for</span> sum <span class=\"sy2\">=</span> d2<span class=\"sy1\">[</span><span class=\"nu0\">0</span><span class=\"sy1\">];</span> sum &lt; target<span class=\"sy1\">;</span> sum <span class=\"sy2\">+=</span> d2<span class=\"sy1\">[</span>j<span class=\"sy1\">]</span> <span class=\"sy1\">{</span><br/>            j<span class=\"sy2\">++</span><br/>        <span class=\"sy1\">}</span><br/>        s<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span> <span class=\"sy2\">=</span> data<span class=\"sy1\">[</span>j<span class=\"sy1\">]</span><span class=\"sy3\">.</span>r2<br/>    <span class=\"sy1\">}</span><br/>    <span class=\"kw1\">return</span> s<br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"co1\">// nearest finds the nearest mean to a given point.</span><br/><span class=\"co1\">// return values are the index of the nearest mean, and the distance from</span><br/><span class=\"co1\">// the point to the mean.</span><br/><span class=\"kw4\">func</span> nearest<span class=\"sy1\">(</span>p r2c<span class=\"sy1\">,</span> mean <span class=\"sy1\">[]</span>r2<span class=\"sy1\">)</span> <span class=\"sy1\">(</span><span class=\"kw4\">int</span><span class=\"sy1\">,</span> <span class=\"kw4\">float64</span><span class=\"sy1\">)</span> <span class=\"sy1\">{</span><br/>    iMin <span class=\"sy2\">:=</span> <span class=\"nu0\">0</span><br/>    dMin <span class=\"sy2\">:=</span> math<span class=\"sy3\">.</span>Hypot<span class=\"sy1\">(</span>p<span class=\"sy3\">.</span>x<span class=\"sy3\">-</span>mean<span class=\"sy1\">[</span><span class=\"nu0\">0</span><span class=\"sy1\">]</span><span class=\"sy3\">.</span>x<span class=\"sy1\">,</span> p<span class=\"sy3\">.</span>y<span class=\"sy3\">-</span>mean<span class=\"sy1\">[</span><span class=\"nu0\">0</span><span class=\"sy1\">]</span><span class=\"sy3\">.</span>y<span class=\"sy1\">)</span><br/>    <span class=\"kw1\">for</span> <span class=\"nu2\">i</span> <span class=\"sy2\">:=</span> <span class=\"nu0\">1</span><span class=\"sy1\">;</span> <span class=\"nu2\">i</span> &lt; <span class=\"kw3\">len</span><span class=\"sy1\">(</span>mean<span class=\"sy1\">);</span> <span class=\"nu2\">i</span><span class=\"sy2\">++</span> <span class=\"sy1\">{</span><br/>        d <span class=\"sy2\">:=</span> math<span class=\"sy3\">.</span>Hypot<span class=\"sy1\">(</span>p<span class=\"sy3\">.</span>x<span class=\"sy3\">-</span>mean<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span><span class=\"sy3\">.</span>x<span class=\"sy1\">,</span> p<span class=\"sy3\">.</span>y<span class=\"sy3\">-</span>mean<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span><span class=\"sy3\">.</span>y<span class=\"sy1\">)</span><br/>        <span class=\"kw1\">if</span> d &lt; dMin <span class=\"sy1\">{</span><br/>            dMin <span class=\"sy2\">=</span> d<br/>            iMin <span class=\"sy2\">=</span> <span class=\"nu2\">i</span><br/>        <span class=\"sy1\">}</span><br/>    <span class=\"sy1\">}</span><br/>    <span class=\"kw1\">return</span> iMin<span class=\"sy1\">,</span> dMin<br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"co1\">// kMeans algorithm.  Lloyd's</span><br/><span class=\"kw4\">func</span> kMeans<span class=\"sy1\">(</span>data <span class=\"sy1\">[]</span>r2c<span class=\"sy1\">,</span> mean <span class=\"sy1\">[]</span>r2<span class=\"sy1\">)</span> <span class=\"sy1\">{</span><br/>    <span class=\"co1\">// initial assignment</span><br/>    <span class=\"kw1\">for</span> <span class=\"nu2\">i</span><span class=\"sy1\">,</span> p <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> data <span class=\"sy1\">{</span><br/>        cMin<span class=\"sy1\">,</span> _ <span class=\"sy2\">:=</span> nearest<span class=\"sy1\">(</span>p<span class=\"sy1\">,</span> mean<span class=\"sy1\">)</span><br/>        data<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span><span class=\"sy3\">.</span>c <span class=\"sy2\">=</span> cMin<br/>    <span class=\"sy1\">}</span><br/>    mLen <span class=\"sy2\">:=</span> <span class=\"kw3\">make</span><span class=\"sy1\">([]</span><span class=\"kw4\">int</span><span class=\"sy1\">,</span> <span class=\"kw3\">len</span><span class=\"sy1\">(</span>mean<span class=\"sy1\">))</span><br/>    <span class=\"kw1\">for</span> <span class=\"sy1\">{</span><br/>        <span class=\"co1\">// update means</span><br/>        <span class=\"kw1\">for</span> <span class=\"nu2\">i</span> <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> mean <span class=\"sy1\">{</span><br/>            mean<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span> <span class=\"sy2\">=</span> r2<span class=\"sy1\">{}</span><br/>            mLen<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span> <span class=\"sy2\">=</span> <span class=\"nu0\">0</span><br/>        <span class=\"sy1\">}</span><br/>        <span class=\"kw1\">for</span> _<span class=\"sy1\">,</span> p <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> data <span class=\"sy1\">{</span><br/>            mean<span class=\"sy1\">[</span>p<span class=\"sy3\">.</span>c<span class=\"sy1\">]</span><span class=\"sy3\">.</span>x <span class=\"sy2\">+=</span> p<span class=\"sy3\">.</span>x<br/>            mean<span class=\"sy1\">[</span>p<span class=\"sy3\">.</span>c<span class=\"sy1\">]</span><span class=\"sy3\">.</span>y <span class=\"sy2\">+=</span> p<span class=\"sy3\">.</span>y<br/>            mLen<span class=\"sy1\">[</span>p<span class=\"sy3\">.</span>c<span class=\"sy1\">]</span><span class=\"sy2\">++</span><br/>        <span class=\"sy1\">}</span><br/>        <span class=\"kw1\">for</span> <span class=\"nu2\">i</span> <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> mean <span class=\"sy1\">{</span><br/>            inv <span class=\"sy2\">:=</span> <span class=\"nu0\">1</span> <span class=\"sy3\">/</span> <span class=\"kw4\">float64</span><span class=\"sy1\">(</span>mLen<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">])</span><br/>            mean<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span><span class=\"sy3\">.</span>x <span class=\"sy2\">*=</span> inv<br/>            mean<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span><span class=\"sy3\">.</span>y <span class=\"sy2\">*=</span> inv<br/>        <span class=\"sy1\">}</span><br/>        <span class=\"co1\">// make new assignments, count changes</span><br/>        <span class=\"kw1\">var</span> changes <span class=\"kw4\">int</span><br/>        <span class=\"kw1\">for</span> <span class=\"nu2\">i</span><span class=\"sy1\">,</span> p <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> data <span class=\"sy1\">{</span><br/>            <span class=\"kw1\">if</span> cMin<span class=\"sy1\">,</span> _ <span class=\"sy2\">:=</span> nearest<span class=\"sy1\">(</span>p<span class=\"sy1\">,</span> mean<span class=\"sy1\">);</span> cMin <span class=\"sy2\">!=</span> p<span class=\"sy3\">.</span>c <span class=\"sy1\">{</span><br/>                changes<span class=\"sy2\">++</span><br/>                data<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span><span class=\"sy3\">.</span>c <span class=\"sy2\">=</span> cMin<br/>            <span class=\"sy1\">}</span><br/>        <span class=\"sy1\">}</span><br/>        <span class=\"kw1\">if</span> changes <span class=\"sy3\">==</span> <span class=\"nu0\">0</span> <span class=\"sy1\">{</span><br/>            <span class=\"kw1\">return</span><br/>        <span class=\"sy1\">}</span><br/>    <span class=\"sy1\">}</span><br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"co1\">// parameters for extra credit exercises</span><br/><span class=\"kw1\">type</span> ecParam <span class=\"kw4\">struct</span> <span class=\"sy1\">{</span><br/>    k          <span class=\"kw4\">int</span><br/>    nPoints    <span class=\"kw4\">int</span><br/>    xBox<span class=\"sy1\">,</span> yBox <span class=\"kw4\">int</span><br/>    stdv       <span class=\"kw4\">int</span><br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"co1\">// extra credit 1 and 2:</span><br/><span class=\"kw4\">func</span> main<span class=\"sy1\">()</span> <span class=\"sy1\">{</span><br/>    ec <span class=\"sy2\">:=</span> &amp;ecParam<span class=\"sy1\">{</span><span class=\"nu0\">6</span><span class=\"sy1\">,</span> <span class=\"nu0\">30000</span><span class=\"sy1\">,</span> <span class=\"nu0\">300</span><span class=\"sy1\">,</span> <span class=\"nu0\">200</span><span class=\"sy1\">,</span> <span class=\"nu0\">30</span><span class=\"sy1\">}</span><br/>\u00a0<br/>    origin<span class=\"sy1\">,</span> data <span class=\"sy2\">:=</span> genECData<span class=\"sy1\">(</span>ec<span class=\"sy1\">)</span><br/>    vis<span class=\"sy1\">(</span>ec<span class=\"sy1\">,</span> data<span class=\"sy1\">,</span> <span class=\"st0\">\"origin\"</span><span class=\"sy1\">)</span><br/>    fmt<span class=\"sy3\">.</span><span class=\"me1\">Println</span><span class=\"sy1\">(</span><span class=\"st0\">\"Data set origins:\"</span><span class=\"sy1\">)</span><br/>    fmt<span class=\"sy3\">.</span><span class=\"me1\">Println</span><span class=\"sy1\">(</span><span class=\"st0\">\"    x      y\"</span><span class=\"sy1\">)</span><br/>    <span class=\"kw1\">for</span> _<span class=\"sy1\">,</span> o <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> origin <span class=\"sy1\">{</span><br/>        fmt<span class=\"sy3\">.</span>Printf<span class=\"sy1\">(</span><span class=\"st0\">\"%5.1f \u00a0%5.1f<span class=\"es1\">\\n</span>\"</span><span class=\"sy1\">,</span> o<span class=\"sy3\">.</span><span class=\"me1\">x</span><span class=\"sy1\">,</span> o<span class=\"sy3\">.</span><span class=\"me1\">y</span><span class=\"sy1\">)</span><br/>    <span class=\"sy1\">}</span><br/>\u00a0<br/>    kmpp<span class=\"sy1\">(</span>ec<span class=\"sy3\">.</span><span class=\"me1\">k</span><span class=\"sy1\">,</span> data<span class=\"sy1\">)</span><br/>\u00a0<br/>    fmt<span class=\"sy3\">.</span><span class=\"me1\">Println</span><span class=\"sy1\">(</span><br/>        <span class=\"st0\">\"<span class=\"es1\">\\n</span>Cluster centroids, mean distance from centroid, number of points:\"</span><span class=\"sy1\">)</span><br/>    fmt<span class=\"sy3\">.</span><span class=\"me1\">Println</span><span class=\"sy1\">(</span><span class=\"st0\">\"    x      y  distance  points\"</span><span class=\"sy1\">)</span><br/>    cent <span class=\"sy2\">:=</span> <span class=\"kw3\">make</span><span class=\"sy1\">([]</span>r2<span class=\"sy1\">,</span> ec<span class=\"sy3\">.</span>k<span class=\"sy1\">)</span><br/>    cLen <span class=\"sy2\">:=</span> <span class=\"kw3\">make</span><span class=\"sy1\">([]</span><span class=\"kw4\">int</span><span class=\"sy1\">,</span> ec<span class=\"sy3\">.</span>k<span class=\"sy1\">)</span><br/>    inv <span class=\"sy2\">:=</span> <span class=\"kw3\">make</span><span class=\"sy1\">([]</span><span class=\"kw4\">float64</span><span class=\"sy1\">,</span> ec<span class=\"sy3\">.</span>k<span class=\"sy1\">)</span><br/>    <span class=\"kw1\">for</span> _<span class=\"sy1\">,</span> p <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> data <span class=\"sy1\">{</span><br/>        cent<span class=\"sy1\">[</span>p<span class=\"sy3\">.</span>c<span class=\"sy1\">]</span><span class=\"sy3\">.</span>x <span class=\"sy2\">+=</span> p<span class=\"sy3\">.</span>x <br/>        cent<span class=\"sy1\">[</span>p<span class=\"sy3\">.</span>c<span class=\"sy1\">]</span><span class=\"sy3\">.</span>y <span class=\"sy2\">+=</span> p<span class=\"sy3\">.</span>y <br/>        cLen<span class=\"sy1\">[</span>p<span class=\"sy3\">.</span>c<span class=\"sy1\">]</span><span class=\"sy2\">++</span><br/>    <span class=\"sy1\">}</span><br/>    <span class=\"kw1\">for</span> <span class=\"nu2\">i</span><span class=\"sy1\">,</span> iLen <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> cLen <span class=\"sy1\">{</span><br/>        inv<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span> <span class=\"sy2\">=</span> <span class=\"nu0\">1</span> <span class=\"sy3\">/</span> <span class=\"kw4\">float64</span><span class=\"sy1\">(</span>iLen<span class=\"sy1\">)</span><br/>        cent<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span><span class=\"sy3\">.</span>x <span class=\"sy2\">*=</span> inv<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span><br/>        cent<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span><span class=\"sy3\">.</span>y <span class=\"sy2\">*=</span> inv<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span><br/>    <span class=\"sy1\">}</span><br/>    dist <span class=\"sy2\">:=</span> <span class=\"kw3\">make</span><span class=\"sy1\">([]</span><span class=\"kw4\">float64</span><span class=\"sy1\">,</span> ec<span class=\"sy3\">.</span>k<span class=\"sy1\">)</span><br/>    <span class=\"kw1\">for</span> _<span class=\"sy1\">,</span> p <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> data <span class=\"sy1\">{</span><br/>        dist<span class=\"sy1\">[</span>p<span class=\"sy3\">.</span>c<span class=\"sy1\">]</span> <span class=\"sy2\">+=</span> math<span class=\"sy3\">.</span>Hypot<span class=\"sy1\">(</span>p<span class=\"sy3\">.</span>x<span class=\"sy3\">-</span>cent<span class=\"sy1\">[</span>p<span class=\"sy3\">.</span>c<span class=\"sy1\">]</span><span class=\"sy3\">.</span>x<span class=\"sy1\">,</span> p<span class=\"sy3\">.</span>y<span class=\"sy3\">-</span>cent<span class=\"sy1\">[</span>p<span class=\"sy3\">.</span>c<span class=\"sy1\">]</span><span class=\"sy3\">.</span>y<span class=\"sy1\">)</span><br/>    <span class=\"sy1\">}</span><br/>    <span class=\"kw1\">for</span> <span class=\"nu2\">i</span><span class=\"sy1\">,</span> iLen <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> cLen <span class=\"sy1\">{</span><br/>        fmt<span class=\"sy3\">.</span>Printf<span class=\"sy1\">(</span><span class=\"st0\">\"%5.1f \u00a0%5.1f \u00a0%8.1f \u00a0%6d<span class=\"es1\">\\n</span>\"</span><span class=\"sy1\">,</span><br/>            cent<span class=\"sy1\">[</span>i<span class=\"sy1\">]</span><span class=\"sy3\">.</span><span class=\"me1\">x</span><span class=\"sy1\">,</span> cent<span class=\"sy1\">[</span>i<span class=\"sy1\">]</span><span class=\"sy3\">.</span><span class=\"me1\">y</span><span class=\"sy1\">,</span> dist<span class=\"sy1\">[</span>i<span class=\"sy1\">]</span><span class=\"sy3\">*</span>inv<span class=\"sy1\">[</span>i<span class=\"sy1\">],</span> iLen<span class=\"sy1\">)</span><br/>    <span class=\"sy1\">}</span><br/>    vis<span class=\"sy1\">(</span>ec<span class=\"sy1\">,</span> data<span class=\"sy1\">,</span> <span class=\"st0\">\"clusters\"</span><span class=\"sy1\">)</span><br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"co1\">// genECData generates random data for extra credit tasks.</span><br/><span class=\"co1\">// k origin points are randomly selected in a bounding box.</span><br/><span class=\"co1\">// nPoints/k coordinates are then generated for each origin point.</span><br/><span class=\"co1\">// The x and y coordinates of the data are normally distributed</span><br/><span class=\"co1\">// with standard deviation stdv.  Thus data coordinates are not</span><br/><span class=\"co1\">// constrained to the origin box; they can range to +/- max float64.</span><br/><span class=\"kw4\">func</span> genECData<span class=\"sy1\">(</span>ec <span class=\"sy3\">*</span>ecParam<span class=\"sy1\">)</span> <span class=\"sy1\">(</span>orig <span class=\"sy1\">[]</span>r2<span class=\"sy1\">,</span> data <span class=\"sy1\">[]</span>r2c<span class=\"sy1\">)</span> <span class=\"sy1\">{</span><br/>    rand<span class=\"sy3\">.</span>Seed<span class=\"sy1\">(</span>time<span class=\"sy3\">.</span>Now<span class=\"sy1\">()</span><span class=\"sy3\">.</span>UnixNano<span class=\"sy1\">())</span><br/>    orig <span class=\"sy2\">=</span> <span class=\"kw3\">make</span><span class=\"sy1\">([]</span>r2<span class=\"sy1\">,</span> ec<span class=\"sy3\">.</span>k<span class=\"sy1\">)</span><br/>    data <span class=\"sy2\">=</span> <span class=\"kw3\">make</span><span class=\"sy1\">([]</span>r2c<span class=\"sy1\">,</span> ec<span class=\"sy3\">.</span>nPoints<span class=\"sy1\">)</span><br/>    <span class=\"kw1\">for</span> <span class=\"nu2\">i</span><span class=\"sy1\">,</span> n <span class=\"sy2\">:=</span> <span class=\"nu0\">0</span><span class=\"sy1\">,</span> <span class=\"nu0\">0</span><span class=\"sy1\">;</span> <span class=\"nu2\">i</span> &lt; ec<span class=\"sy3\">.</span>k<span class=\"sy1\">;</span> <span class=\"nu2\">i</span><span class=\"sy2\">++</span> <span class=\"sy1\">{</span><br/>        x <span class=\"sy2\">:=</span> rand<span class=\"sy3\">.</span>Float64<span class=\"sy1\">()</span> <span class=\"sy3\">*</span> <span class=\"kw4\">float64</span><span class=\"sy1\">(</span>ec<span class=\"sy3\">.</span>xBox<span class=\"sy1\">)</span><br/>        y <span class=\"sy2\">:=</span> rand<span class=\"sy3\">.</span>Float64<span class=\"sy1\">()</span> <span class=\"sy3\">*</span> <span class=\"kw4\">float64</span><span class=\"sy1\">(</span>ec<span class=\"sy3\">.</span>yBox<span class=\"sy1\">)</span><br/>        orig<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span> <span class=\"sy2\">=</span> r2<span class=\"sy1\">{</span>x<span class=\"sy1\">,</span> y<span class=\"sy1\">}</span><br/>        <span class=\"kw1\">for</span> j <span class=\"sy2\">:=</span> ec<span class=\"sy3\">.</span>nPoints <span class=\"sy3\">/</span> ec<span class=\"sy3\">.</span>k<span class=\"sy1\">;</span> j &gt; <span class=\"nu0\">0</span><span class=\"sy1\">;</span> j<span class=\"sy2\">--</span> <span class=\"sy1\">{</span><br/>            data<span class=\"sy1\">[</span>n<span class=\"sy1\">]</span><span class=\"sy3\">.</span>x <span class=\"sy2\">=</span> rand<span class=\"sy3\">.</span>NormFloat64<span class=\"sy1\">()</span><span class=\"sy3\">*</span><span class=\"kw4\">float64</span><span class=\"sy1\">(</span>ec<span class=\"sy3\">.</span>stdv<span class=\"sy1\">)</span> <span class=\"sy3\">+</span> x<br/>            data<span class=\"sy1\">[</span>n<span class=\"sy1\">]</span><span class=\"sy3\">.</span>y <span class=\"sy2\">=</span> rand<span class=\"sy3\">.</span>NormFloat64<span class=\"sy1\">()</span><span class=\"sy3\">*</span><span class=\"kw4\">float64</span><span class=\"sy1\">(</span>ec<span class=\"sy3\">.</span>stdv<span class=\"sy1\">)</span> <span class=\"sy3\">+</span> y<br/>            data<span class=\"sy1\">[</span>n<span class=\"sy1\">]</span><span class=\"sy3\">.</span>c <span class=\"sy2\">=</span> <span class=\"nu2\">i</span><br/>            n<span class=\"sy2\">++</span><br/>        <span class=\"sy1\">}</span><br/>    <span class=\"sy1\">}</span><br/>    <span class=\"kw1\">return</span><br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"co1\">// vis writes a .png for extra credit 2.</span><br/><span class=\"kw4\">func</span> vis<span class=\"sy1\">(</span>ec <span class=\"sy3\">*</span>ecParam<span class=\"sy1\">,</span> data <span class=\"sy1\">[]</span>r2c<span class=\"sy1\">,</span> fn <span class=\"kw4\">string</span><span class=\"sy1\">)</span> <span class=\"sy1\">{</span><br/>    colors <span class=\"sy2\">:=</span> <span class=\"kw3\">make</span><span class=\"sy1\">([]</span>color<span class=\"sy3\">.</span>NRGBA<span class=\"sy1\">,</span> ec<span class=\"sy3\">.</span>k<span class=\"sy1\">)</span><br/>    <span class=\"kw1\">for</span> <span class=\"nu2\">i</span> <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> colors <span class=\"sy1\">{</span><br/>        i3 <span class=\"sy2\">:=</span> <span class=\"nu2\">i</span> <span class=\"sy3\">*</span> <span class=\"nu0\">3</span><br/>        third <span class=\"sy2\">:=</span> i3 <span class=\"sy3\">/</span> ec<span class=\"sy3\">.</span>k<br/>        frac <span class=\"sy2\">:=</span> <span class=\"kw4\">uint8</span><span class=\"sy1\">((</span>i3 <span class=\"sy3\">%</span> ec<span class=\"sy3\">.</span>k<span class=\"sy1\">)</span> <span class=\"sy3\">*</span> <span class=\"nu0\">255</span> <span class=\"sy3\">/</span> ec<span class=\"sy3\">.</span>k<span class=\"sy1\">)</span><br/>        <span class=\"kw1\">switch</span> third <span class=\"sy1\">{</span><br/>        <span class=\"kw1\">case</span> <span class=\"nu0\">0</span><span class=\"sy1\">:</span><br/>            colors<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span> <span class=\"sy2\">=</span> color<span class=\"sy3\">.</span>NRGBA<span class=\"sy1\">{</span>frac<span class=\"sy1\">,</span> <span class=\"nu0\">255</span> <span class=\"sy3\">-</span> frac<span class=\"sy1\">,</span> <span class=\"nu0\">0</span><span class=\"sy1\">,</span> <span class=\"nu0\">255</span><span class=\"sy1\">}</span><br/>        <span class=\"kw1\">case</span> <span class=\"nu0\">1</span><span class=\"sy1\">:</span><br/>            colors<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span> <span class=\"sy2\">=</span> color<span class=\"sy3\">.</span>NRGBA<span class=\"sy1\">{</span><span class=\"nu0\">0</span><span class=\"sy1\">,</span> frac<span class=\"sy1\">,</span> <span class=\"nu0\">255</span> <span class=\"sy3\">-</span> frac<span class=\"sy1\">,</span> <span class=\"nu0\">255</span><span class=\"sy1\">}</span><br/>        <span class=\"kw1\">case</span> <span class=\"nu0\">2</span><span class=\"sy1\">:</span><br/>            colors<span class=\"sy1\">[</span><span class=\"nu2\">i</span><span class=\"sy1\">]</span> <span class=\"sy2\">=</span> color<span class=\"sy3\">.</span>NRGBA<span class=\"sy1\">{</span><span class=\"nu0\">255</span> <span class=\"sy3\">-</span> frac<span class=\"sy1\">,</span> <span class=\"nu0\">0</span><span class=\"sy1\">,</span> frac<span class=\"sy1\">,</span> <span class=\"nu0\">255</span><span class=\"sy1\">}</span><br/>        <span class=\"sy1\">}</span><br/>    <span class=\"sy1\">}</span><br/>    bounds <span class=\"sy2\">:=</span> image<span class=\"sy3\">.</span>Rect<span class=\"sy1\">(</span><span class=\"sy3\">-</span>ec<span class=\"sy3\">.</span>stdv<span class=\"sy1\">,</span> <span class=\"sy3\">-</span>ec<span class=\"sy3\">.</span>stdv<span class=\"sy1\">,</span> ec<span class=\"sy3\">.</span>xBox<span class=\"sy3\">+</span>ec<span class=\"sy3\">.</span>stdv<span class=\"sy1\">,</span> ec<span class=\"sy3\">.</span>yBox<span class=\"sy3\">+</span>ec<span class=\"sy3\">.</span>stdv<span class=\"sy1\">)</span><br/>    im <span class=\"sy2\">:=</span> image<span class=\"sy3\">.</span>NewNRGBA<span class=\"sy1\">(</span>bounds<span class=\"sy1\">)</span><br/>    draw<span class=\"sy3\">.</span>Draw<span class=\"sy1\">(</span>im<span class=\"sy1\">,</span> bounds<span class=\"sy1\">,</span> image<span class=\"sy3\">.</span>NewUniform<span class=\"sy1\">(</span>color<span class=\"sy3\">.</span>White<span class=\"sy1\">),</span> image<span class=\"sy3\">.</span>ZP<span class=\"sy1\">,</span> draw<span class=\"sy3\">.</span>Src<span class=\"sy1\">)</span><br/>    fMinX <span class=\"sy2\">:=</span> <span class=\"kw4\">float64</span><span class=\"sy1\">(</span>bounds<span class=\"sy3\">.</span>Min<span class=\"sy3\">.</span>X<span class=\"sy1\">)</span><br/>    fMaxX <span class=\"sy2\">:=</span> <span class=\"kw4\">float64</span><span class=\"sy1\">(</span>bounds<span class=\"sy3\">.</span>Max<span class=\"sy3\">.</span>X<span class=\"sy1\">)</span><br/>    fMinY <span class=\"sy2\">:=</span> <span class=\"kw4\">float64</span><span class=\"sy1\">(</span>bounds<span class=\"sy3\">.</span>Min<span class=\"sy3\">.</span>Y<span class=\"sy1\">)</span><br/>    fMaxY <span class=\"sy2\">:=</span> <span class=\"kw4\">float64</span><span class=\"sy1\">(</span>bounds<span class=\"sy3\">.</span>Max<span class=\"sy3\">.</span>Y<span class=\"sy1\">)</span><br/>    <span class=\"kw1\">for</span> _<span class=\"sy1\">,</span> p <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> data <span class=\"sy1\">{</span><br/>        imx <span class=\"sy2\">:=</span> math<span class=\"sy3\">.</span>Floor<span class=\"sy1\">(</span>p<span class=\"sy3\">.</span>x<span class=\"sy1\">)</span><br/>        imy <span class=\"sy2\">:=</span> math<span class=\"sy3\">.</span>Floor<span class=\"sy1\">(</span><span class=\"kw4\">float64</span><span class=\"sy1\">(</span>ec<span class=\"sy3\">.</span>yBox<span class=\"sy1\">)</span> <span class=\"sy3\">-</span> p<span class=\"sy3\">.</span>y<span class=\"sy1\">)</span><br/>        <span class=\"kw1\">if</span> imx &gt;<span class=\"sy2\">=</span> fMinX &amp;&amp; imx &lt; fMaxX &amp;&amp; imy &gt;<span class=\"sy2\">=</span> fMinY &amp;&amp; imy &lt; fMaxY <span class=\"sy1\">{</span><br/>            im<span class=\"sy3\">.</span>SetNRGBA<span class=\"sy1\">(</span><span class=\"kw4\">int</span><span class=\"sy1\">(</span>imx<span class=\"sy1\">),</span> <span class=\"kw4\">int</span><span class=\"sy1\">(</span>imy<span class=\"sy1\">),</span> colors<span class=\"sy1\">[</span>p<span class=\"sy3\">.</span>c<span class=\"sy1\">])</span><br/>        <span class=\"sy1\">}</span><br/>    <span class=\"sy1\">}</span><br/>    f<span class=\"sy1\">,</span> err <span class=\"sy2\">:=</span> os<span class=\"sy3\">.</span>Create<span class=\"sy1\">(</span>fn <span class=\"sy3\">+</span> <span class=\"st0\">\".png\"</span><span class=\"sy1\">)</span><br/>    <span class=\"kw1\">if</span> err <span class=\"sy2\">!=</span> <span class=\"kw2\">nil</span> <span class=\"sy1\">{</span><br/>        fmt<span class=\"sy3\">.</span>Println<span class=\"sy1\">(</span>err<span class=\"sy1\">)</span><br/>        <span class=\"kw1\">return</span><br/>    <span class=\"sy1\">}</span><br/>    err <span class=\"sy2\">=</span> png<span class=\"sy3\">.</span>Encode<span class=\"sy1\">(</span>f<span class=\"sy1\">,</span> im<span class=\"sy1\">)</span><br/>    <span class=\"kw1\">if</span> err <span class=\"sy2\">!=</span> <span class=\"kw2\">nil</span> <span class=\"sy1\">{</span><br/>        fmt<span class=\"sy3\">.</span>Println<span class=\"sy1\">(</span>err<span class=\"sy1\">)</span><br/>    <span class=\"sy1\">}</span><br/>    err <span class=\"sy2\">=</span> f<span class=\"sy3\">.</span>Close<span class=\"sy1\">()</span><br/>    <span class=\"kw1\">if</span> err <span class=\"sy2\">!=</span> <span class=\"kw2\">nil</span> <span class=\"sy1\">{</span><br/>        fmt<span class=\"sy3\">.</span>Println<span class=\"sy1\">(</span>err<span class=\"sy1\">)</span><br/>    <span class=\"sy1\">}</span><br/><span class=\"sy1\">}</span></pre>"}, {"lang": "Haskell", "loc": 58, "block": "<pre class=\"haskell highlighted_source\"><span class=\"coMULTI\">{-# LANGUAGE Strict,FlexibleInstances #-}</span><br/><span class=\"kw1\">module</span> KMeans <span class=\"kw1\">where</span><br/>\u00a0<br/><span class=\"kw1\">import</span> Control<span class=\"sy0\">.</span>Applicative<br/><span class=\"kw1\">import</span> Control<span class=\"sy0\">.</span><a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Monad\"><span class=\"kw4\">Monad</span></a><span class=\"sy0\">.</span>Random<br/><span class=\"kw1\">import</span> Data<span class=\"sy0\">.</span>List <span class=\"br0\">(</span>minimumBy<span class=\"sy0\">,</span> genericLength<span class=\"sy0\">,</span> transpose<span class=\"br0\">)</span><br/><span class=\"kw1\">import</span> Data<span class=\"sy0\">.</span><a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Ord\"><span class=\"kw4\">Ord</span></a> <span class=\"br0\">(</span>comparing<span class=\"br0\">)</span><br/><span class=\"kw1\">import</span> <span class=\"kw1\">qualified</span> Data<span class=\"sy0\">.</span>Map<span class=\"sy0\">.</span>Strict <span class=\"kw1\">as</span> M<br/>\u00a0<br/>\u00a0<br/><span class=\"kw1\">type</span> Vec <span class=\"sy0\">=</span> <span class=\"br0\">[</span><a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float\"><span class=\"kw4\">Float</span></a><span class=\"br0\">]</span><br/><span class=\"kw1\">type</span> Cluster <span class=\"sy0\">=</span> <span class=\"br0\">[</span>Vec<span class=\"br0\">]</span><br/>\u00a0<br/>kMeansIteration <span class=\"sy0\">::</span> <span class=\"br0\">[</span>Vec<span class=\"br0\">]</span> <span class=\"sy0\">-&gt;</span> <span class=\"br0\">[</span>Vec<span class=\"br0\">]</span> <span class=\"sy0\">-&gt;</span> <span class=\"br0\">[</span>Cluster<span class=\"br0\">]</span><br/>kMeansIteration pts <span class=\"sy0\">=</span> clusterize <span class=\"sy0\">.</span> fixPoint iteration<br/>  <span class=\"kw1\">where</span><br/>    iteration <span class=\"sy0\">=</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:map\"><span class=\"kw3\">map</span></a> centroid <span class=\"sy0\">.</span> clusterize<br/>\u00a0<br/>    clusterize centroids <span class=\"sy0\">=</span> M<span class=\"sy0\">.</span>elems <span class=\"sy0\">$</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:foldr\"><span class=\"kw3\">foldr</span></a> add m0 pts<br/>      <span class=\"kw1\">where</span> add x <span class=\"sy0\">=</span> M<span class=\"sy0\">.</span>insertWith <span class=\"br0\">(</span><span class=\"sy0\">++</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>centroids `nearestTo` x<span class=\"br0\">)</span> <span class=\"br0\">[</span>x<span class=\"br0\">]</span><br/>            m0 <span class=\"sy0\">=</span> M<span class=\"sy0\">.</span>unions <span class=\"sy0\">$</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:map\"><span class=\"kw3\">map</span></a> <span class=\"br0\">(</span>`M<span class=\"sy0\">.</span>singleton` <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"br0\">)</span> centroids<br/>\u00a0<br/>nearestTo <span class=\"sy0\">::</span> <span class=\"br0\">[</span>Vec<span class=\"br0\">]</span> <span class=\"sy0\">-&gt;</span> Vec <span class=\"sy0\">-&gt;</span> Vec<br/>nearestTo pts x <span class=\"sy0\">=</span>  minimumBy <span class=\"br0\">(</span>comparing <span class=\"br0\">(</span>distance x<span class=\"br0\">)</span><span class=\"br0\">)</span> pts<br/>\u00a0<br/>distance <span class=\"sy0\">::</span> Vec <span class=\"sy0\">-&gt;</span> Vec <span class=\"sy0\">-&gt;</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Float\"><span class=\"kw4\">Float</span></a><br/>distance a b <span class=\"sy0\">=</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:sum\"><span class=\"kw3\">sum</span></a> <span class=\"sy0\">$</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:map\"><span class=\"kw3\">map</span></a> <span class=\"br0\">(</span><span class=\"sy0\">^</span><span class=\"nu0\">2</span><span class=\"br0\">)</span> <span class=\"sy0\">$</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:zipWith\"><span class=\"kw3\">zipWith</span></a> <span class=\"br0\">(</span><span class=\"sy0\">-</span><span class=\"br0\">)</span> a b<br/>\u00a0<br/>centroid <span class=\"sy0\">::</span> <span class=\"br0\">[</span>Vec<span class=\"br0\">]</span> <span class=\"sy0\">-&gt;</span> Vec<br/>centroid <span class=\"sy0\">=</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:map\"><span class=\"kw3\">map</span></a> mean <span class=\"sy0\">.</span> transpose<br/>  <span class=\"kw1\">where</span>  mean pts <span class=\"sy0\">=</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:sum\"><span class=\"kw3\">sum</span></a> pts <span class=\"sy0\">/</span> genericLength pts<br/>\u00a0<br/>fixPoint <span class=\"sy0\">::</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Eq\"><span class=\"kw4\">Eq</span></a> a <span class=\"sy0\">=&gt;</span> <span class=\"br0\">(</span>a <span class=\"sy0\">-&gt;</span> a<span class=\"br0\">)</span> <span class=\"sy0\">-&gt;</span> a <span class=\"sy0\">-&gt;</span> a<br/>fixPoint f x <span class=\"sy0\">=</span> <span class=\"kw1\">if</span> x <span class=\"sy0\">==</span> fx <span class=\"kw1\">then</span> x <span class=\"kw1\">else</span> fixPoint f fx <span class=\"kw1\">where</span> fx <span class=\"sy0\">=</span> f x<br/>\u00a0<br/><span class=\"co1\">-- initial sampling</span><br/>\u00a0<br/>kMeans <span class=\"sy0\">::</span> MonadRandom m <span class=\"sy0\">=&gt;</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int\"><span class=\"kw4\">Int</span></a> <span class=\"sy0\">-&gt;</span> <span class=\"br0\">[</span>Vec<span class=\"br0\">]</span> <span class=\"sy0\">-&gt;</span> m <span class=\"br0\">[</span>Cluster<span class=\"br0\">]</span><br/>kMeans n pts <span class=\"sy0\">=</span> kMeansIteration pts <span class=\"sy0\">&lt;$&gt;</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:take\"><span class=\"kw3\">take</span></a> n <span class=\"sy0\">&lt;$&gt;</span> randomElements pts<br/>\u00a0<br/>kMeansPP <span class=\"sy0\">::</span> MonadRandom m <span class=\"sy0\">=&gt;</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Int\"><span class=\"kw4\">Int</span></a> <span class=\"sy0\">-&gt;</span> <span class=\"br0\">[</span>Vec<span class=\"br0\">]</span> <span class=\"sy0\">-&gt;</span> m <span class=\"br0\">[</span>Cluster<span class=\"br0\">]</span><br/>kMeansPP n pts <span class=\"sy0\">=</span> kMeansIteration pts <span class=\"sy0\">&lt;$&gt;</span> centroids<br/>  <span class=\"kw1\">where</span> centroids <span class=\"sy0\">=</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:iterate\"><span class=\"kw3\">iterate</span></a> <span class=\"br0\">(</span><span class=\"sy0\">&gt;&gt;=</span> nextCentroid<span class=\"br0\">)</span> x0 <span class=\"sy0\">!!</span> <span class=\"br0\">(</span>n<span class=\"sy0\">-</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><br/>        x0 <span class=\"sy0\">=</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:take\"><span class=\"kw3\">take</span></a> <span class=\"nu0\">1</span> <span class=\"sy0\">&lt;$&gt;</span> randomElements pts<br/>        nextCentroid cs <span class=\"sy0\">=</span> <span class=\"br0\">(</span>: cs<span class=\"br0\">)</span> <span class=\"sy0\">&lt;$&gt;</span> fromList <span class=\"br0\">(</span><a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:map\"><span class=\"kw3\">map</span></a> <span class=\"br0\">(</span>weight cs<span class=\"br0\">)</span> pts<span class=\"br0\">)</span><br/>        weight cs x <span class=\"sy0\">=</span> <span class=\"br0\">(</span>x<span class=\"sy0\">,</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:toRational\"><span class=\"kw3\">toRational</span></a> <span class=\"sy0\">$</span> distance x <span class=\"br0\">(</span>cs `nearestTo` x<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/>randomElements <span class=\"sy0\">::</span> MonadRandom m <span class=\"sy0\">=&gt;</span> <span class=\"br0\">[</span>a<span class=\"br0\">]</span> <span class=\"sy0\">-&gt;</span> m <span class=\"br0\">[</span>a<span class=\"br0\">]</span><br/>randomElements pts <span class=\"sy0\">=</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:map\"><span class=\"kw3\">map</span></a> <span class=\"br0\">(</span>pts <span class=\"sy0\">!!</span><span class=\"br0\">)</span> <span class=\"sy0\">&lt;$&gt;</span> getRandomRs <span class=\"br0\">(</span><span class=\"nu0\">0</span><span class=\"sy0\">,</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:length\"><span class=\"kw3\">length</span></a> pts<span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">-- sample cluster generation</span><br/>\u00a0<br/><span class=\"kw1\">instance</span> <span class=\"br0\">(</span>RandomGen g<span class=\"sy0\">,</span> Monoid m<span class=\"br0\">)</span> <span class=\"sy0\">=&gt;</span> Monoid <span class=\"br0\">(</span>Rand g m<span class=\"br0\">)</span> <span class=\"kw1\">where</span><br/>   mempty <span class=\"sy0\">=</span> pure mempty<br/>   mappend <span class=\"sy0\">=</span> liftA2 mappend<br/>\u00a0<br/>mkCluster n s m <span class=\"sy0\">=</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:take\"><span class=\"kw3\">take</span></a> n <span class=\"sy0\">.</span> transpose <span class=\"sy0\">&lt;$&gt;</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:mapM\"><span class=\"kw3\">mapM</span></a> randomsAround m<br/>  <span class=\"kw1\">where</span> randomsAround x0 <span class=\"sy0\">=</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:map\"><span class=\"kw3\">map</span></a> <span class=\"br0\">(</span>\\x <span class=\"sy0\">-&gt;</span> x0<span class=\"sy0\">+</span>s<span class=\"sy0\">*</span><a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:atanh\"><span class=\"kw3\">atanh</span></a> x<span class=\"br0\">)</span> <span class=\"sy0\">&lt;$&gt;</span> getRandomRs <span class=\"br0\">(</span><span class=\"sy0\">-</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span><span class=\"nu0\">1</span><span class=\"br0\">)</span></pre>"}, {"lang": "J", "loc": 11, "block": "<pre class=\"j highlighted_source\">   <span class=\"co1\">NB.  Selection of initial centroids, per K-means++</span><br/>   initialCentroids     =:  <span class=\"sy0\">(</span>] , randomCentroid<span class=\"sy0\">)</span>^:<span class=\"sy0\">(</span>&lt;:@:]`<span class=\"sy0\">(</span>,:@:<a class=\"__cf_email__\" data-cfemail=\"77041212133412190305181e1337\" href=\"/cdn-cgi/l/email-protection\">[email\u00a0protected]</a>:[<span class=\"sy0\">))</span>~<br/>     seedCentroid       =:  {~\u00a0<a class=\"__cf_email__\" data-cfemail=\"0c334c\" href=\"/cdn-cgi/l/email-protection\">[email\u00a0protected]</a>#<br/>     randomCentroid     =:  [ {~ [: wghtProb [: &lt;./ distance/~<br/>       distance         =:  +/&amp;.:*:@:-\"<span class=\"nu0\">1</span>  <span class=\"co1\">NB.  Extra credit #3 (N-dimensional is the same as 2-dimensional in J)</span><br/>       wghtProb         =:  <span class=\"nu0\">1</span>&amp;$:\u00a0: <span class=\"sy0\">((</span>%{:<span class=\"sy0\">)</span>@:<span class=\"sy0\">(</span>+/\\<span class=\"sy0\">)</span>@:] I. [\u00a0<a class=\"__cf_email__\" data-cfemail=\"3f007f\" href=\"/cdn-cgi/l/email-protection\">[email\u00a0protected]</a>$ 0:<span class=\"sy0\">)</span>\"<span class=\"nu0\">0</span> <span class=\"nu0\">1</span> <span class=\"co1\">NB.  Due to Roger Hui http://j.mp/lj5Pnt</span><br/>\u00a0<br/>   <span class=\"co1\">NB.  Having selected the initial centroids, the standard K-means algo follows</span><br/>   centroids            =:  <span class=\"sy0\">(</span>[ mean/.~ closestCentroid<span class=\"sy0\">)</span>^:<span class=\"sy0\">(</span>]`_:`initialCentroids<span class=\"sy0\">)</span><br/>     closestCentroid    =:  [: <span class=\"sy0\">(</span>i.&lt;./<span class=\"sy0\">)</span>\"<span class=\"nu0\">1</span> distance/<br/>     mean               =:  +/\u00a0% #</pre>"}, {"lang": "JavaScript", "loc": 749, "block": "<pre class=\"javascript highlighted_source\">\u00a0<br/><span class=\"coMULTI\">/**<br/> * kmeans module<br/> * <br/> *   cluster(model, k, converged = assignmentsConverged)<br/> *   distance(p, q),<br/> *   distanceSquared(p, q),<br/> *   centroidsConverged(delta)<br/> *   assignmentsConverged(model, newModel)<br/> *   assignmentsToClusters(model)<br/> */</span><br/>define<span class=\"br0\">(</span><span class=\"kw1\">function</span> <span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <span class=\"st0\">\"use strict\"</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * @public<br/>     * Calculate the squared distance between two vectors.<br/>     *<br/>     * @param [number] p vector with same dimension as q<br/>     * @param [number] q vector with same dimension as p<br/>     * @return {number} the distance between p and q squared<br/>     */</span><br/>    <span class=\"kw1\">function</span> distanceSquared<span class=\"br0\">(</span>p<span class=\"sy0\">,</span> q<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">const</span> d <span class=\"sy0\">=</span> p.<span class=\"me1\">length</span><span class=\"sy0\">;</span> <span class=\"co1\">// dimension of vectors</span><br/>\u00a0<br/>        <span class=\"kw1\">if</span><span class=\"br0\">(</span>d <span class=\"sy0\">!==</span> q.<span class=\"me1\">length</span><span class=\"br0\">)</span> <span class=\"kw1\">throw</span> Error<span class=\"br0\">(</span><span class=\"st0\">\"p and q vectors must be the same length\"</span><span class=\"br0\">)</span><br/>\u00a0<br/>        let sum <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> d<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            sum <span class=\"sy0\">+=</span> <span class=\"br0\">(</span>p<span class=\"br0\">[</span>i<span class=\"br0\">]</span> <span class=\"sy0\">-</span> q<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"br0\">)</span><span class=\"sy0\">**</span><span class=\"nu0\">2</span><br/>        <span class=\"br0\">}</span><br/>        <span class=\"kw1\">return</span> sum<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * @public<br/>     * Calculate the distance between two vectors of the same dimension.<br/>     *<br/>     * @param [number] p vector of same dimension as q<br/>     * @param [number] q vector of same dimension as p<br/>     * @return the distance between vectors p and q<br/>     */</span><br/>    <span class=\"kw1\">function</span> distance<span class=\"br0\">(</span>p<span class=\"sy0\">,</span> q<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">return</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">sqrt</span><span class=\"br0\">(</span>distanceSquared<span class=\"br0\">(</span>p<span class=\"sy0\">,</span> q<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * @private<br/>     * find the closest centroid for the given observation and return it's index.<br/>     *<br/>     * @param [[number]] centroids - array of k vectors, each vector with same dimension as observations.<br/>     *                               these are the center of the k clusters<br/>     * @param [[number]] observation - vector with same dimension as centroids.<br/>     *                                 this is the observation to be clustered.<br/>     * @return {number} the index of the closest centroid in centroids<br/>     */</span><br/>    <span class=\"kw1\">function</span> findClosestCentroid<span class=\"br0\">(</span>centroids<span class=\"sy0\">,</span> observation<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">const</span> k <span class=\"sy0\">=</span> centroids.<span class=\"me1\">length</span><span class=\"sy0\">;</span> <span class=\"co1\">// number of clusters/centroids</span><br/>\u00a0<br/>        let centroid <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>        let minDistance <span class=\"sy0\">=</span> distance<span class=\"br0\">(</span>centroids<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span><span class=\"sy0\">,</span> observation<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">1</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> k<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">const</span> dist <span class=\"sy0\">=</span> distance<span class=\"br0\">(</span>centroids<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"sy0\">,</span> observation<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">if</span><span class=\"br0\">(</span>dist <span class=\"sy0\">&lt;</span> minDistance<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                centroid <span class=\"sy0\">=</span> i<span class=\"sy0\">;</span><br/>                minDistance <span class=\"sy0\">=</span> dist<span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>        <span class=\"br0\">}</span><br/>        <span class=\"kw1\">return</span> centroid<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * @private<br/>     * Calculate the centroid for the given observations.<br/>     * This takes the average of all observations (at each dimension).<br/>     * This average vector is the centroid for those observations.<br/>     *<br/>     * @param [[number]] observations - array of observations (each observatino is a vectors)<br/>     * @return [number] centroid for given observations (vector of same dimension as observations)<br/>     */</span><br/>    <span class=\"kw1\">function</span> calculateCentroid<span class=\"br0\">(</span>observations<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">const</span> n <span class=\"sy0\">=</span> observations.<span class=\"me1\">length</span><span class=\"sy0\">;</span>      <span class=\"co1\">// number of observations</span><br/>        <span class=\"kw1\">const</span> d <span class=\"sy0\">=</span> observations<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span>.<span class=\"me1\">length</span><span class=\"sy0\">;</span>   <span class=\"co1\">// dimension of vectors</span><br/>\u00a0<br/>        <span class=\"co1\">// create zero vector of same dimension as observation</span><br/>        let centroid <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> d<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            centroid.<span class=\"me1\">push</span><span class=\"br0\">(</span><span class=\"nu0\">0.0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"co1\">//</span><br/>        <span class=\"co1\">// sum all observations at each dimension</span><br/>        <span class=\"co1\">//</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> n<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"co1\">//</span><br/>            <span class=\"co1\">// add the observation to the sum vector, element by element</span><br/>            <span class=\"co1\">// to prepare to calculate the average at each dimension.</span><br/>            <span class=\"co1\">//</span><br/>            <span class=\"kw1\">for</span><span class=\"br0\">(</span>let j <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> j <span class=\"sy0\">&lt;</span> d<span class=\"sy0\">;</span> j <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                centroid<span class=\"br0\">[</span>j<span class=\"br0\">]</span> <span class=\"sy0\">+=</span> observations<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"br0\">[</span>j<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"co1\">//</span><br/>        <span class=\"co1\">// divide each dimension by the number of observations</span><br/>        <span class=\"co1\">// to create the average vector.</span><br/>        <span class=\"co1\">//</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let j <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> j <span class=\"sy0\">&lt;</span> d<span class=\"sy0\">;</span> j <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            centroid<span class=\"br0\">[</span>j<span class=\"br0\">]</span> <span class=\"sy0\">/=</span> n<span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">return</span> centroid<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * @private<br/>     * calculate the cluster assignments for the observations, given the centroids.<br/>     *<br/>     * @param [[number]] centroids - list of vectors with same dimension as observations<br/>     * @param [[number]] observations - list of vectors with same dimension as centroids<br/>     * @return [number] list of indices into centroids; one per observation.<br/>     */</span><br/>    <span class=\"kw1\">function</span> assignClusters<span class=\"br0\">(</span>centroids<span class=\"sy0\">,</span> observations<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">const</span> n <span class=\"sy0\">=</span> observations.<span class=\"me1\">length</span><span class=\"sy0\">;</span>  <span class=\"co1\">// number of observations</span><br/>\u00a0<br/>        <span class=\"kw1\">const</span> assignments <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> n<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            assignments.<span class=\"me1\">push</span><span class=\"br0\">(</span>findClosestCentroid<span class=\"br0\">(</span>centroids<span class=\"sy0\">,</span> observations<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">return</span> assignments<span class=\"sy0\">;</span> <span class=\"co1\">// centroid index for each observation</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * @private<br/>     * calculate one step of the k-means algorithm;<br/>     * - assign each observation to the nearest centroid to create clusters<br/>     * - calculate a new centroid for each cluster given the observations in the cluster.<br/>     *<br/>     * @param [[number]] centroids - list of vectors with same dimension as observations<br/>     * @param [[number]] observations - list of vectors with same dimension as centroids<br/>     * @return a new model with observations, centroids and assignments<br/>     */</span><br/>    <span class=\"kw1\">function</span> kmeansStep<span class=\"br0\">(</span>centroids<span class=\"sy0\">,</span> observations<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">const</span> k <span class=\"sy0\">=</span> centroids.<span class=\"me1\">length</span><span class=\"sy0\">;</span> <span class=\"co1\">// number of clusters/centroids</span><br/>\u00a0<br/>        <span class=\"co1\">// assign each observation to the nearest centroid to create clusters</span><br/>        <span class=\"kw1\">const</span> assignments <span class=\"sy0\">=</span> assignClusters<span class=\"br0\">(</span>centroids<span class=\"sy0\">,</span> observations<span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">// array of cluster indices that correspond observations</span><br/>\u00a0<br/>        <span class=\"co1\">// calculate a new centroid for each cluster given the observations in the cluster</span><br/>        <span class=\"kw1\">const</span> newCentroids <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> k<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"co1\">// get the observations for this cluster/centroid</span><br/>            <span class=\"kw1\">const</span> clusteredObservations <span class=\"sy0\">=</span> observations.<span class=\"me1\">filter</span><span class=\"br0\">(</span><span class=\"br0\">(</span>v<span class=\"sy0\">,</span> j<span class=\"br0\">)</span> <span class=\"sy0\">=&gt;</span> assignments<span class=\"br0\">[</span>j<span class=\"br0\">]</span> <span class=\"sy0\">===</span> i<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>            <span class=\"co1\">// calculate a new centroid for the observations</span><br/>            newCentroids.<span class=\"me1\">push</span><span class=\"br0\">(</span>calculateCentroid<span class=\"br0\">(</span>clusteredObservations<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>        <span class=\"kw1\">return</span> <span class=\"br0\">{</span><span class=\"st0\">'observations'</span><span class=\"sy0\">:</span> observations<span class=\"sy0\">,</span> <span class=\"st0\">'centroids'</span><span class=\"sy0\">:</span> newCentroids<span class=\"sy0\">,</span> <span class=\"st0\">'assignments'</span><span class=\"sy0\">:</span> assignments <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * @public<br/>     * Run k-means on the given model until each centroid converges to with the given delta<br/>     * The initial model is NOT modified by the algorithm, rather a new model is returned.<br/>     * <br/>     * @param {*} model - object with <br/>     *                    observations: array, length n, of data points; each datapoint is <br/>     *                                  itself an array of numbers (a vector).<br/>     *                                  The length each datapoint (d) vector should be the same.  <br/>     *                    centroids: array of data points.<br/>     *                               The length of the centroids array indicates the number of<br/>     *                               of desired clusters (k).<br/>     *                               each datapoint is array (vector) of numbers <br/>     *                               with same dimension as the datapoints in observations. <br/>     *                    assignments: array of integers, one per observation, <br/>     *                                 with values 0..centroids.length - 1<br/>     * @param number delta - the maximum difference between each centroid in consecutive runs for convergence<br/>     * @return {*} - result with <br/>     *               model: model, as described above, with updated centroids and assignments, <br/>     *               iterations: number of iterations, <br/>     *               durationMs: elapsed time in milliseconds<br/>     */</span><br/>    <span class=\"kw1\">function</span> kmeans<span class=\"br0\">(</span>model<span class=\"sy0\">,</span> maximumIterations <span class=\"sy0\">=</span> <span class=\"nu0\">200</span><span class=\"sy0\">,</span> converged <span class=\"sy0\">=</span> assignmentsConverged<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">const</span> start <span class=\"sy0\">=</span> <span class=\"kw1\">new</span> <span class=\"kw4\">Date</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"co1\">// calculate new centroids and cluster assignments</span><br/>        let newModel <span class=\"sy0\">=</span> kmeansStep<span class=\"br0\">(</span>model.<span class=\"me1\">centroids</span><span class=\"sy0\">,</span> model.<span class=\"me1\">observations</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"co1\">// continue until centroids do not change (within given delta)</span><br/>        let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>        while<span class=\"br0\">(</span><span class=\"br0\">(</span>i <span class=\"sy0\">&lt;</span> maximumIterations<span class=\"br0\">)</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"sy0\">!</span>converged<span class=\"br0\">(</span>model<span class=\"sy0\">,</span> newModel<span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            model <span class=\"sy0\">=</span> newModel<span class=\"sy0\">;</span>   <span class=\"co1\">// new model is our model now</span><br/>            <span class=\"co1\">// console.log(model);</span><br/>\u00a0<br/>            <span class=\"co1\">// calculate new centroids and cluster assignments</span><br/>            newModel <span class=\"sy0\">=</span> kmeansStep<span class=\"br0\">(</span>model.<span class=\"me1\">centroids</span><span class=\"sy0\">,</span> model.<span class=\"me1\">observations</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"co1\">// console.log(newModel);</span><br/>        <span class=\"kw1\">const</span> finish <span class=\"sy0\">=</span> <span class=\"kw1\">new</span> <span class=\"kw4\">Date</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">return</span> <span class=\"br0\">{</span><span class=\"st0\">'model'</span><span class=\"sy0\">:</span> newModel<span class=\"sy0\">,</span> <span class=\"st0\">'iterations'</span><span class=\"sy0\">:</span> i<span class=\"sy0\">,</span> <span class=\"st0\">'durationMs'</span><span class=\"sy0\">:</span> <span class=\"br0\">(</span>finish.<span class=\"me1\">getTime</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">-</span> start.<span class=\"me1\">getTime</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">}</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * @public<br/>     * Return a function that determines convergence based on the centroids.<br/>     * If two consecutive sets of centroids remain within a given delta,<br/>     * then the algorithm is converged.<br/>     * <br/>     * @param number delta, the maximum difference between each centroid in consecutive runs for convergence<br/>     * @return function to use as the converged function in kmeans call.<br/>     */</span><br/>    <span class=\"kw1\">function</span> centroidsConverged<span class=\"br0\">(</span>delta<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"coMULTI\">/**<br/>         * determine if two consecutive set of centroids are converged given a maximum delta.<br/>         *<br/>         * @param [[number]] centroids - list of vectors with same dimension as observations<br/>         * @param [[number]] newCentroids - list of vectors with same dimension as observations<br/>         * @param number delta - the maximum difference between each centroid in consecutive runs for convergence<br/>         */</span><br/>        <span class=\"kw1\">return</span> <span class=\"kw1\">function</span><span class=\"br0\">(</span>model<span class=\"sy0\">,</span> newModel<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">const</span> centroids <span class=\"sy0\">=</span> model.<span class=\"me1\">centroids</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">const</span> newCentroids <span class=\"sy0\">=</span> newModel.<span class=\"me1\">centroids</span><span class=\"sy0\">;</span><br/>\u00a0<br/>            <span class=\"kw1\">const</span> k <span class=\"sy0\">=</span> centroids.<span class=\"me1\">length</span><span class=\"sy0\">;</span> <span class=\"co1\">// number of clusters/centroids</span><br/>            <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> k<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                <span class=\"kw1\">if</span><span class=\"br0\">(</span>distance<span class=\"br0\">(</span>centroids<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"sy0\">,</span> newCentroids<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"br0\">)</span> <span class=\"sy0\">&gt;</span> delta<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                    <span class=\"kw1\">return</span> <span class=\"kw2\">false</span><span class=\"sy0\">;</span><br/>                <span class=\"br0\">}</span><br/>            <span class=\"br0\">}</span><br/>\u00a0<br/>            <span class=\"kw1\">return</span> <span class=\"kw2\">true</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * @public<br/>     * determine if two consecutive set of clusters are converged;<br/>     * the clusters are converged if the cluster assignments are the same.<br/>     *<br/>     * @param {*} model - object with observations, centroids, assignments<br/>     * @param {*} newModel - object with observations, centroids, assignments<br/>     * @param number delta - the maximum difference between each centroid in consecutive runs for convergence<br/>     */</span><br/>    <span class=\"kw1\">function</span> assignmentsConverged<span class=\"br0\">(</span>model<span class=\"sy0\">,</span> newModel<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">function</span> arraysEqual<span class=\"br0\">(</span>a<span class=\"sy0\">,</span> b<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>a <span class=\"sy0\">===</span> b<span class=\"br0\">)</span> <span class=\"kw1\">return</span> <span class=\"kw2\">true</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>a <span class=\"sy0\">===</span> <span class=\"kw2\">undefined</span> <span class=\"sy0\">||</span> b <span class=\"sy0\">===</span> <span class=\"kw2\">undefined</span><span class=\"br0\">)</span> <span class=\"kw1\">return</span> <span class=\"kw2\">false</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>a <span class=\"sy0\">===</span> <span class=\"kw2\">null</span> <span class=\"sy0\">||</span> b <span class=\"sy0\">===</span> <span class=\"kw2\">null</span><span class=\"br0\">)</span> <span class=\"kw1\">return</span> <span class=\"kw2\">false</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>a.<span class=\"me1\">length</span> <span class=\"sy0\">!==</span> b.<span class=\"me1\">length</span><span class=\"br0\">)</span> <span class=\"kw1\">return</span> <span class=\"kw2\">false</span><span class=\"sy0\">;</span><br/>\u00a0<br/>            <span class=\"co1\">// If you don't care about the order of the elements inside</span><br/>            <span class=\"co1\">// the array, you should sort both arrays here.</span><br/>\u00a0<br/>            <span class=\"kw1\">for</span> <span class=\"br0\">(</span><span class=\"kw1\">var</span> i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> a.<span class=\"me1\">length</span><span class=\"sy0\">;</span> <span class=\"sy0\">++</span>i<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>a<span class=\"br0\">[</span>i<span class=\"br0\">]</span> <span class=\"sy0\">!==</span> b<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"br0\">)</span> <span class=\"kw1\">return</span> <span class=\"kw2\">false</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>            <span class=\"kw1\">return</span> <span class=\"kw2\">true</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">return</span> arraysEqual<span class=\"br0\">(</span>model.<span class=\"me1\">assignments</span><span class=\"sy0\">,</span> newModel.<span class=\"me1\">assignments</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * Use the model assignments to create<br/>     * array of observation indices for each centroid<br/>     * <br/>     * @param {object} model with observations, centroids and assignments<br/>     * @reutrn [[number]] array of observation indices for each cluster<br/>     */</span><br/>    <span class=\"kw1\">function</span> assignmentsToClusters<span class=\"br0\">(</span>model<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"co1\">// </span><br/>        <span class=\"co1\">// put offset of each data points into clusters using the assignments</span><br/>        <span class=\"co1\">//</span><br/>        <span class=\"kw1\">const</span> n <span class=\"sy0\">=</span> model.<span class=\"me1\">observations</span>.<span class=\"me1\">length</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> k <span class=\"sy0\">=</span> model.<span class=\"me1\">centroids</span>.<span class=\"me1\">length</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> assignments <span class=\"sy0\">=</span> model.<span class=\"me1\">assignments</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> clusters <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> k<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            clusters.<span class=\"me1\">push</span><span class=\"br0\">(</span><span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"br0\">)</span><br/>        <span class=\"br0\">}</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> n<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            clusters<span class=\"br0\">[</span>assignments<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"br0\">]</span>.<span class=\"me1\">push</span><span class=\"br0\">(</span>i<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">return</span> clusters<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>\u00a0<br/>    <span class=\"co1\">//</span><br/>    <span class=\"co1\">// return public methods</span><br/>    <span class=\"co1\">//</span><br/>    <span class=\"kw1\">return</span> <span class=\"br0\">{</span><br/>        <span class=\"st0\">'cluster'</span><span class=\"sy0\">:</span> kmeans<span class=\"sy0\">,</span> <br/>        <span class=\"st0\">'distance'</span><span class=\"sy0\">:</span> distance<span class=\"sy0\">,</span><br/>        <span class=\"st0\">'distanceSquared'</span><span class=\"sy0\">:</span> distanceSquared<span class=\"sy0\">,</span><br/>        <span class=\"st0\">'centroidsConverged'</span><span class=\"sy0\">:</span> centroidsConverged<span class=\"sy0\">,</span><br/>        <span class=\"st0\">'assignmentsConverged'</span><span class=\"sy0\">:</span> assignmentsConverged<span class=\"sy0\">,</span><br/>        <span class=\"st0\">\"assignmentsToClusters\"</span><span class=\"sy0\">:</span> assignmentsToClusters<br/>    <span class=\"br0\">}</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"br0\">}</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"coMULTI\">/**<br/> * kmeans++ initialization module<br/> */</span><br/>define<span class=\"br0\">(</span><span class=\"kw1\">function</span> <span class=\"br0\">(</span>require<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <span class=\"st0\">\"use strict\"</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"kw1\">const</span> kmeans <span class=\"sy0\">=</span> require<span class=\"br0\">(</span><span class=\"st0\">\"./kmeans\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * @public<br/>     * create an initial model given the data and the number of clusters.<br/>     * <br/>     * This uses the kmeans++ algorithm:<br/>     * 1. Choose one center uniformly at random from among the data points.<br/>     * 2. For each data point x, compute D(x), the distance between x and <br/>     *    the nearest center that has already been chosen.<br/>     * 3. Choose one new data point at random as a new center, <br/>     *    using a weighted probability distribution where a point x is chosen with probability proportional to D(x)^2.<br/>     * 4. Repeat Steps 2 and 3 until k centers have been chosen.<br/>     * 5. Now that the initial centers have been chosen, proceed using<br/>     *    standard k-means clustering.<br/>     * <br/>     * @param {[float]} observations the data as an array of number<br/>     * @param {integer} k the number of clusters<br/>     */</span><br/>    <span class=\"kw1\">return</span> <span class=\"kw1\">function</span><span class=\"br0\">(</span>observations<span class=\"sy0\">,</span> k<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>\u00a0<br/>        <span class=\"coMULTI\">/**<br/>         * given a set of n  weights,<br/>         * choose a value in the range 0..n-1<br/>         * at random using weights as a distribution.<br/>         * <br/>         * @param {*} weights <br/>         */</span><br/>        <span class=\"kw1\">function</span> weightedRandomIndex<span class=\"br0\">(</span>weights<span class=\"sy0\">,</span> normalizationWeight<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">const</span> n <span class=\"sy0\">=</span> weights.<span class=\"me1\">length</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">if</span><span class=\"br0\">(</span><span class=\"kw1\">typeof</span> normalizationWeight <span class=\"sy0\">!==</span> <span class=\"st0\">'number'</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                normalizationWeight <span class=\"sy0\">=</span> <span class=\"nu0\">0.0</span><span class=\"sy0\">;</span><br/>                <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> n<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                    normalizationWeight <span class=\"sy0\">+=</span> weights<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>                <span class=\"br0\">}</span><br/>            <span class=\"br0\">}</span><br/>\u00a0<br/>            <span class=\"kw1\">const</span> r <span class=\"sy0\">=</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span>  <span class=\"co1\">// uniformly random number 0..1 (a probability)</span><br/>            let index <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>            let cumulativeWeight <span class=\"sy0\">=</span> <span class=\"nu0\">0.0</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> n<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                <span class=\"co1\">//</span><br/>                <span class=\"co1\">// use the uniform probability to search </span><br/>                <span class=\"co1\">// within the normalized weighting (we divide by totalWeight to normalize).</span><br/>                <span class=\"co1\">// once we hit the probability, we have found our index.</span><br/>                <span class=\"co1\">//</span><br/>                cumulativeWeight <span class=\"sy0\">+=</span> weights<span class=\"br0\">[</span>i<span class=\"br0\">]</span> <span class=\"sy0\">/</span> normalizationWeight<span class=\"sy0\">;</span><br/>                <span class=\"kw1\">if</span><span class=\"br0\">(</span>cumulativeWeight <span class=\"sy0\">&gt;</span> r<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                    <span class=\"kw1\">return</span> i<span class=\"sy0\">;</span><br/>                <span class=\"br0\">}</span><br/>            <span class=\"br0\">}</span><br/>\u00a0<br/>            <span class=\"kw1\">throw</span> Error<span class=\"br0\">(</span><span class=\"st0\">\"algorithmic failure choosing weighted random index\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">const</span> n <span class=\"sy0\">=</span> observations.<span class=\"me1\">length</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> distanceToCloseCentroid <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">;</span> <span class=\"co1\">// distance D(x) to closest centroid for each observation</span><br/>        <span class=\"kw1\">const</span> centroids <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">;</span>   <span class=\"co1\">// indices of observations that are chosen as centroids</span><br/>\u00a0<br/>        <span class=\"co1\">//</span><br/>        <span class=\"co1\">// keep list of all observations' indices so</span><br/>        <span class=\"co1\">// we can remove centroids as they are created</span><br/>        <span class=\"co1\">// so they can't be chosen twice</span><br/>        <span class=\"co1\">//</span><br/>        <span class=\"kw1\">const</span> index <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> n<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            index<span class=\"br0\">[</span>i<span class=\"br0\">]</span> <span class=\"sy0\">=</span> i<span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"co1\">//</span><br/>        <span class=\"co1\">//  1. Choose one center uniformly at random from among the data points.</span><br/>        <span class=\"co1\">//</span><br/>        let centroidIndex <span class=\"sy0\">=</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">floor</span><span class=\"br0\">(</span><span class=\"kw4\">Math</span>.<span class=\"me1\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">*</span> n<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        centroids.<span class=\"me1\">push</span><span class=\"br0\">(</span>centroidIndex<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let c <span class=\"sy0\">=</span> <span class=\"nu0\">1</span><span class=\"sy0\">;</span> c <span class=\"sy0\">&lt;</span> k<span class=\"sy0\">;</span> c <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span>        <br/>            index.<span class=\"me1\">slice</span><span class=\"br0\">(</span>centroids<span class=\"br0\">[</span>c <span class=\"sy0\">-</span> <span class=\"nu0\">1</span><span class=\"br0\">]</span><span class=\"sy0\">,</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">;</span>    <span class=\"co1\">// remove previous centroid from further consideration</span><br/>            distanceToCloseCentroid<span class=\"br0\">[</span>centroids<span class=\"br0\">[</span>c <span class=\"sy0\">-</span> <span class=\"nu0\">1</span><span class=\"br0\">]</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span>  <span class=\"co1\">// this effectively removes it from the probability distribution</span><br/>\u00a0<br/>            <span class=\"co1\">//</span><br/>            <span class=\"co1\">// 2. For each data point x, compute D(x), the distance between x and </span><br/>            <span class=\"co1\">//    the nearest center that has already been chosen.  </span><br/>            <span class=\"co1\">//</span><br/>            <span class=\"co1\">// NOTE: we used the distance squared (L2 norm)</span><br/>            <span class=\"co1\">//</span><br/>            let totalWeight <span class=\"sy0\">=</span> <span class=\"nu0\">0.0</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> index.<span class=\"me1\">length</span><span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                <span class=\"co1\">//</span><br/>                <span class=\"co1\">// if this is the first time through, the distance is undefined, so just set it.</span><br/>                <span class=\"co1\">// Otherwise, choose the minimum of the prior closest and this new centroid</span><br/>                <span class=\"co1\">//</span><br/>                <span class=\"kw1\">const</span> distanceToCentroid <span class=\"sy0\">=</span> kmeans.<span class=\"me1\">distanceSquared</span><span class=\"br0\">(</span>observations<span class=\"br0\">[</span>index<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"br0\">]</span><span class=\"sy0\">,</span> observations<span class=\"br0\">[</span>centroids<span class=\"br0\">[</span>c <span class=\"sy0\">-</span> <span class=\"nu0\">1</span><span class=\"br0\">]</span><span class=\"br0\">]</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>                distanceToCloseCentroid<span class=\"br0\">[</span>index<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <br/>                    <span class=\"br0\">(</span><span class=\"kw1\">typeof</span> distanceToCloseCentroid<span class=\"br0\">[</span>index<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"br0\">]</span> <span class=\"sy0\">===</span> <span class=\"st0\">'number'</span><span class=\"br0\">)</span> <br/>                    <span class=\"sy0\">?</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">min</span><span class=\"br0\">(</span>distanceToCloseCentroid<span class=\"br0\">[</span>index<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"br0\">]</span><span class=\"sy0\">,</span> distanceToCentroid<span class=\"br0\">)</span><br/>                    <span class=\"sy0\">:</span> distanceToCentroid<span class=\"sy0\">;</span><br/>                totalWeight <span class=\"sy0\">+=</span> distanceToCloseCentroid<span class=\"br0\">[</span>index<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span>  <br/>\u00a0<br/>            <span class=\"co1\">//</span><br/>            <span class=\"co1\">//  3. Choose one new data point at random as a new center, </span><br/>            <span class=\"co1\">//     using a weighted probability distribution where a point x is chosen with probability proportional to D(x)^2.</span><br/>            <span class=\"co1\">//</span><br/>            centroidIndex <span class=\"sy0\">=</span> index<span class=\"br0\">[</span>weightedRandomIndex<span class=\"br0\">(</span>distanceToCloseCentroid<span class=\"sy0\">,</span> totalWeight<span class=\"br0\">)</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>            centroids.<span class=\"me1\">push</span><span class=\"br0\">(</span>centroidIndex<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>            <span class=\"co1\">//  4. Repeat Steps 2 and 3 until k centers have been chosen.</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"co1\">//</span><br/>        <span class=\"co1\">//  5. Now that the initial centers have been chosen, proceed using</span><br/>        <span class=\"co1\">//     standard k-means clustering. Return the model so that</span><br/>        <span class=\"co1\">//     kmeans can continue.</span><br/>        <span class=\"co1\">//</span><br/>        <span class=\"kw1\">return</span> <span class=\"br0\">{</span><br/>            <span class=\"st0\">'observations'</span><span class=\"sy0\">:</span> observations<span class=\"sy0\">,</span><br/>            <span class=\"st0\">'centroids'</span><span class=\"sy0\">:</span> centroids.<span class=\"me1\">map</span><span class=\"br0\">(</span>x <span class=\"sy0\">=&gt;</span> observations<span class=\"br0\">[</span>x<span class=\"br0\">]</span><span class=\"br0\">)</span><span class=\"sy0\">,</span> <span class=\"co1\">// map centroid index to centroid value</span><br/>            <span class=\"st0\">'assignments'</span><span class=\"sy0\">:</span> observations.<span class=\"me1\">map</span><span class=\"br0\">(</span><span class=\"br0\">(</span>x<span class=\"sy0\">,</span> i<span class=\"br0\">)</span> <span class=\"sy0\">=&gt;</span> i <span class=\"sy0\">%</span> centroids.<span class=\"me1\">length</span><span class=\"br0\">)</span> <span class=\"co1\">// distribute among centroids</span><br/>        <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"br0\">}</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"coMULTI\">/**<br/> * Extra Credit #1<br/> * module for creating random models for kmeans clustering<br/> */</span><br/>define<span class=\"br0\">(</span><span class=\"kw1\">function</span> <span class=\"br0\">(</span>require<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <span class=\"st0\">\"use strict\"</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"kw1\">const</span> kmeans <span class=\"sy0\">=</span> require<span class=\"br0\">(</span><span class=\"st0\">\"./kmeans\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * @return a random, normally distributed number<br/>     */</span><br/>    <span class=\"kw1\">function</span> randomNormal<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"co1\">// n = 6 gives a good enough approximation</span><br/>        <span class=\"kw1\">return</span> <span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"kw4\">Math</span>.<span class=\"me1\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">+</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">+</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">+</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">+</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">+</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"sy0\">-</span> <span class=\"nu0\">3</span><span class=\"br0\">)</span> <span class=\"sy0\">/</span> <span class=\"nu0\">3</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * Generate a uniform random unit vector<br/>     * <br/>     * @param {Integer} d dimension of data<br/>     * @return n random datapoints of dimension d with length == 1<br/>     */</span><br/>    <span class=\"kw1\">function</span> randomUnitVector<span class=\"br0\">(</span>d<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">const</span> range <span class=\"sy0\">=</span> max <span class=\"sy0\">-</span> min<span class=\"sy0\">;</span><br/>        let magnitude <span class=\"sy0\">=</span> <span class=\"nu0\">0.0</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> observation <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"co1\">// uniform random for each dimension</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let j <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> j <span class=\"sy0\">&lt;</span> d<span class=\"sy0\">;</span> j <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">const</span> x <span class=\"sy0\">=</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            observation<span class=\"br0\">[</span>j<span class=\"br0\">]</span> <span class=\"sy0\">=</span> x<span class=\"sy0\">;</span><br/>            magnitude <span class=\"sy0\">=</span> x <span class=\"sy0\">*</span> x<span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"co1\">// normalize</span><br/>        <span class=\"kw1\">const</span> magnitude <span class=\"sy0\">=</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">sqrt</span><span class=\"br0\">(</span>magnitude<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let j <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> j <span class=\"sy0\">&lt;</span> d<span class=\"sy0\">;</span> j <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            observation<span class=\"br0\">[</span>j<span class=\"br0\">]</span> <span class=\"sy0\">/=</span> magnitude<span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">return</span> observation<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * Generate a uniform random unit vectors for clustering<br/>     * <br/>     * @param {Integer} n number of data points<br/>     * @param {Integer} d dimension of data<br/>     * @return n random datapoints of dimension d with length == 1<br/>     */</span><br/>    <span class=\"kw1\">function</span> randomUnitVectors<span class=\"br0\">(</span>n<span class=\"sy0\">,</span> d<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>\u00a0<br/>        <span class=\"co1\">// create n random observations, each of dimension d</span><br/>        <span class=\"kw1\">const</span> observations <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> n<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"co1\">// create random observation of dimension d</span><br/>            <span class=\"kw1\">const</span> observation <span class=\"sy0\">=</span> randomUnitVector<span class=\"br0\">(</span>d<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            observations.<span class=\"me1\">push</span><span class=\"br0\">(</span>observation<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">return</span> observations<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>\u00a0<br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * Generate a spherical random vector<br/>     * <br/>     * @param {Integer} n number of data points<br/>     * @param {Integer} d dimension of data<br/>     * @param {Number} r radium from center for data point<br/>     * @return n random datapoints of dimension d<br/>     */</span><br/>    <span class=\"kw1\">function</span> randomSphericalVector<span class=\"br0\">(</span>d<span class=\"sy0\">,</span> r<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">const</span> observation <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        let magnitude <span class=\"sy0\">=</span> <span class=\"nu0\">0.0</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let j <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> j <span class=\"sy0\">&lt;</span> d<span class=\"sy0\">;</span> j <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span><br/>        <span class=\"br0\">{</span><br/>            <span class=\"kw1\">const</span> x <span class=\"sy0\">=</span> randomNormal<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            observation<span class=\"br0\">[</span>j<span class=\"br0\">]</span> <span class=\"sy0\">=</span> x<span class=\"sy0\">;</span><br/>            magnitude <span class=\"sy0\">+=</span> x <span class=\"sy0\">*</span> x<span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"co1\">// normalize</span><br/>        magnitude <span class=\"sy0\">=</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">sqrt</span><span class=\"br0\">(</span>magnitude<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let j <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> j <span class=\"sy0\">&lt;</span> d<span class=\"sy0\">;</span> j <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            observation<span class=\"br0\">[</span>j<span class=\"br0\">]</span> <span class=\"sy0\">=</span> observation<span class=\"br0\">[</span>j<span class=\"br0\">]</span> <span class=\"sy0\">*</span> r <span class=\"sy0\">/</span> magnitude<span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">return</span> observation<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>\u00a0<br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * Generate a spherical random vectors<br/>     * <br/>     * @param {Integer} n number of data points<br/>     * @param {Integer} d dimension of data<br/>     * @param {Number} max radius from center for data points<br/>     * @return n random datapoints of dimension d<br/>     */</span><br/>    <span class=\"kw1\">function</span> randomSphericalVectors<span class=\"br0\">(</span>n<span class=\"sy0\">,</span> d<span class=\"sy0\">,</span> r<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>\u00a0<br/>        <span class=\"co1\">// create n random observations, each of dimension d</span><br/>        <span class=\"kw1\">const</span> observations <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> n<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"co1\">// create random observation of dimension d with random radius</span><br/>            <span class=\"kw1\">const</span> observation <span class=\"sy0\">=</span> randomSphericalVector<span class=\"br0\">(</span>d<span class=\"sy0\">,</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">*</span> r<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            observations.<span class=\"me1\">push</span><span class=\"br0\">(</span>observation<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">return</span> observations<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * Generate a uniform random model for clustering<br/>     * <br/>     * @param {Integer} n number of data points<br/>     * @param {Integer} d dimension of data<br/>     * @param {Number} radius of sphere<br/>     * @return n random datapoints of dimension d<br/>     */</span><br/>    <span class=\"kw1\">function</span> randomVectors<span class=\"br0\">(</span>n<span class=\"sy0\">,</span> d<span class=\"sy0\">,</span> min<span class=\"sy0\">,</span> max<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>\u00a0<br/>        <span class=\"kw1\">const</span> range <span class=\"sy0\">=</span> max <span class=\"sy0\">-</span> min<span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"co1\">// create n random observations, each of dimension d</span><br/>        <span class=\"kw1\">const</span> observations <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> n<span class=\"sy0\">;</span> i <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"co1\">// create random observation of dimension d</span><br/>            <span class=\"kw1\">const</span> observation <span class=\"sy0\">=</span> randomVector<span class=\"br0\">(</span>d<span class=\"sy0\">,</span> min<span class=\"sy0\">,</span> max<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            observations.<span class=\"me1\">push</span><span class=\"br0\">(</span>observation<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">return</span> observations<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * Generate a uniform random model for clustering<br/>     * <br/>     * @param {Integer} d dimension of data<br/>     * @param {Number} radius of sphere<br/>     * @return n random datapoints of dimension d<br/>     */</span><br/>    <span class=\"kw1\">function</span> randomVector<span class=\"br0\">(</span>d<span class=\"sy0\">,</span> min<span class=\"sy0\">,</span> max<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>\u00a0<br/>        <span class=\"co1\">// create random observation of dimension d</span><br/>        <span class=\"kw1\">const</span> range <span class=\"sy0\">=</span> max <span class=\"sy0\">-</span> min<span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> observation <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span><span class=\"br0\">(</span>let j <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> j <span class=\"sy0\">&lt;</span> d<span class=\"sy0\">;</span> j <span class=\"sy0\">+=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            observation.<span class=\"me1\">push</span><span class=\"br0\">(</span>min <span class=\"sy0\">+</span> <span class=\"kw4\">Math</span>.<span class=\"me1\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">*</span> range<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">return</span> observation<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"kw1\">return</span> <span class=\"br0\">{</span><br/>        <span class=\"st0\">'randomVector'</span><span class=\"sy0\">:</span> randomVector<span class=\"sy0\">,</span><br/>        <span class=\"st0\">'randomUnitVector'</span><span class=\"sy0\">:</span> randomUnitVector<span class=\"sy0\">,</span><br/>        <span class=\"st0\">'randomSphericalVector'</span><span class=\"sy0\">:</span> randomSphericalVector<span class=\"sy0\">,</span><br/>        <span class=\"st0\">'randomVectors'</span><span class=\"sy0\">:</span> randomVectors<span class=\"sy0\">,</span><br/>        <span class=\"st0\">'randomUnitVectors'</span><span class=\"sy0\">:</span> randomUnitVectors<span class=\"sy0\">,</span><br/>        <span class=\"st0\">'randomSphericalVectors'</span><span class=\"sy0\">:</span> randomSphericalVectors<br/>    <span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"br0\">}</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"coMULTI\">/**<br/> * Extra Credit #4<br/> * Application to cluster random data using kmeans++<br/> * <br/> * cluster(k, n, d) - cluster n data points of dimension d into k clusters<br/> * plot(canvas, result) - plot the results of cluster() to the given html5 canvas using clusterjs<br/> */</span><br/>define<span class=\"br0\">(</span><span class=\"kw1\">function</span> <span class=\"br0\">(</span>require<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <span class=\"st0\">\"use strict\"</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">const</span> kmeans <span class=\"sy0\">=</span> require<span class=\"br0\">(</span><span class=\"st0\">\"./kmeans/kmeans\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">const</span> kmeanspp <span class=\"sy0\">=</span> require<span class=\"br0\">(</span><span class=\"st0\">\"./kmeans/kmeanspp\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">const</span> randomCentroidInitializer <span class=\"sy0\">=</span> require<span class=\"br0\">(</span><span class=\"st0\">\"./kmeans/randomCentroidInitializer\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">const</span> kmeansRandomModel <span class=\"sy0\">=</span> require<span class=\"br0\">(</span><span class=\"st0\">\"./kmeans/kmeansRandomModel\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * @public<br/>     * Load iris dataset and run kmeans on it given the number of clusters<br/>     * <br/>     * @param {integer} k number of clusters to create<br/>     */</span><br/>    <span class=\"kw1\">function</span> cluster<span class=\"br0\">(</span>k<span class=\"sy0\">,</span> n<span class=\"sy0\">,</span> d<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>\u00a0<br/>        <span class=\"co1\">//</span><br/>        <span class=\"co1\">// map iris data rows from dictionary to vector (array), leaving out the label</span><br/>        <span class=\"co1\">//</span><br/>        <span class=\"kw1\">const</span> observations <span class=\"sy0\">=</span> kmeansRandomModel.<span class=\"me1\">randomSphericalVectors</span><span class=\"br0\">(</span>n<span class=\"sy0\">,</span> d<span class=\"sy0\">,</span> <span class=\"nu0\">10.0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"co1\">//</span><br/>        <span class=\"co1\">// create the intial model and run it</span><br/>        <span class=\"co1\">//</span><br/>        <span class=\"co1\">// const initialModel = randomCentroidInitializer(observations, k);</span><br/>        <span class=\"kw1\">const</span> initialModel <span class=\"sy0\">=</span> kmeanspp<span class=\"br0\">(</span>observations<span class=\"sy0\">,</span> k<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"co1\">//</span><br/>        <span class=\"co1\">// cluster into given number of clusters</span><br/>        <span class=\"co1\">//</span><br/>        <span class=\"kw1\">const</span> results <span class=\"sy0\">=</span> kmeans.<span class=\"me1\">cluster</span><span class=\"br0\">(</span>initialModel<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"co1\">//</span><br/>        <span class=\"co1\">// do this for the convenience of the plotting functions</span><br/>        <span class=\"co1\">//</span><br/>        results.<span class=\"me1\">clusters</span> <span class=\"sy0\">=</span> kmeans.<span class=\"me1\">assignmentsToClusters</span><span class=\"br0\">(</span>results.<span class=\"me1\">model</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"kw1\">return</span> results<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"kw1\">const</span> clusterColor <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"st0\">'red'</span><span class=\"sy0\">,</span> <span class=\"st0\">'green'</span><span class=\"sy0\">,</span> <span class=\"st0\">'blue'</span><span class=\"sy0\">,</span> <span class=\"st0\">'yellow'</span><span class=\"sy0\">,</span> <span class=\"st0\">'purple'</span><span class=\"sy0\">,</span> <span class=\"st0\">'cyan'</span><span class=\"sy0\">,</span> <span class=\"st0\">'magenta'</span><span class=\"sy0\">,</span> <span class=\"st0\">'pink'</span><span class=\"sy0\">,</span> <span class=\"st0\">'brown'</span><span class=\"sy0\">,</span> <span class=\"st0\">'black'</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>    let chart <span class=\"sy0\">=</span> <span class=\"kw2\">undefined</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/**<br/>     * plot the clustred iris data model.<br/>     * <br/>     * @param {object} results of cluster(), with model, clusters and clusterCompositions<br/>     * @param {boolean} showClusterColor true to show learned cluster points<br/>     * @param {boolean} showSpeciesColor true to show known dataset labelled points<br/>     */</span><br/>    <span class=\"kw1\">function</span> plot<span class=\"br0\">(</span>canvas<span class=\"sy0\">,</span> results<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>\u00a0<br/>        <span class=\"co1\">//</span><br/>        <span class=\"co1\">// map iris data rows from dictionary to vector (array), leaving out the label</span><br/>        <span class=\"co1\">//</span><br/>        <span class=\"kw1\">const</span> model <span class=\"sy0\">=</span> results.<span class=\"me1\">model</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> observations <span class=\"sy0\">=</span> model.<span class=\"me1\">observations</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> assignments <span class=\"sy0\">=</span> model.<span class=\"me1\">assignments</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> centroids <span class=\"sy0\">=</span> model.<span class=\"me1\">centroids</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> d <span class=\"sy0\">=</span> observations<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span>.<span class=\"me1\">length</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> n <span class=\"sy0\">=</span> observations.<span class=\"me1\">length</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> k <span class=\"sy0\">=</span> centroids.<span class=\"me1\">length</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"co1\">// </span><br/>        <span class=\"co1\">// put offset of each data points into clusters using the assignments</span><br/>        <span class=\"co1\">//</span><br/>        <span class=\"kw1\">const</span> clusters <span class=\"sy0\">=</span> results.<span class=\"me1\">clusters</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"co1\">//</span><br/>        <span class=\"co1\">// plot the clusters</span><br/>        <span class=\"co1\">//</span><br/>        <span class=\"kw1\">const</span> chartData <span class=\"sy0\">=</span> <span class=\"br0\">{</span><br/>            <span class=\"co1\">// for the purposes of plotting in 2 dimensions, we will use </span><br/>            <span class=\"co1\">// x = dimension 0 and y = dimension 1 </span><br/>            datasets<span class=\"sy0\">:</span> clusters.<span class=\"me1\">map</span><span class=\"br0\">(</span><span class=\"kw1\">function</span><span class=\"br0\">(</span>c<span class=\"sy0\">,</span> i<span class=\"br0\">)</span> <span class=\"br0\">{</span> <br/>                <span class=\"kw1\">return</span> <span class=\"br0\">{</span><br/>                    label<span class=\"sy0\">:</span> <span class=\"st0\">\"cluster\"</span> <span class=\"sy0\">+</span> i<span class=\"sy0\">,</span><br/>                    data<span class=\"sy0\">:</span> c.<span class=\"me1\">map</span><span class=\"br0\">(</span>d <span class=\"sy0\">=&gt;</span> <span class=\"br0\">(</span><span class=\"br0\">{</span><span class=\"st0\">'x'</span><span class=\"sy0\">:</span> observations<span class=\"br0\">[</span>d<span class=\"br0\">]</span><span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span><span class=\"sy0\">,</span> <span class=\"st0\">'y'</span><span class=\"sy0\">:</span> observations<span class=\"br0\">[</span>d<span class=\"br0\">]</span><span class=\"br0\">[</span><span class=\"nu0\">1</span><span class=\"br0\">]</span><span class=\"br0\">}</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">,</span><br/>                    backgroundColor<span class=\"sy0\">:</span> clusterColor<span class=\"br0\">[</span>i <span class=\"sy0\">%</span> clusterColor.<span class=\"me1\">length</span><span class=\"br0\">]</span><span class=\"sy0\">,</span><br/>                    pointBackgroundColor<span class=\"sy0\">:</span> clusterColor<span class=\"br0\">[</span>i <span class=\"sy0\">%</span> clusterColor.<span class=\"me1\">length</span><span class=\"br0\">]</span><span class=\"sy0\">,</span><br/>                    pointBorderColor<span class=\"sy0\">:</span>  clusterColor<span class=\"br0\">[</span>i <span class=\"sy0\">%</span> clusterColor.<span class=\"me1\">length</span><span class=\"br0\">]</span><br/>                <span class=\"br0\">}</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><span class=\"br0\">)</span><br/>        <span class=\"br0\">}</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> chartOptions <span class=\"sy0\">=</span> <span class=\"br0\">{</span><br/>            responsive<span class=\"sy0\">:</span> <span class=\"kw2\">true</span><span class=\"sy0\">,</span><br/>            maintainAspectRatio<span class=\"sy0\">:</span> <span class=\"kw2\">false</span><span class=\"sy0\">,</span><br/>            title<span class=\"sy0\">:</span> <span class=\"br0\">{</span><br/>                display<span class=\"sy0\">:</span> <span class=\"kw2\">true</span><span class=\"sy0\">,</span><br/>                text<span class=\"sy0\">:</span> <span class=\"st0\">'Random spherical data set (d=$d, n=$n) clustered using K-Means (k=$k)'</span><br/>                        .<span class=\"me1\">replace</span><span class=\"br0\">(</span><span class=\"st0\">\"$d\"</span><span class=\"sy0\">,</span> d<span class=\"br0\">)</span><br/>                        .<span class=\"me1\">replace</span><span class=\"br0\">(</span><span class=\"st0\">'$n'</span><span class=\"sy0\">,</span> n<span class=\"br0\">)</span><br/>                        .<span class=\"me1\">replace</span><span class=\"br0\">(</span><span class=\"st0\">'$k'</span><span class=\"sy0\">,</span> k<span class=\"br0\">)</span><br/>            <span class=\"br0\">}</span><span class=\"sy0\">,</span><br/>            legend<span class=\"sy0\">:</span> <span class=\"br0\">{</span><br/>                position<span class=\"sy0\">:</span> <span class=\"st0\">'bottom'</span><span class=\"sy0\">,</span><br/>                display<span class=\"sy0\">:</span> <span class=\"kw2\">true</span><br/>            <span class=\"br0\">}</span><span class=\"sy0\">,</span><br/>            scales<span class=\"sy0\">:</span> <span class=\"br0\">{</span><br/>                xAxes<span class=\"sy0\">:</span> <span class=\"br0\">[</span><span class=\"br0\">{</span><br/>                    type<span class=\"sy0\">:</span> <span class=\"st0\">'linear'</span><span class=\"sy0\">,</span><br/>                    position<span class=\"sy0\">:</span> <span class=\"st0\">'bottom'</span><span class=\"sy0\">,</span><br/>                    scaleLabel<span class=\"sy0\">:</span> <span class=\"br0\">{</span><br/>                        labelString<span class=\"sy0\">:</span> <span class=\"st0\">'x axis'</span><span class=\"sy0\">,</span><br/>                        display<span class=\"sy0\">:</span> <span class=\"kw2\">false</span><span class=\"sy0\">,</span><br/>                    <span class=\"br0\">}</span><br/>                <span class=\"br0\">}</span><span class=\"br0\">]</span><span class=\"sy0\">,</span><br/>                yAxes<span class=\"sy0\">:</span> <span class=\"br0\">[</span><span class=\"br0\">{</span><br/>                    type<span class=\"sy0\">:</span> <span class=\"st0\">'linear'</span><span class=\"sy0\">,</span><br/>                    position<span class=\"sy0\">:</span> <span class=\"st0\">'left'</span><span class=\"sy0\">,</span><br/>                    scaleLabel<span class=\"sy0\">:</span> <span class=\"br0\">{</span><br/>                        labelString<span class=\"sy0\">:</span> <span class=\"st0\">'y axis'</span><span class=\"sy0\">,</span><br/>                        display<span class=\"sy0\">:</span> <span class=\"kw2\">false</span><br/>                    <span class=\"br0\">}</span><br/>                <span class=\"br0\">}</span><span class=\"br0\">]</span><br/>            <span class=\"br0\">}</span><br/>        <span class=\"br0\">}</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"co1\">//</span><br/>        <span class=\"co1\">// we need to destroy the previous chart so it's interactivity </span><br/>        <span class=\"co1\">// does not continue to run</span><br/>        <span class=\"co1\">//</span><br/>        <span class=\"kw1\">if</span><span class=\"br0\">(</span><span class=\"kw2\">undefined</span> <span class=\"sy0\">!==</span> chart<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            chart.<span class=\"me1\">destroy</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>        <span class=\"br0\">}</span> <br/>        chart <span class=\"sy0\">=</span> <span class=\"kw1\">new</span> Chart<span class=\"br0\">(</span>canvas<span class=\"sy0\">,</span> <span class=\"br0\">{</span><br/>            type<span class=\"sy0\">:</span> <span class=\"st0\">'scatter'</span><span class=\"sy0\">,</span><br/>            data<span class=\"sy0\">:</span> chartData<span class=\"sy0\">,</span><br/>            options<span class=\"sy0\">:</span> chartOptions<span class=\"sy0\">,</span><br/>        <span class=\"br0\">}</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"kw1\">return</span> <span class=\"br0\">{</span><span class=\"st0\">'cluster'</span><span class=\"sy0\">:</span> cluster<span class=\"sy0\">,</span> <span class=\"st0\">'plot'</span><span class=\"sy0\">:</span> plot<span class=\"br0\">}</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\u00a0<br/>\u00a0</pre>"}, {"lang": "Kotlin", "loc": 162, "block": "<pre class=\"scala highlighted_source\"><span class=\"co1\">// version 1.2.21</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">import</span></a> java.<span class=\"me1\">util</span>.<span class=\"me1\">Random</span><br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">import</span></a> kotlin.<span class=\"me1\">math</span>.<span class=\"sy0\">*</span><br/>\u00a0<br/>data <a href=\"http://scala-lang.org\"><span class=\"kw1\">class</span></a> Point<span class=\"br0\">(</span><a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> x<span class=\"sy0\">:</span> Double, <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> y<span class=\"sy0\">:</span> Double, <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> group<span class=\"sy0\">:</span> Int<span class=\"br0\">)</span><br/>\u00a0<br/>typealias LPoint <span class=\"sy0\">=</span> List<span class=\"sy0\">&lt;</span>Point<span class=\"sy0\">&gt;</span><br/>typealias MLPoint <span class=\"sy0\">=</span> MutableList<span class=\"sy0\">&lt;</span>Point<span class=\"sy0\">&gt;</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> origin get<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> Point<span class=\"br0\">(</span><span class=\"nu0\">0.0</span>, <span class=\"nu0\">0.0</span>, <span class=\"nu0\">0</span><span class=\"br0\">)</span><br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> r <span class=\"sy0\">=</span> Random<span class=\"br0\">(</span><span class=\"br0\">)</span><br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> hugeVal <span class=\"sy0\">=</span> Double.<span class=\"me1\">POSITIVE_INFINITY</span><br/>\u00a0<br/>const <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> RAND<span class=\"sy0\">_</span>MAX <span class=\"sy0\">=</span> Int.<span class=\"me1\">MAX_VALUE</span><br/>const <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> PTS <span class=\"sy0\">=</span> <span class=\"nu0\">100</span><span class=\"sy0\">_</span>000<br/>const <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> K <span class=\"sy0\">=</span> <span class=\"nu0\">11</span><br/>const <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> W <span class=\"sy0\">=</span> <span class=\"nu0\">400</span><br/>const <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> H <span class=\"sy0\">=</span> <span class=\"nu0\">400</span><br/>\u00a0<br/>fun rand<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> r.<span class=\"me1\">nextInt</span><span class=\"br0\">(</span>RAND<span class=\"sy0\">_</span>MAX<span class=\"br0\">)</span><br/>\u00a0<br/>fun randf<span class=\"br0\">(</span>m<span class=\"sy0\">:</span> Double<span class=\"br0\">)</span> <span class=\"sy0\">=</span> m <span class=\"sy0\">*</span> rand<span class=\"br0\">(</span><span class=\"br0\">)</span> / <span class=\"br0\">(</span>RAND<span class=\"sy0\">_</span>MAX - <span class=\"nu0\">1</span><span class=\"br0\">)</span><br/>\u00a0<br/>fun genXY<span class=\"br0\">(</span>count<span class=\"sy0\">:</span> Int, radius<span class=\"sy0\">:</span> Double<span class=\"br0\">)</span><span class=\"sy0\">:</span> LPoint <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> pts <span class=\"sy0\">=</span> List<span class=\"br0\">(</span>count<span class=\"br0\">)</span> <span class=\"br0\">{</span> origin <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"coMULTI\">/* note: this is not a uniform 2-d distribution */</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>i in <span class=\"nu0\">0</span> until count<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> ang <span class=\"sy0\">=</span> randf<span class=\"br0\">(</span><span class=\"nu0\">2.0</span> <span class=\"sy0\">*</span> PI<span class=\"br0\">)</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> r <span class=\"sy0\">=</span> randf<span class=\"br0\">(</span>radius<span class=\"br0\">)</span><br/>        pts<span class=\"br0\">[</span>i<span class=\"br0\">]</span>.<span class=\"me1\">x</span> <span class=\"sy0\">=</span> r <span class=\"sy0\">*</span> cos<span class=\"br0\">(</span>ang<span class=\"br0\">)</span><br/>        pts<span class=\"br0\">[</span>i<span class=\"br0\">]</span>.<span class=\"me1\">y</span> <span class=\"sy0\">=</span> r <span class=\"sy0\">*</span> sin<span class=\"br0\">(</span>ang<span class=\"br0\">)</span><br/>    <span class=\"br0\">}</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">return</span></a> pts<br/><span class=\"br0\">}</span><br/>\u00a0<br/>fun dist2<span class=\"br0\">(</span>a<span class=\"sy0\">:</span> Point, b<span class=\"sy0\">:</span> Point<span class=\"br0\">)</span><span class=\"sy0\">:</span> Double <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> x <span class=\"sy0\">=</span> a.<span class=\"me1\">x</span> - b.<span class=\"me1\">x</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> y <span class=\"sy0\">=</span> a.<span class=\"me1\">y</span> - b.<span class=\"me1\">y</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">return</span></a> x <span class=\"sy0\">*</span> x + y <span class=\"sy0\">*</span> y<br/><span class=\"br0\">}</span><br/>\u00a0<br/>fun nearest<span class=\"br0\">(</span>pt<span class=\"sy0\">:</span> Point, cent<span class=\"sy0\">:</span> LPoint, nCluster<span class=\"sy0\">:</span> Int<span class=\"br0\">)</span><span class=\"sy0\">:</span> Pair<span class=\"sy0\">&lt;</span>Int, Double<span class=\"sy0\">&gt;</span> <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> minD <span class=\"sy0\">=</span> hugeVal<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> minI <span class=\"sy0\">=</span> pt.<span class=\"me1\">group</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>i in <span class=\"nu0\">0</span> until nCluster<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> d <span class=\"sy0\">=</span> dist2<span class=\"br0\">(</span>cent<span class=\"br0\">[</span>i<span class=\"br0\">]</span>, pt<span class=\"br0\">)</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>minD <span class=\"sy0\">&gt;</span> d<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            minD <span class=\"sy0\">=</span> d<br/>            minI <span class=\"sy0\">=</span> i<br/>        <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">return</span></a> minI to minD<br/><span class=\"br0\">}</span><br/>\u00a0<br/>fun kpp<span class=\"br0\">(</span>pts<span class=\"sy0\">:</span> LPoint, len<span class=\"sy0\">:</span> Int, cent<span class=\"sy0\">:</span> MLPoint<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> nCent <span class=\"sy0\">=</span> cent.<span class=\"me1\">size</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> d <span class=\"sy0\">=</span> DoubleArray<span class=\"br0\">(</span>len<span class=\"br0\">)</span><br/>    cent<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> pts<span class=\"br0\">[</span>rand<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">%</span> len<span class=\"br0\">]</span>.<span class=\"me1\">copy</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>nCluster in <span class=\"nu0\">1</span> until nCent<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> sum <span class=\"sy0\">=</span> <span class=\"nu0\">0.0</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>j in <span class=\"nu0\">0</span> until len<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            d<span class=\"br0\">[</span>j<span class=\"br0\">]</span> <span class=\"sy0\">=</span> nearest<span class=\"br0\">(</span>pts<span class=\"br0\">[</span>j<span class=\"br0\">]</span>, cent, nCluster<span class=\"br0\">)</span>.<span class=\"me1\">second</span><br/>            sum +<span class=\"sy0\">=</span> d<span class=\"br0\">[</span>j<span class=\"br0\">]</span><br/>        <span class=\"br0\">}</span><br/>        sum <span class=\"sy0\">=</span> randf<span class=\"br0\">(</span>sum<span class=\"br0\">)</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>j in <span class=\"nu0\">0</span> until len<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            sum -<span class=\"sy0\">=</span> d<span class=\"br0\">[</span>j<span class=\"br0\">]</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>sum <span class=\"sy0\">&gt;</span> <span class=\"nu0\">0.0</span><span class=\"br0\">)</span> continue<br/>            cent<span class=\"br0\">[</span>nCluster<span class=\"br0\">]</span> <span class=\"sy0\">=</span> pts<span class=\"br0\">[</span>j<span class=\"br0\">]</span>.<span class=\"me1\">copy</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>            break<br/>        <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>j in <span class=\"nu0\">0</span> until len<span class=\"br0\">)</span> pts<span class=\"br0\">[</span>j<span class=\"br0\">]</span>.<span class=\"me1\">group</span> <span class=\"sy0\">=</span> nearest<span class=\"br0\">(</span>pts<span class=\"br0\">[</span>j<span class=\"br0\">]</span>, cent, nCent<span class=\"br0\">)</span>.<span class=\"me1\">first</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/>fun lloyd<span class=\"br0\">(</span>pts<span class=\"sy0\">:</span> LPoint, len<span class=\"sy0\">:</span> Int, nCluster<span class=\"sy0\">:</span> Int<span class=\"br0\">)</span><span class=\"sy0\">:</span> LPoint <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> cent <span class=\"sy0\">=</span> MutableList<span class=\"br0\">(</span>nCluster<span class=\"br0\">)</span> <span class=\"br0\">{</span> origin <span class=\"br0\">}</span><br/>    kpp<span class=\"br0\">(</span>pts, len, cent<span class=\"br0\">)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">do</span></a> <span class=\"br0\">{</span><br/>        <span class=\"coMULTI\">/* group element for centroids are used as counters */</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>i in <span class=\"nu0\">0</span> until nCluster<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">with</span></a> <span class=\"br0\">(</span>cent<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"br0\">)</span> <span class=\"br0\">{</span> x <span class=\"sy0\">=</span> <span class=\"nu0\">0.0</span><span class=\"sy0\">;</span> y <span class=\"sy0\">=</span> <span class=\"nu0\">0.0</span><span class=\"sy0\">;</span> group <span class=\"sy0\">=</span> <span class=\"nu0\">0</span> <span class=\"br0\">}</span><br/>        <span class=\"br0\">}</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>j in <span class=\"nu0\">0</span> until len<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> p <span class=\"sy0\">=</span> pts<span class=\"br0\">[</span>j<span class=\"br0\">]</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> c <span class=\"sy0\">=</span> cent<span class=\"br0\">[</span>p.<span class=\"me1\">group</span><span class=\"br0\">]</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">with</span></a> <span class=\"br0\">(</span>c<span class=\"br0\">)</span> <span class=\"br0\">{</span> group++<span class=\"sy0\">;</span> x +<span class=\"sy0\">=</span> p.<span class=\"me1\">x</span><span class=\"sy0\">;</span> y +<span class=\"sy0\">=</span> p.<span class=\"me1\">y</span> <span class=\"br0\">}</span><br/>        <span class=\"br0\">}</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>i in <span class=\"nu0\">0</span> until nCluster<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> c <span class=\"sy0\">=</span> cent<span class=\"br0\">[</span>i<span class=\"br0\">]</span><br/>            c.<span class=\"me1\">x</span> /<span class=\"sy0\">=</span> c.<span class=\"me1\">group</span><br/>            c.<span class=\"me1\">y</span> /<span class=\"sy0\">=</span> c.<span class=\"me1\">group</span><br/>        <span class=\"br0\">}</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> changed <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><br/>\u00a0<br/>        <span class=\"coMULTI\">/* find closest centroid of each point */</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>j in <span class=\"nu0\">0</span> until len<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> p <span class=\"sy0\">=</span> pts<span class=\"br0\">[</span>j<span class=\"br0\">]</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> minI <span class=\"sy0\">=</span> nearest<span class=\"br0\">(</span>p, cent, nCluster<span class=\"br0\">)</span>.<span class=\"me1\">first</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>minI <span class=\"sy0\">!=</span> p.<span class=\"me1\">group</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                changed++<br/>                p.<span class=\"me1\">group</span> <span class=\"sy0\">=</span> minI<br/>            <span class=\"br0\">}</span><br/>        <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">while</span></a> <span class=\"br0\">(</span>changed <span class=\"sy0\">&gt;</span> <span class=\"br0\">(</span>len shr <span class=\"nu0\">10</span><span class=\"br0\">)</span><span class=\"br0\">)</span>  <span class=\"coMULTI\">/* stop when 99.9% of points are good */</span><br/>\u00a0<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>i in <span class=\"nu0\">0</span> until nCluster<span class=\"br0\">)</span> cent<span class=\"br0\">[</span>i<span class=\"br0\">]</span>.<span class=\"me1\">group</span> <span class=\"sy0\">=</span> i<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">return</span></a> cent<br/><span class=\"br0\">}</span><br/>\u00a0<br/>fun printEps<span class=\"br0\">(</span>pts<span class=\"sy0\">:</span> LPoint, len<span class=\"sy0\">:</span> Int, cent<span class=\"sy0\">:</span> LPoint, nCluster<span class=\"sy0\">:</span> Int<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> colors <span class=\"sy0\">=</span> DoubleArray<span class=\"br0\">(</span>nCluster <span class=\"sy0\">*</span> <span class=\"nu0\">3</span><span class=\"br0\">)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>i in <span class=\"nu0\">0</span> until nCluster<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        colors<span class=\"br0\">[</span><span class=\"nu0\">3</span> <span class=\"sy0\">*</span> i + <span class=\"nu0\">0</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"br0\">(</span><span class=\"nu0\">3</span> <span class=\"sy0\">*</span> <span class=\"br0\">(</span>i + <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"sy0\">%</span> <span class=\"nu0\">11</span><span class=\"br0\">)</span> / <span class=\"nu0\">11.0</span><br/>        colors<span class=\"br0\">[</span><span class=\"nu0\">3</span> <span class=\"sy0\">*</span> i + <span class=\"nu0\">1</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"br0\">(</span><span class=\"nu0\">7</span> <span class=\"sy0\">*</span> i <span class=\"sy0\">%</span> <span class=\"nu0\">11</span><span class=\"br0\">)</span> / <span class=\"nu0\">11.0</span><br/>        colors<span class=\"br0\">[</span><span class=\"nu0\">3</span> <span class=\"sy0\">*</span> i + <span class=\"nu0\">2</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"br0\">(</span><span class=\"nu0\">9</span> <span class=\"sy0\">*</span> i <span class=\"sy0\">%</span> <span class=\"nu0\">11</span><span class=\"br0\">)</span> / <span class=\"nu0\">11.0</span><br/>    <span class=\"br0\">}</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> minX <span class=\"sy0\">=</span> hugeVal<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> minY <span class=\"sy0\">=</span> hugeVal<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> maxX <span class=\"sy0\">=</span> -hugeVal<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> maxY <span class=\"sy0\">=</span> -hugeVal<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>j in <span class=\"nu0\">0</span> until len<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> p <span class=\"sy0\">=</span> pts<span class=\"br0\">[</span>j<span class=\"br0\">]</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>maxX <span class=\"sy0\">&lt;</span> p.<span class=\"me1\">x</span><span class=\"br0\">)</span> maxX <span class=\"sy0\">=</span> p.<span class=\"me1\">x</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>minX <span class=\"sy0\">&gt;</span> p.<span class=\"me1\">x</span><span class=\"br0\">)</span> minX <span class=\"sy0\">=</span> p.<span class=\"me1\">x</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>maxY <span class=\"sy0\">&lt;</span> p.<span class=\"me1\">y</span><span class=\"br0\">)</span> maxY <span class=\"sy0\">=</span> p.<span class=\"me1\">y</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>minY <span class=\"sy0\">&gt;</span> p.<span class=\"me1\">y</span><span class=\"br0\">)</span> minY <span class=\"sy0\">=</span> p.<span class=\"me1\">y</span><br/>    <span class=\"br0\">}</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> scale <span class=\"sy0\">=</span> minOf<span class=\"br0\">(</span>W / <span class=\"br0\">(</span>maxX - minX<span class=\"br0\">)</span>, H / <span class=\"br0\">(</span>maxY - minY<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> cx <span class=\"sy0\">=</span> <span class=\"br0\">(</span>maxX + minX<span class=\"br0\">)</span> / <span class=\"nu0\">2.0</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> cy <span class=\"sy0\">=</span> <span class=\"br0\">(</span>maxY + minY<span class=\"br0\">)</span> / <span class=\"nu0\">2.0</span><br/>\u00a0<br/>    print<span class=\"br0\">(</span><span class=\"st0\">\"%%!PS-Adobe-3.0<span class=\"es1\">\\n</span>%%%%BoundingBox: -5 -5\u00a0%${W + 10} ${H + 10}<span class=\"es1\">\\n</span>\"</span><span class=\"br0\">)</span><br/>    print<span class=\"br0\">(</span><span class=\"st0\">\"/l {rlineto} def /m {rmoveto} def<span class=\"es1\">\\n</span>\"</span><span class=\"br0\">)</span><br/>    print<span class=\"br0\">(</span><span class=\"st0\">\"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def<span class=\"es1\">\\n</span>\"</span><span class=\"br0\">)</span><br/>    print<span class=\"br0\">(</span><span class=\"st0\">\"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \"</span><span class=\"br0\">)</span><br/>    print<span class=\"br0\">(</span><span class=\"st0\">\"\tgsave 1 setgray fill grestore gsave 3 setlinewidth\"</span><span class=\"br0\">)</span><br/>    print<span class=\"br0\">(</span><span class=\"st0\">\" 1 setgray stroke grestore 0 setgray stroke }def<span class=\"es1\">\\n</span>\"</span><span class=\"br0\">)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> f1 <span class=\"sy0\">=</span> <span class=\"st0\">\"%g\u00a0%g\u00a0%g setrgbcolor\"</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> f2 <span class=\"sy0\">=</span> <span class=\"st0\">\"%.3f\u00a0%.3f c\"</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> f3 <span class=\"sy0\">=</span> <span class=\"st0\">\"<span class=\"es1\">\\n</span>0 setgray\u00a0%g\u00a0%g s\"</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>i in <span class=\"nu0\">0</span> until nCluster<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> c <span class=\"sy0\">=</span> cent<span class=\"br0\">[</span>i<span class=\"br0\">]</span><br/>        println<span class=\"br0\">(</span>f1.<span class=\"me1\">format</span><span class=\"br0\">(</span>colors<span class=\"br0\">[</span><span class=\"nu0\">3</span> <span class=\"sy0\">*</span> i<span class=\"br0\">]</span>, colors<span class=\"br0\">[</span><span class=\"nu0\">3</span> <span class=\"sy0\">*</span> i + <span class=\"nu0\">1</span><span class=\"br0\">]</span>, colors<span class=\"br0\">[</span><span class=\"nu0\">3</span> <span class=\"sy0\">*</span> i + <span class=\"nu0\">2</span><span class=\"br0\">]</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>j in <span class=\"nu0\">0</span> until len<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> p <span class=\"sy0\">=</span> pts<span class=\"br0\">[</span>j<span class=\"br0\">]</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>p.<span class=\"me1\">group</span> <span class=\"sy0\">!=</span> i<span class=\"br0\">)</span> continue<br/>            println<span class=\"br0\">(</span>f2.<span class=\"me1\">format</span><span class=\"br0\">(</span><span class=\"br0\">(</span>p.<span class=\"me1\">x</span> - cx<span class=\"br0\">)</span> <span class=\"sy0\">*</span> scale + W / <span class=\"nu0\">2</span>, <span class=\"br0\">(</span>p.<span class=\"me1\">y</span> - cy<span class=\"br0\">)</span> <span class=\"sy0\">*</span> scale + H / <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>        <span class=\"br0\">}</span><br/>        println<span class=\"br0\">(</span>f3.<span class=\"me1\">format</span><span class=\"br0\">(</span><span class=\"br0\">(</span>c.<span class=\"me1\">x</span> - cx<span class=\"br0\">)</span> <span class=\"sy0\">*</span> scale + W / <span class=\"nu0\">2</span>, <span class=\"br0\">(</span>c.<span class=\"me1\">y</span> - cy<span class=\"br0\">)</span> <span class=\"sy0\">*</span> scale + H / <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>    <span class=\"br0\">}</span><br/>    print<span class=\"br0\">(</span><span class=\"st0\">\"<span class=\"es1\">\\n</span>%%%%EOF\"</span><span class=\"br0\">)</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/>fun main<span class=\"br0\">(</span>args<span class=\"sy0\">:</span> Array<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> v <span class=\"sy0\">=</span> genXY<span class=\"br0\">(</span>PTS, <span class=\"nu0\">10.0</span><span class=\"br0\">)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> c <span class=\"sy0\">=</span> lloyd<span class=\"br0\">(</span>v, PTS, K<span class=\"br0\">)</span><br/>    printEps<span class=\"br0\">(</span>v, PTS, c, K<span class=\"br0\">)</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Mathematica", "loc": 24, "block": "<pre class=\"text highlighted_source\">initM[list_List, k_Integer, distFunc_Symbol]\u00a0:= <br/>  Module[{m = {RandomChoice[list]}, n, d},<br/>   While[Length[m] &lt; k,<br/>    n = <a class=\"__cf_email__\" data-cfemail=\"6735060903080a240f080e04022729020615021413\" href=\"/cdn-cgi/l/email-protection\">[email\u00a0protected]</a>[m, #] &amp; /@ list;<br/>    d = Apply[distFunc, Transpose[{n, list}], {1}];<br/>    m = Append[m, RandomChoice[d -&gt; list]] <br/>    ];<br/>   m<br/>   ];<br/>kmeanspp[list_, k_, <br/>   opts\u00a0: OptionsPattern[{DistanceFunction -&gt; <br/>       SquaredEuclideanDistance, \"RandomSeed\" -&gt; {}}]]\u00a0:= <br/>  BlockRandom[SeedRandom[OptionValue[\"RandomSeed\"]];<br/>   Module[{m = initM[list, k, OptionValue[DistanceFunction]], update, <br/>     partition, clusters}, update[]\u00a0:= m = Mean /@ clusters;<br/>    partition[_]\u00a0:= (clusters = <br/>       GatherBy[list, <br/>        <a class=\"__cf_email__\" data-cfemail=\"580a39363c37351b3037313b3d18\" href=\"/cdn-cgi/l/email-protection\">[email\u00a0protected]</a><br/>          Nearest[m, #, (# -&gt; OptionValue[#] &amp;@DistanceFunction)] &amp;]; <br/>      update[]);<br/>    FixedPoint[partition, list];<br/>    {clusters, m}<br/>    ]<br/>   ];</pre>"}, {"lang": "Perl 6", "loc": 26, "block": "<pre class=\"perl6 highlighted_source\"><span class=\"kw2\">sub</span> postfix<span class=\"sy0\">:</span>\u00ab<span class=\"sy0\">-</span>means<span class=\"sy0\">++</span>\u00bb<span class=\"br0\">(</span>Int <span class=\"re0\">$K</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <span class=\"kw1\">return</span> <span class=\"kw2\">sub</span> <span class=\"br0\">(</span><span class=\"re0\">@data</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">my</span> <span class=\"re0\">@means</span> <span class=\"sy0\">=</span> <span class=\"re0\">@data</span><span class=\"sy0\">.</span><span class=\"kw3\">pick</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">until</span> <span class=\"re0\">@means</span> <span class=\"sy0\">==</span> <span class=\"re0\">$K</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">my</span> <span class=\"re0\">@cumulD2</span> <span class=\"sy0\">=</span> <span class=\"br0\">[</span>\\<span class=\"sy0\">+</span><span class=\"br0\">]</span> <span class=\"re0\">@data</span><span class=\"sy0\">.</span><span class=\"kw3\">map</span><span class=\"sy0\">:</span> <span class=\"sy0\">-&gt;</span> <span class=\"re0\">$x</span> <span class=\"br0\">{</span><br/>                <span class=\"kw3\">min</span> <span class=\"re0\">@means</span><span class=\"sy0\">.</span><span class=\"kw3\">map</span><span class=\"sy0\">:</span> <span class=\"br0\">{</span> <span class=\"kw3\">abs</span><span class=\"br0\">(</span><span class=\"re0\">$x</span> <span class=\"sy0\">-</span> <span class=\"re0\">$_</span><span class=\"br0\">)</span><span class=\"sy0\">**</span><span class=\"nu0\">2</span> <span class=\"br0\">}</span><br/>            <span class=\"br0\">}</span><br/>            <span class=\"kw1\">my</span> <span class=\"re0\">$rand</span> <span class=\"sy0\">=</span> <span class=\"kw3\">rand</span> <span class=\"sy0\">*</span> <span class=\"re0\">@cumulD2</span><span class=\"br0\">[</span><span class=\"sy0\">*-</span><span class=\"nu0\">1</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>            <span class=\"re0\">@means</span><span class=\"sy0\">.</span><span class=\"kw3\">push</span><span class=\"sy0\">:</span> <span class=\"re0\">@data</span><span class=\"br0\">[</span><br/>                <span class=\"br0\">(</span><span class=\"sy0\">^</span><span class=\"re0\">@data</span><span class=\"br0\">)</span><span class=\"sy0\">.</span><span class=\"kw3\">first</span><span class=\"sy0\">:</span> <span class=\"br0\">{</span> <span class=\"re0\">@cumulD2</span><span class=\"br0\">[</span><span class=\"re0\">$_</span><span class=\"br0\">]</span> <span class=\"sy0\">&gt;</span> <span class=\"re0\">$rand</span> <span class=\"br0\">}</span><br/>            <span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>        <span class=\"kw2\">sub</span> cluster <span class=\"br0\">{</span> <span class=\"re0\">@data</span><span class=\"sy0\">.</span><span class=\"kw3\">classify</span><span class=\"sy0\">:</span> <span class=\"sy0\">-&gt;</span> <span class=\"re0\">$x</span> <span class=\"br0\">{</span> <span class=\"re0\">@means</span><span class=\"sy0\">.</span><span class=\"kw3\">min</span><span class=\"sy0\">:</span> <span class=\"br0\">{</span> <span class=\"kw3\">abs</span><span class=\"br0\">(</span><span class=\"re0\">$_</span> <span class=\"sy0\">-</span> <span class=\"re0\">$x</span><span class=\"br0\">)</span> <span class=\"br0\">}</span> <span class=\"br0\">}</span> <span class=\"br0\">}</span><br/>        <span class=\"kw1\">loop</span> <span class=\"br0\">(</span><br/>            <span class=\"kw1\">my</span> <span class=\"re0\">%cluster</span><span class=\"sy0\">;</span><br/>            <span class=\"re0\">$*TOLERANCE</span> <span class=\"sy0\">&lt;</span> <span class=\"br0\">[</span><span class=\"sy0\">+</span><span class=\"br0\">]</span> <span class=\"br0\">(</span><span class=\"re0\">@means</span> Z<span class=\"sy0\">-</span> <span class=\"kw3\">keys</span> <span class=\"br0\">(</span><span class=\"re0\">%cluster</span> <span class=\"sy0\">=</span> cluster<span class=\"br0\">)</span><span class=\"br0\">)</span>\u00bb<span class=\"sy0\">.</span><span class=\"kw3\">abs</span> <span class=\"kw1\">X</span><span class=\"sy0\">**</span> <span class=\"nu0\">2</span><span class=\"sy0\">;</span><br/>            <span class=\"re0\">@means</span> <span class=\"sy0\">=</span> <span class=\"re0\">%cluster</span><span class=\"sy0\">.</span><span class=\"kw3\">values</span><span class=\"sy0\">.</span><span class=\"kw3\">map</span><span class=\"br0\">(</span> <span class=\"br0\">{</span> <span class=\"sy0\">.</span><span class=\"kw3\">elems</span> R<span class=\"sy0\">/</span> <span class=\"br0\">[</span><span class=\"sy0\">+</span><span class=\"br0\">]</span> <span class=\"sy0\">@</span><span class=\"re0\">$_</span> <span class=\"br0\">}</span> <span class=\"br0\">)</span><br/>        <span class=\"br0\">)</span> <span class=\"br0\">{</span> <span class=\"sy0\">;</span> <span class=\"br0\">}</span><br/>        <span class=\"kw1\">return</span> <span class=\"re0\">@means</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw1\">my</span> <span class=\"re0\">@centers</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">,</span> <span class=\"nu0\">5</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span> <span class=\"sy0\">+</span> 2i<span class=\"sy0\">;</span><br/><span class=\"kw1\">my</span> <span class=\"re0\">@data</span> <span class=\"sy0\">=</span> flat <span class=\"re0\">@centers</span><span class=\"sy0\">.</span><span class=\"kw3\">map</span><span class=\"sy0\">:</span> <span class=\"br0\">{</span> <span class=\"br0\">(</span><span class=\"re0\">$_</span> <span class=\"sy0\">+</span> <span class=\"sy0\">.</span>5 <span class=\"sy0\">-</span> <span class=\"kw3\">rand</span> <span class=\"sy0\">+</span> <span class=\"br0\">(</span><span class=\"sy0\">.</span>5 <span class=\"sy0\">-</span> <span class=\"kw3\">rand</span><span class=\"br0\">)</span> <span class=\"sy0\">*</span> <span class=\"kw3\">i</span><span class=\"br0\">)</span> <span class=\"kw1\">xx</span> <span class=\"nu0\">100</span> <span class=\"br0\">}</span><br/><span class=\"re0\">@data</span><span class=\"sy0\">.=</span><span class=\"kw3\">pick</span><span class=\"br0\">(</span><span class=\"sy0\">*</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"sy0\">.</span><span class=\"kw3\">say</span> <span class=\"kw1\">for</span> <span class=\"nu0\">3</span><span class=\"sy0\">-</span>means<span class=\"sy0\">++</span><span class=\"br0\">(</span><span class=\"re0\">@data</span><span class=\"br0\">)</span><span class=\"sy0\">;</span></pre>"}, {"lang": "Python", "loc": 174, "block": "<pre class=\"python highlighted_source\"><span class=\"kw1\">from</span> <span class=\"kw3\">math</span> <span class=\"kw1\">import</span> pi<span class=\"sy0\">,</span> sin<span class=\"sy0\">,</span> cos<br/><span class=\"kw1\">from</span> <span class=\"kw3\">collections</span> <span class=\"kw1\">import</span> namedtuple<br/><span class=\"kw1\">from</span> <span class=\"kw3\">random</span> <span class=\"kw1\">import</span> <span class=\"kw3\">random</span><span class=\"sy0\">,</span> choice<br/><span class=\"kw1\">from</span> <span class=\"kw3\">copy</span> <span class=\"kw1\">import</span> <span class=\"kw3\">copy</span><br/>\u00a0<br/><span class=\"kw1\">try</span>:<br/>    <span class=\"kw1\">import</span> psyco<br/>    psyco.<span class=\"me1\">full</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/><span class=\"kw1\">except</span> <span class=\"kw2\">ImportError</span>:<br/>    <span class=\"kw1\">pass</span><br/>\u00a0<br/>\u00a0<br/>FLOAT_MAX <span class=\"sy0\">=</span> <span class=\"nu0\">1e100</span><br/>\u00a0<br/>\u00a0<br/><span class=\"kw1\">class</span> Point:<br/>    <span class=\"kw4\">__slots__</span> <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"st0\">\"x\"</span><span class=\"sy0\">,</span> <span class=\"st0\">\"y\"</span><span class=\"sy0\">,</span> <span class=\"st0\">\"group\"</span><span class=\"br0\">]</span><br/>    <span class=\"kw1\">def</span> <span class=\"kw4\">__init__</span><span class=\"br0\">(</span><span class=\"kw2\">self</span><span class=\"sy0\">,</span> x<span class=\"sy0\">=</span><span class=\"nu0\">0.0</span><span class=\"sy0\">,</span> y<span class=\"sy0\">=</span><span class=\"nu0\">0.0</span><span class=\"sy0\">,</span> group<span class=\"sy0\">=</span><span class=\"nu0\">0</span><span class=\"br0\">)</span>:<br/>        <span class=\"kw2\">self</span>.<span class=\"me1\">x</span><span class=\"sy0\">,</span> <span class=\"kw2\">self</span>.<span class=\"me1\">y</span><span class=\"sy0\">,</span> <span class=\"kw2\">self</span>.<span class=\"me1\">group</span> <span class=\"sy0\">=</span> x<span class=\"sy0\">,</span> y<span class=\"sy0\">,</span> group<br/>\u00a0<br/>\u00a0<br/><span class=\"kw1\">def</span> generate_points<span class=\"br0\">(</span>npoints<span class=\"sy0\">,</span> radius<span class=\"br0\">)</span>:<br/>    points <span class=\"sy0\">=</span> <span class=\"br0\">[</span>Point<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">for</span> _ <span class=\"kw1\">in</span> <span class=\"kw2\">xrange</span><span class=\"br0\">(</span>npoints<span class=\"br0\">)</span><span class=\"br0\">]</span><br/>\u00a0<br/>    <span class=\"co1\"># note: this is not a uniform 2-d distribution</span><br/>    <span class=\"kw1\">for</span> p <span class=\"kw1\">in</span> points:<br/>        r <span class=\"sy0\">=</span> <span class=\"kw3\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span> * radius<br/>        ang <span class=\"sy0\">=</span> <span class=\"kw3\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span> * <span class=\"nu0\">2</span> * pi<br/>        p.<span class=\"me1\">x</span> <span class=\"sy0\">=</span> r * cos<span class=\"br0\">(</span>ang<span class=\"br0\">)</span><br/>        p.<span class=\"me1\">y</span> <span class=\"sy0\">=</span> r * sin<span class=\"br0\">(</span>ang<span class=\"br0\">)</span><br/>\u00a0<br/>    <span class=\"kw1\">return</span> points<br/>\u00a0<br/>\u00a0<br/><span class=\"kw1\">def</span> nearest_cluster_center<span class=\"br0\">(</span>point<span class=\"sy0\">,</span> cluster_centers<span class=\"br0\">)</span>:<br/>    <span class=\"st0\">\"\"\"Distance and index of the closest cluster center\"\"\"</span><br/>    <span class=\"kw1\">def</span> sqr_distance_2D<span class=\"br0\">(</span>a<span class=\"sy0\">,</span> b<span class=\"br0\">)</span>:<br/>        <span class=\"kw1\">return</span> <span class=\"br0\">(</span>a.<span class=\"me1\">x</span> - b.<span class=\"me1\">x</span><span class=\"br0\">)</span> ** <span class=\"nu0\">2</span>  +  <span class=\"br0\">(</span>a.<span class=\"me1\">y</span> - b.<span class=\"me1\">y</span><span class=\"br0\">)</span> ** <span class=\"nu0\">2</span><br/>\u00a0<br/>    min_index <span class=\"sy0\">=</span> point.<span class=\"me1\">group</span><br/>    min_dist <span class=\"sy0\">=</span> FLOAT_MAX<br/>\u00a0<br/>    <span class=\"kw1\">for</span> i<span class=\"sy0\">,</span> cc <span class=\"kw1\">in</span> <span class=\"kw2\">enumerate</span><span class=\"br0\">(</span>cluster_centers<span class=\"br0\">)</span>:<br/>        d <span class=\"sy0\">=</span> sqr_distance_2D<span class=\"br0\">(</span>cc<span class=\"sy0\">,</span> point<span class=\"br0\">)</span><br/>        <span class=\"kw1\">if</span> min_dist <span class=\"sy0\">&gt;</span> d:<br/>            min_dist <span class=\"sy0\">=</span> d<br/>            min_index <span class=\"sy0\">=</span> i<br/>\u00a0<br/>    <span class=\"kw1\">return</span> <span class=\"br0\">(</span>min_index<span class=\"sy0\">,</span> min_dist<span class=\"br0\">)</span><br/>\u00a0<br/>\u00a0<br/><span class=\"kw1\">def</span> kpp<span class=\"br0\">(</span>points<span class=\"sy0\">,</span> cluster_centers<span class=\"br0\">)</span>:<br/>    cluster_centers<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"kw3\">copy</span><span class=\"br0\">(</span>choice<span class=\"br0\">(</span>points<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>    d <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"nu0\">0.0</span> <span class=\"kw1\">for</span> _ <span class=\"kw1\">in</span> <span class=\"kw2\">xrange</span><span class=\"br0\">(</span><span class=\"kw2\">len</span><span class=\"br0\">(</span>points<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">]</span><br/>\u00a0<br/>    <span class=\"kw1\">for</span> i <span class=\"kw1\">in</span> <span class=\"kw2\">xrange</span><span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"kw2\">len</span><span class=\"br0\">(</span>cluster_centers<span class=\"br0\">)</span><span class=\"br0\">)</span>:<br/>        <span class=\"kw2\">sum</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><br/>        <span class=\"kw1\">for</span> j<span class=\"sy0\">,</span> p <span class=\"kw1\">in</span> <span class=\"kw2\">enumerate</span><span class=\"br0\">(</span>points<span class=\"br0\">)</span>:<br/>            d<span class=\"br0\">[</span>j<span class=\"br0\">]</span> <span class=\"sy0\">=</span> nearest_cluster_center<span class=\"br0\">(</span>p<span class=\"sy0\">,</span> cluster_centers<span class=\"br0\">[</span>:i<span class=\"br0\">]</span><span class=\"br0\">)</span><span class=\"br0\">[</span><span class=\"nu0\">1</span><span class=\"br0\">]</span><br/>            <span class=\"kw2\">sum</span> +<span class=\"sy0\">=</span> d<span class=\"br0\">[</span>j<span class=\"br0\">]</span><br/>\u00a0<br/>        <span class=\"kw2\">sum</span> *<span class=\"sy0\">=</span> <span class=\"kw3\">random</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/>        <span class=\"kw1\">for</span> j<span class=\"sy0\">,</span> di <span class=\"kw1\">in</span> <span class=\"kw2\">enumerate</span><span class=\"br0\">(</span>d<span class=\"br0\">)</span>:<br/>            <span class=\"kw2\">sum</span> -<span class=\"sy0\">=</span> di<br/>            <span class=\"kw1\">if</span> <span class=\"kw2\">sum</span> <span class=\"sy0\">&gt;</span> <span class=\"nu0\">0</span>:<br/>                <span class=\"kw1\">continue</span><br/>            cluster_centers<span class=\"br0\">[</span>i<span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"kw3\">copy</span><span class=\"br0\">(</span>points<span class=\"br0\">[</span>j<span class=\"br0\">]</span><span class=\"br0\">)</span><br/>            <span class=\"kw1\">break</span><br/>\u00a0<br/>    <span class=\"kw1\">for</span> p <span class=\"kw1\">in</span> points:<br/>        p.<span class=\"me1\">group</span> <span class=\"sy0\">=</span> nearest_cluster_center<span class=\"br0\">(</span>p<span class=\"sy0\">,</span> cluster_centers<span class=\"br0\">)</span><span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span><br/>\u00a0<br/>\u00a0<br/><span class=\"kw1\">def</span> lloyd<span class=\"br0\">(</span>points<span class=\"sy0\">,</span> nclusters<span class=\"br0\">)</span>:<br/>    cluster_centers <span class=\"sy0\">=</span> <span class=\"br0\">[</span>Point<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">for</span> _ <span class=\"kw1\">in</span> <span class=\"kw2\">xrange</span><span class=\"br0\">(</span>nclusters<span class=\"br0\">)</span><span class=\"br0\">]</span><br/>\u00a0<br/>    <span class=\"co1\"># call k++ init</span><br/>    kpp<span class=\"br0\">(</span>points<span class=\"sy0\">,</span> cluster_centers<span class=\"br0\">)</span><br/>\u00a0<br/>    lenpts10 <span class=\"sy0\">=</span> <span class=\"kw2\">len</span><span class=\"br0\">(</span>points<span class=\"br0\">)</span> <span class=\"sy0\">&gt;&gt;</span> <span class=\"nu0\">10</span><br/>\u00a0<br/>    changed <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><br/>    <span class=\"kw1\">while</span> <span class=\"kw2\">True</span>:<br/>        <span class=\"co1\"># group element for centroids are used as counters</span><br/>        <span class=\"kw1\">for</span> cc <span class=\"kw1\">in</span> cluster_centers:<br/>            cc.<span class=\"me1\">x</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><br/>            cc.<span class=\"me1\">y</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><br/>            cc.<span class=\"me1\">group</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><br/>\u00a0<br/>        <span class=\"kw1\">for</span> p <span class=\"kw1\">in</span> points:<br/>            cluster_centers<span class=\"br0\">[</span>p.<span class=\"me1\">group</span><span class=\"br0\">]</span>.<span class=\"me1\">group</span> +<span class=\"sy0\">=</span> <span class=\"nu0\">1</span><br/>            cluster_centers<span class=\"br0\">[</span>p.<span class=\"me1\">group</span><span class=\"br0\">]</span>.<span class=\"me1\">x</span> +<span class=\"sy0\">=</span> p.<span class=\"me1\">x</span><br/>            cluster_centers<span class=\"br0\">[</span>p.<span class=\"me1\">group</span><span class=\"br0\">]</span>.<span class=\"me1\">y</span> +<span class=\"sy0\">=</span> p.<span class=\"me1\">y</span><br/>\u00a0<br/>        <span class=\"kw1\">for</span> cc <span class=\"kw1\">in</span> cluster_centers:<br/>            cc.<span class=\"me1\">x</span> /<span class=\"sy0\">=</span> cc.<span class=\"me1\">group</span><br/>            cc.<span class=\"me1\">y</span> /<span class=\"sy0\">=</span> cc.<span class=\"me1\">group</span><br/>\u00a0<br/>        <span class=\"co1\"># find closest centroid of each PointPtr</span><br/>        changed <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><br/>        <span class=\"kw1\">for</span> p <span class=\"kw1\">in</span> points:<br/>            min_i <span class=\"sy0\">=</span> nearest_cluster_center<span class=\"br0\">(</span>p<span class=\"sy0\">,</span> cluster_centers<span class=\"br0\">)</span><span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span><br/>            <span class=\"kw1\">if</span> min_i <span class=\"sy0\">!=</span> p.<span class=\"me1\">group</span>:<br/>                changed +<span class=\"sy0\">=</span> <span class=\"nu0\">1</span><br/>                p.<span class=\"me1\">group</span> <span class=\"sy0\">=</span> min_i<br/>\u00a0<br/>        <span class=\"co1\"># stop when 99.9% of points are good</span><br/>        <span class=\"kw1\">if</span> changed <span class=\"sy0\">&lt;=</span> lenpts10:<br/>            <span class=\"kw1\">break</span><br/>\u00a0<br/>    <span class=\"kw1\">for</span> i<span class=\"sy0\">,</span> cc <span class=\"kw1\">in</span> <span class=\"kw2\">enumerate</span><span class=\"br0\">(</span>cluster_centers<span class=\"br0\">)</span>:<br/>        cc.<span class=\"me1\">group</span> <span class=\"sy0\">=</span> i<br/>\u00a0<br/>    <span class=\"kw1\">return</span> cluster_centers<br/>\u00a0<br/>\u00a0<br/><span class=\"kw1\">def</span> print_eps<span class=\"br0\">(</span>points<span class=\"sy0\">,</span> cluster_centers<span class=\"sy0\">,</span> W<span class=\"sy0\">=</span><span class=\"nu0\">400</span><span class=\"sy0\">,</span> H<span class=\"sy0\">=</span><span class=\"nu0\">400</span><span class=\"br0\">)</span>:<br/>    Color <span class=\"sy0\">=</span> namedtuple<span class=\"br0\">(</span><span class=\"st0\">\"Color\"</span><span class=\"sy0\">,</span> <span class=\"st0\">\"r g b\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    colors <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><br/>    <span class=\"kw1\">for</span> i <span class=\"kw1\">in</span> <span class=\"kw2\">xrange</span><span class=\"br0\">(</span><span class=\"kw2\">len</span><span class=\"br0\">(</span>cluster_centers<span class=\"br0\">)</span><span class=\"br0\">)</span>:<br/>        colors.<span class=\"me1\">append</span><span class=\"br0\">(</span>Color<span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"nu0\">3</span> * <span class=\"br0\">(</span>i + <span class=\"nu0\">1</span><span class=\"br0\">)</span>\u00a0% <span class=\"nu0\">11</span><span class=\"br0\">)</span> / <span class=\"nu0\">11.0</span><span class=\"sy0\">,</span><br/>                            <span class=\"br0\">(</span><span class=\"nu0\">7</span> * i\u00a0% <span class=\"nu0\">11</span><span class=\"br0\">)</span> / <span class=\"nu0\">11.0</span><span class=\"sy0\">,</span><br/>                            <span class=\"br0\">(</span><span class=\"nu0\">9</span> * i\u00a0% <span class=\"nu0\">11</span><span class=\"br0\">)</span> / <span class=\"nu0\">11.0</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/>    max_x <span class=\"sy0\">=</span> max_y <span class=\"sy0\">=</span> -FLOAT_MAX<br/>    min_x <span class=\"sy0\">=</span> min_y <span class=\"sy0\">=</span> FLOAT_MAX<br/>\u00a0<br/>    <span class=\"kw1\">for</span> p <span class=\"kw1\">in</span> points:<br/>        <span class=\"kw1\">if</span> max_x <span class=\"sy0\">&lt;</span> p.<span class=\"me1\">x</span>: max_x <span class=\"sy0\">=</span> p.<span class=\"me1\">x</span><br/>        <span class=\"kw1\">if</span> min_x <span class=\"sy0\">&gt;</span> p.<span class=\"me1\">x</span>: min_x <span class=\"sy0\">=</span> p.<span class=\"me1\">x</span><br/>        <span class=\"kw1\">if</span> max_y <span class=\"sy0\">&lt;</span> p.<span class=\"me1\">y</span>: max_y <span class=\"sy0\">=</span> p.<span class=\"me1\">y</span><br/>        <span class=\"kw1\">if</span> min_y <span class=\"sy0\">&gt;</span> p.<span class=\"me1\">y</span>: min_y <span class=\"sy0\">=</span> p.<span class=\"me1\">y</span><br/>\u00a0<br/>    scale <span class=\"sy0\">=</span> <span class=\"kw2\">min</span><span class=\"br0\">(</span>W / <span class=\"br0\">(</span>max_x - min_x<span class=\"br0\">)</span><span class=\"sy0\">,</span><br/>                H / <span class=\"br0\">(</span>max_y - min_y<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>    cx <span class=\"sy0\">=</span> <span class=\"br0\">(</span>max_x + min_x<span class=\"br0\">)</span> / <span class=\"nu0\">2</span><br/>    cy <span class=\"sy0\">=</span> <span class=\"br0\">(</span>max_y + min_y<span class=\"br0\">)</span> / <span class=\"nu0\">2</span><br/>\u00a0<br/>    <span class=\"kw1\">print</span> <span class=\"st0\">\"%%!PS-Adobe-3.0<span class=\"es0\">\\n</span>%%%%BoundingBox: -5 -5\u00a0%d\u00a0%d\"</span>\u00a0% <span class=\"br0\">(</span>W + <span class=\"nu0\">10</span><span class=\"sy0\">,</span> H + <span class=\"nu0\">10</span><span class=\"br0\">)</span><br/>\u00a0<br/>    <span class=\"kw1\">print</span> <span class=\"br0\">(</span><span class=\"st0\">\"/l {rlineto} def /m {rmoveto} def<span class=\"es0\">\\n</span>\"</span> +<br/>           <span class=\"st0\">\"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def<span class=\"es0\">\\n</span>\"</span> +<br/>           <span class=\"st0\">\"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \"</span> +<br/>           <span class=\"st0\">\"   gsave 1 setgray fill grestore gsave 3 setlinewidth\"</span> +<br/>           <span class=\"st0\">\" 1 setgray stroke grestore 0 setgray stroke }def\"</span><span class=\"br0\">)</span><br/>\u00a0<br/>    <span class=\"kw1\">for</span> i<span class=\"sy0\">,</span> cc <span class=\"kw1\">in</span> <span class=\"kw2\">enumerate</span><span class=\"br0\">(</span>cluster_centers<span class=\"br0\">)</span>:<br/>        <span class=\"kw1\">print</span> <span class=\"br0\">(</span><span class=\"st0\">\"%g\u00a0%g\u00a0%g setrgbcolor\"</span>\u00a0%<br/>               <span class=\"br0\">(</span>colors<span class=\"br0\">[</span>i<span class=\"br0\">]</span>.<span class=\"me1\">r</span><span class=\"sy0\">,</span> colors<span class=\"br0\">[</span>i<span class=\"br0\">]</span>.<span class=\"me1\">g</span><span class=\"sy0\">,</span> colors<span class=\"br0\">[</span>i<span class=\"br0\">]</span>.<span class=\"me1\">b</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/>        <span class=\"kw1\">for</span> p <span class=\"kw1\">in</span> points:<br/>            <span class=\"kw1\">if</span> p.<span class=\"me1\">group</span> <span class=\"sy0\">!=</span> i:<br/>                <span class=\"kw1\">continue</span><br/>            <span class=\"kw1\">print</span> <span class=\"br0\">(</span><span class=\"st0\">\"%.3f\u00a0%.3f c\"</span>\u00a0% <span class=\"br0\">(</span><span class=\"br0\">(</span>p.<span class=\"me1\">x</span> - cx<span class=\"br0\">)</span> * scale + W / <span class=\"nu0\">2</span><span class=\"sy0\">,</span><br/>                                    <span class=\"br0\">(</span>p.<span class=\"me1\">y</span> - cy<span class=\"br0\">)</span> * scale + H / <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/>        <span class=\"kw1\">print</span> <span class=\"br0\">(</span><span class=\"st0\">\"<span class=\"es0\">\\n</span>0 setgray\u00a0%g\u00a0%g s\"</span>\u00a0% <span class=\"br0\">(</span><span class=\"br0\">(</span>cc.<span class=\"me1\">x</span> - cx<span class=\"br0\">)</span> * scale + W / <span class=\"nu0\">2</span><span class=\"sy0\">,</span><br/>                                        <span class=\"br0\">(</span>cc.<span class=\"me1\">y</span> - cy<span class=\"br0\">)</span> * scale + H / <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/>    <span class=\"kw1\">print</span> <span class=\"st0\">\"<span class=\"es0\">\\n</span>%%%%EOF\"</span><br/>\u00a0<br/>\u00a0<br/><span class=\"kw1\">def</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span>:<br/>    npoints <span class=\"sy0\">=</span> <span class=\"nu0\">30000</span><br/>    k <span class=\"sy0\">=</span> <span class=\"nu0\">7</span> <span class=\"co1\"># # clusters</span><br/>\u00a0<br/>    points <span class=\"sy0\">=</span> generate_points<span class=\"br0\">(</span>npoints<span class=\"sy0\">,</span> <span class=\"nu0\">10</span><span class=\"br0\">)</span><br/>    cluster_centers <span class=\"sy0\">=</span> lloyd<span class=\"br0\">(</span>points<span class=\"sy0\">,</span> k<span class=\"br0\">)</span><br/>    print_eps<span class=\"br0\">(</span>points<span class=\"sy0\">,</span> cluster_centers<span class=\"br0\">)</span><br/>\u00a0<br/>\u00a0<br/>main<span class=\"br0\">(</span><span class=\"br0\">)</span></pre>"}, {"lang": "Racket", "loc": 36, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>#lang racket<br/>(require racket/dict<br/>         math/distributions)<br/>\u00a0<br/>;; Divides the set of points into k clusters<br/>;; using the standard k-means clustering algorithm<br/>(define (k-means data k #:initialization (init k-means++))<br/>  (define (iteration centroids)     <br/>    (map centroid (clusterize data centroids)))<br/>  (fixed-point iteration (init data k) #:same-test small-shift?))<br/>\u00a0<br/>;; Finds the centroid for a set of points<br/>(define (centroid pts)<br/>  (vector-map (curryr / (length pts))<br/>       (for/fold ([sum (car pts)]) ([x (in-list (cdr pts))])<br/>         (vector-map + x sum))))<br/>\u00a0<br/>;; Divides the set of points into clusters<br/>;; using given centroids<br/>(define (clusterize data centroids)<br/>  (for*/fold ([res (map list centroids)]) ([x (in-list data)])<br/>    (define c (argmin (distanse-to x) centroids))<br/>    (dict-set res c (cons x (dict-ref res c)))))<br/>\u00a0<br/>;; Stop criterion: all centroids change their positions<br/>;; by less then 0.1% of the minimal distance between centroids.<br/>(define (small-shift? c1 c2)<br/>  (define min-distance<br/>    (apply min<br/>           (for*/list ([x (in-list c2)]<br/>                       [y (in-list c2)] #:unless (equal? x y))<br/>             ((metric) x y))))<br/>  (for/and ([a (in-list c1)] [b (in-list c2)])<br/>    (&lt; ((metric) a b) (* 0.001 min-distance))))<br/>\u00a0</pre>"}, {"lang": "Rust", "loc": 300, "block": "<pre class=\"text highlighted_source\">extern crate csv;<br/>extern crate getopts;<br/>extern crate gnuplot;<br/>extern crate nalgebra;<br/>extern crate num;<br/>extern crate rand;<br/>extern crate rustc_serialize;<br/>extern crate test;<br/>\u00a0<br/>use getopts::Options;<br/>use gnuplot::{Axes2D, AxesCommon, Color, Figure, Fix, PointSize, PointSymbol};<br/>use nalgebra::{DVector, Iterable};<br/>use rand::{Rng, SeedableRng, StdRng};<br/>use rand::distributions::{IndependentSample, Range};<br/>use std::f64::consts::PI;<br/>use std::env;<br/>\u00a0<br/>type Point = DVector&lt;f64&gt;;<br/>\u00a0<br/>struct Cluster&lt;'a&gt; {<br/>    members: Vec&lt;&amp;'a Point&gt;,<br/>    center: Point,<br/>}<br/>\u00a0<br/>struct Stats {<br/>    centroids: Vec&lt;Point&gt;,<br/>    mean_d_from_centroid: DVector&lt;f64&gt;,<br/>}<br/>\u00a0<br/>/// DVector doesn't implement BaseFloat, so a custom distance function is required.<br/>fn sqdist(p1: &amp;Point, p2: &amp;Point) -&gt; f64 {<br/>    (p1.clone() - p2.clone()).iter().map(|x| x * x).fold(0f64, |a, b| a + b)<br/>}<br/>\u00a0<br/>/// Returns (distance^2, index) tuple of winning point.<br/>fn nearest(p: &amp;Point, candidates: &amp;Vec&lt;Point&gt;) -&gt; (f64, usize) {<br/>    let (dsquared, the_index) = candidates.iter()<br/>                                          .enumerate()<br/>                                          .fold((sqdist(p, &amp;candidates[0]), 0),<br/>                                                |(d, index), next| {<br/>                                                    let dprime = sqdist(p, &amp;candidates[next.0]);<br/>                                                    if dprime &lt; d {<br/>                                                        (dprime, next.0)<br/>                                                    } else {<br/>                                                        (d, index)<br/>                                                    }<br/>                                                });<br/>    (dsquared, the_index)<br/>}<br/>\u00a0<br/>/// Computes starting centroids and makes initial assignments.<br/>fn kpp(points: &amp;Vec&lt;Point&gt;, k: usize, rng: &amp;mut StdRng) -&gt; Stats {<br/>    let mut centroids: Vec&lt;Point&gt; = Vec::new();<br/>    // Random point for first centroid guess:<br/>    centroids.push(points[rng.gen::&lt;usize&gt;()\u00a0% points.len()].clone());<br/>    let mut dists: Vec&lt;f64&gt; = vec![0f64; points.len()];<br/>\u00a0<br/>    for _ in 1..k {<br/>        let mut sum = 0f64;<br/>        for (j, p) in points.iter().enumerate() {<br/>            let (dsquared, _) = nearest(&amp;p, &amp;centroids);<br/>            dists[j] = dsquared;<br/>            sum += dsquared;<br/>        }<br/>\u00a0<br/>        // This part chooses the next cluster center with a probability proportional to d^2<br/>        sum *= rng.next_f64();<br/>        for (j, d) in dists.iter().enumerate() {<br/>            sum -= *d;<br/>            if sum &lt;= 0f64 {<br/>                centroids.push(points[j].clone());<br/>                break;<br/>            }<br/>        }<br/>    }<br/>\u00a0<br/>    let clusters = assign_clusters(points, &amp;centroids);<br/>    compute_stats(&amp;clusters)<br/>}<br/>\u00a0<br/>fn assign_clusters&lt;'a&gt;(points: &amp;'a Vec&lt;Point&gt;, centroids: &amp;Vec&lt;Point&gt;) -&gt; Vec&lt;Cluster&lt;'a&gt;&gt; {<br/>    let mut clusters: Vec&lt;Cluster&gt; = Vec::new();<br/>\u00a0<br/>    for _ in 0..centroids.len() {<br/>        clusters.push(Cluster {<br/>            members: Vec::new(),<br/>            center: DVector::new_zeros(points[0].len()),<br/>        });<br/>    }<br/>\u00a0<br/>    for p in points.iter() {<br/>        let (_, nearest_index) = nearest(p, centroids);<br/>        clusters[nearest_index].center = clusters[nearest_index].center.clone() + p.clone();<br/>        clusters[nearest_index].members.push(p);<br/>    }<br/>\u00a0<br/>    for i in 0..clusters.len() {<br/>        clusters[i].center = clusters[i].center.clone() / clusters[i].members.len() as f64;<br/>    }<br/>\u00a0<br/>    clusters<br/>}<br/>\u00a0<br/>/// Computes centroids and mean-distance-from-centroid for each cluster.<br/>fn compute_stats(clusters: &amp;Vec&lt;Cluster&gt;) -&gt; Stats {<br/>    let mut centroids = Vec::new();<br/>    let mut means_vec = Vec::new();<br/>\u00a0<br/>    for c in clusters.iter() {<br/>        let pts = &amp;c.members;<br/>        let seed: DVector&lt;f64&gt; = DVector::new_zeros(pts[0].len());<br/>        let centroid = pts.iter().fold(seed, |a, &amp;b| a + b.clone()) / pts.len() as f64;<br/>        means_vec.push(pts.iter().fold(0f64, |acc, pt| acc + sqdist(pt, &amp;centroid).sqrt()) /<br/>                       pts.len() as f64);<br/>        centroids.push(centroid);<br/>    }<br/>\u00a0<br/>    Stats {<br/>        centroids: centroids,<br/>        mean_d_from_centroid: DVector::from_slice(means_vec.len(), means_vec.as_slice()),<br/>    }<br/>}<br/>\u00a0<br/>fn lloyd&lt;'a&gt;(points: &amp;'a Vec&lt;Point&gt;,<br/>             k: usize,<br/>             stoppage_delta: f64,<br/>             max_iter: u32,<br/>             rng: &amp;mut StdRng)<br/>             -&gt; (Vec&lt;Cluster&lt;'a&gt;&gt;, Stats) {<br/>\u00a0<br/>    let mut clusters = Vec::new();<br/>    // Choose starting centroids and make initial assignments<br/>    let mut stats = kpp(points, k, rng);<br/>\u00a0<br/>    for i in 1..max_iter {<br/>        let last_means: DVector&lt;f64&gt; = stats.mean_d_from_centroid.clone();<br/>        clusters = assign_clusters(points, &amp;stats.centroids);<br/>        stats = compute_stats(&amp;clusters);<br/>        let err = sqdist(&amp;stats.mean_d_from_centroid, &amp;last_means).sqrt();<br/>        if err &lt; stoppage_delta {<br/>            println!(\"Stoppage condition reached on iteration {}\", i);<br/>            return (clusters, stats);<br/>        }<br/>        // Console output<br/>        print!(\"Iter {}: \", i);<br/>        for (cen, mu) in stats.centroids.iter().zip(stats.mean_d_from_centroid.iter()) {<br/>            print_dvec(cen);<br/>            print!(\" {:1.2} | \", mu);<br/>        }<br/>        print!(\"{:1.5}\\n\", err);<br/>    }<br/>\u00a0<br/>    println!(\"Stoppage condition not reached by iteration {}\", max_iter);<br/>    (clusters, stats)<br/>}<br/>\u00a0<br/>/// Uniform sampling on the unit disk.<br/>fn generate_points(n: u32, rng: &amp;mut StdRng) -&gt; Vec&lt;Point&gt; {<br/>    let r_range = Range::new(0f64, 1f64);<br/>    let theta_range = Range::new(0f64, 2f64 * PI);<br/>    let mut points: Vec&lt;Point&gt; = Vec::new();<br/>\u00a0<br/>    for _ in 0..n {<br/>        let root_r = r_range.ind_sample(rng).sqrt();<br/>        let theta = theta_range.ind_sample(rng);<br/>        points.push(DVector::&lt;f64&gt;::from_slice(2, &amp;[root_r * theta.cos(), root_r * theta.sin()]));<br/>    }<br/>\u00a0<br/>    points<br/>}<br/>\u00a0<br/>// Plot clusters (2d only). Closure idiom allows us to borrow and mutate the Axes2D.<br/>fn viz(clusters: Vec&lt;Cluster&gt;, stats: Stats, k: usize, n: u32, e: f64) {<br/>    let mut fg = Figure::new();<br/>    {<br/>        let prep = |fg: &amp;mut Figure| {<br/>            let axes: &amp;mut Axes2D = fg.axes2d();<br/>            let title: String = format!(\"k = {}, n = {}, e = {:4}\", k, n, e);<br/>            let centroids_x = stats.centroids.iter().map(|c| c[0]);<br/>            let centroids_y = stats.centroids.iter().map(|c| c[1]);<br/>            for cluster in clusters.iter() {<br/>                axes.points(cluster.members.iter().map(|p| p[0]),<br/>                            cluster.members<br/>                                   .iter()<br/>                                   .map(|p| p[1]),<br/>                            &amp;[PointSymbol('O'), PointSize(0.25)]);<br/>            }<br/>            axes.set_aspect_ratio(Fix(1.0))<br/>                .points(centroids_x,<br/>                        centroids_y,<br/>                        &amp;[PointSymbol('o'), PointSize(1.5), Color(\"black\")])<br/>                .set_title(&amp;title[..], &amp;[]);<br/>        };<br/>        prep(&amp;mut fg);<br/>    }<br/>    fg.show();<br/>}<br/>\u00a0<br/>fn print_dvec(v: &amp;DVector&lt;f64&gt;) {<br/>    print!(\"(\");<br/>    for elem in v.at.iter().take(v.len() - 1) {<br/>        print!(\"{:+1.2}, \", elem)<br/>    }<br/>    print!(\"{:+1.2})\", v.at.iter().last().unwrap());<br/>}<br/>\u00a0<br/>fn print_usage(program: &amp;str, opts: Options) {<br/>    let brief = format!(\"Usage: {} [options]\", program);<br/>    print!(\"{}\", opts.usage(&amp;brief));<br/>}<br/>\u00a0<br/>fn main() {<br/>    let args: Vec&lt;String&gt; = env::args().collect();<br/>    let mut k: usize = 7;<br/>    let mut n: u32 = 30000;<br/>    let mut e: f64 = 1e-3;<br/>    let max_iterations = 100u32;<br/>\u00a0<br/>    let mut opts = Options::new();<br/>    opts.optflag(\"?\", \"help\", \"Print this help menu\");<br/>    opts.optopt(\"k\",<br/>                \"\",<br/>                \"Number of clusters to assign (default: 7)\",<br/>                \"&lt;clusters&gt;\");<br/>    opts.optopt(\"n\",<br/>                \"\",<br/>                \"Operate on this many points on the unit disk (default: 30000)\",<br/>                \"&lt;pts&gt;\");<br/>    opts.optopt(\"e\",<br/>                \"\",<br/>                \"Min delta in norm of successive cluster centroids to continue (default: 1e-3)\",<br/>                \"&lt;eps&gt;\");<br/>    opts.optopt(\"f\", \"\", \"Read points from file (overrides -n)\", \"&lt;csv&gt;\");<br/>\u00a0<br/>    let program = args[0].clone();<br/>    let matches = match opts.parse(&amp;args[1..]) {<br/>        Ok(m) =&gt; m,<br/>        Err(f) =&gt; panic!(f.to_string()),<br/>    };<br/>    if matches.opt_present(\"?\") {<br/>        print_usage(&amp;program, opts);<br/>        return;<br/>    }<br/>    match matches.opt_str(\"k\") {<br/>        None =&gt; {}<br/>        Some(x) =&gt; k = x.parse::&lt;usize&gt;().unwrap(),<br/>    };<br/>    match matches.opt_str(\"n\") {<br/>        None =&gt; {}<br/>        Some(x) =&gt; n = x.parse::&lt;u32&gt;().unwrap(),<br/>    };<br/>    match matches.opt_str(\"e\") {<br/>        None =&gt; {}<br/>        Some(x) =&gt; e = x.parse::&lt;f64&gt;().unwrap(),<br/>    };<br/>\u00a0<br/>    let seed: &amp;[_] = &amp;[1, 2, 3, 4];<br/>    let mut rng: StdRng = SeedableRng::from_seed(seed);<br/>\u00a0<br/>    let mut points: Vec&lt;Point&gt;;<br/>\u00a0<br/>    match matches.opt_str(\"f\") {<br/>        None =&gt; {<br/>            // Proceed with random 2d data<br/>            points = generate_points(n, &amp;mut rng)<br/>        }<br/>        Some(file) =&gt; {<br/>            points = Vec::new();<br/>            let mut rdr = csv::Reader::from_file(file.clone()).unwrap();<br/>            for row in rdr.records().map(|r| r.unwrap()) {<br/>                // row is Vec&lt;String&gt;<br/>                let floats: Vec&lt;f64&gt; = row.iter().map(|s| s.parse::&lt;f64&gt;().unwrap()).collect();<br/>                points.push(DVector::&lt;f64&gt;::from_slice(floats.len(), floats.as_slice()));<br/>            }<br/>            assert!(points.iter().all(|v| v.len() == points[0].len()));<br/>            n = points.len() as u32;<br/>            println!(\"Read {} points from {}\", points.len(), file.clone());<br/>        }<br/>    };<br/>\u00a0<br/>    assert!(points.len() &gt;= k);<br/>    let (clusters, stats) = lloyd(&amp;points, k, e, max_iterations, &amp;mut rng);<br/>\u00a0<br/>    println!(\" k       centroid{}mean dist    pop\",<br/>             std::iter::repeat(\" \").take((points[0].len() - 2) * 7 + 7).collect::&lt;String&gt;());<br/>    println!(\"===  {}  ===========  =====\",<br/>             std::iter::repeat(\"=\").take(points[0].len() * 7 + 2).collect::&lt;String&gt;());<br/>    for i in 0..clusters.len() {<br/>        print!(\" {:&gt;1}    \", i);<br/>        print_dvec(&amp;stats.centroids[i]);<br/>        print!(\"      {:1.2}       {:&gt;4}\\n\",<br/>               stats.mean_d_from_centroid[i],<br/>               clusters[i].members.len());<br/>    }<br/>\u00a0<br/>    if points[0].len() == 2 {<br/>        viz(clusters, stats, k, n, e)<br/>    }<br/>}<br/>\u00a0</pre>"}, {"lang": "Scheme", "loc": 180, "block": "<pre class=\"scheme highlighted_source\">\u00a0<br/><span class=\"br0\">(</span>import <span class=\"br0\">(</span>scheme base<span class=\"br0\">)</span> <span class=\"co1\">; headers for R7RS Scheme</span><br/>        <span class=\"br0\">(</span>scheme file<span class=\"br0\">)</span><br/>        <span class=\"br0\">(</span>scheme inexact<span class=\"br0\">)</span><br/>        <span class=\"br0\">(</span>scheme <span class=\"kw1\">write</span><span class=\"br0\">)</span><br/>        <span class=\"br0\">(</span>srfi <span class=\"nu0\">1</span> lists<span class=\"br0\">)</span><br/>        <span class=\"br0\">(</span>srfi <span class=\"nu0\">27</span> random<span class=\"sy0\">-</span>bits<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;; calculate euclidean distance between points, any dimension</span><br/><span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>euclidean<span class=\"sy0\">-</span>distance pt1 pt2<span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">sqrt</span> <span class=\"br0\">(</span>apply <span class=\"sy0\">+</span> <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>x y<span class=\"br0\">)</span> <span class=\"br0\">(</span>square <span class=\"br0\">(</span><span class=\"sy0\">-</span> x y<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> pt1 pt2<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;; input</span><br/><span class=\"co1\">;; - K: the target number of clusters K</span><br/><span class=\"co1\">;; - data: a list of points in the Cartesian plane</span><br/><span class=\"co1\">;; output</span><br/><span class=\"co1\">;; - a list of K centres</span><br/><span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>kmeans<span class=\"sy0\">++</span> K data<span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>select<span class=\"sy0\">-</span>uniformly data<span class=\"br0\">)</span><br/>    <span class=\"br0\">(</span><span class=\"kw1\">let</span> loop <span class=\"br0\">(</span><span class=\"br0\">(</span>index <span class=\"br0\">(</span>random<span class=\"sy0\">-</span>integer <span class=\"br0\">(</span><span class=\"kw1\">length</span> data<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"co1\">; uniform selection of index</span><br/>               <span class=\"br0\">(</span>rem data<span class=\"br0\">)</span><br/>               <span class=\"br0\">(</span>front '<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>      <span class=\"br0\">(</span><span class=\"kw1\">if</span> <span class=\"br0\">(</span><span class=\"kw1\">zero?</span> index<span class=\"br0\">)</span><br/>        <span class=\"br0\">(</span>values <span class=\"br0\">(</span><span class=\"kw1\">car</span> rem<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw1\">append</span> <span class=\"br0\">(</span><span class=\"kw1\">reverse</span> front<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw1\">cdr</span> rem<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>        <span class=\"br0\">(</span>loop <span class=\"br0\">(</span><span class=\"sy0\">-</span> index <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw1\">cdr</span> rem<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw1\">cons</span> <span class=\"br0\">(</span><span class=\"kw1\">car</span> rem<span class=\"br0\">)</span> front<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>  <span class=\"co1\">;</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>select<span class=\"sy0\">-</span>weighted centres data<span class=\"br0\">)</span><br/>    <span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>distance<span class=\"sy0\">-</span>to<span class=\"sy0\">-</span>nearest datum<span class=\"br0\">)</span><br/>      <span class=\"br0\">(</span>apply <span class=\"kw1\">min</span> <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>c<span class=\"br0\">)</span> <span class=\"br0\">(</span>euclidean<span class=\"sy0\">-</span>distance c datum<span class=\"br0\">)</span><span class=\"br0\">)</span> centres<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>    <span class=\"co1\">;</span><br/>    <span class=\"br0\">(</span><span class=\"kw1\">let*</span> <span class=\"br0\">(</span><span class=\"br0\">(</span>weights <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span><span class=\"kw1\">d</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>square <span class=\"br0\">(</span>distance<span class=\"sy0\">-</span>to<span class=\"sy0\">-</span>nearest <span class=\"kw1\">d</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> data<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>           <span class=\"br0\">(</span>target<span class=\"sy0\">-</span>weight <span class=\"br0\">(</span><span class=\"sy0\">*</span> <span class=\"br0\">(</span>apply <span class=\"sy0\">+</span> weights<span class=\"br0\">)</span> <span class=\"br0\">(</span>random<span class=\"sy0\">-</span>real<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>      <span class=\"br0\">(</span><span class=\"kw1\">let</span> loop <span class=\"br0\">(</span><span class=\"br0\">(</span>rem data<span class=\"br0\">)</span><br/>                 <span class=\"br0\">(</span>front '<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                 <span class=\"br0\">(</span>weight<span class=\"sy0\">-</span>sum <span class=\"nu0\">0.0</span><span class=\"br0\">)</span><br/>                 <span class=\"br0\">(</span>wgts weights<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>        <span class=\"br0\">(</span><span class=\"kw1\">if</span> <span class=\"br0\">(</span><span class=\"kw1\">or</span> <span class=\"br0\">(</span><span class=\"sy0\">&gt;=</span> weight<span class=\"sy0\">-</span>sum target<span class=\"sy0\">-</span>weight<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw1\">null?</span> <span class=\"br0\">(</span><span class=\"kw1\">cdr</span> rem<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>          <span class=\"br0\">(</span>values <span class=\"br0\">(</span><span class=\"kw1\">car</span> rem<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw1\">append</span> <span class=\"br0\">(</span><span class=\"kw1\">reverse</span> front<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw1\">cdr</span> rem<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>          <span class=\"br0\">(</span>loop <span class=\"br0\">(</span><span class=\"kw1\">cdr</span> rem<span class=\"br0\">)</span><br/>                <span class=\"br0\">(</span><span class=\"kw1\">cons</span> <span class=\"br0\">(</span><span class=\"kw1\">car</span> rem<span class=\"br0\">)</span> front<span class=\"br0\">)</span><br/>                <span class=\"br0\">(</span><span class=\"sy0\">+</span> weight<span class=\"sy0\">-</span>sum <span class=\"br0\">(</span><span class=\"kw1\">car</span> wgts<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                <span class=\"br0\">(</span><span class=\"kw1\">cdr</span> weights<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>  <span class=\"co1\">;</span><br/>  <span class=\"br0\">(</span>let<span class=\"sy0\">-</span>values <span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"br0\">(</span>pt rem<span class=\"br0\">)</span> <span class=\"br0\">(</span>select<span class=\"sy0\">-</span>uniformly data<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>              <span class=\"br0\">(</span><span class=\"kw1\">let</span> loop <span class=\"br0\">(</span><span class=\"br0\">(</span>centres <span class=\"br0\">(</span><span class=\"kw1\">list</span> pt<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                         <span class=\"br0\">(</span>items rem<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                <span class=\"br0\">(</span><span class=\"kw1\">if</span> <span class=\"br0\">(</span><span class=\"sy0\">=</span> <span class=\"br0\">(</span><span class=\"kw1\">length</span> centres<span class=\"br0\">)</span> K<span class=\"br0\">)</span><br/>                  centres<br/>                  <span class=\"br0\">(</span>let<span class=\"sy0\">-</span>values <span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"br0\">(</span>pt rem<span class=\"br0\">)</span> <span class=\"br0\">(</span>select<span class=\"sy0\">-</span>weighted centres items<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                              <span class=\"br0\">(</span>loop <span class=\"br0\">(</span><span class=\"kw1\">cons</span> pt centres<span class=\"br0\">)</span><br/>                                    rem<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;; assign a point into a cluster</span><br/><span class=\"co1\">;; input: a point and a list of cluster centres</span><br/><span class=\"co1\">;; output: index of cluster centre</span><br/><span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>assign<span class=\"sy0\">-</span>cluster pt centres<span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">let*</span> <span class=\"br0\">(</span><span class=\"br0\">(</span>distances <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>centre<span class=\"br0\">)</span> <span class=\"br0\">(</span>euclidean<span class=\"sy0\">-</span>distance centre pt<span class=\"br0\">)</span><span class=\"br0\">)</span> centres<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>         <span class=\"br0\">(</span>smallest <span class=\"br0\">(</span>apply <span class=\"kw1\">min</span> distances<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>    <span class=\"br0\">(</span>list<span class=\"sy0\">-</span>index <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span><span class=\"kw1\">d</span><span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"sy0\">=</span> <span class=\"kw1\">d</span> smallest<span class=\"br0\">)</span><span class=\"br0\">)</span> distances<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;; input</span><br/><span class=\"co1\">;; - num: the number of clusters K</span><br/><span class=\"co1\">;; - data: a list of points in the Cartesian plane</span><br/><span class=\"co1\">;; output</span><br/><span class=\"co1\">;; - list of K centres</span><br/><span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>cluster K data<span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>centroid<span class=\"sy0\">-</span>for<span class=\"sy0\">-</span>cluster i assignments<span class=\"br0\">)</span><br/>    <span class=\"br0\">(</span><span class=\"kw1\">let*</span> <span class=\"br0\">(</span><span class=\"br0\">(</span>cluster <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"kw1\">cadr</span> <span class=\"br0\">(</span>filter <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>a<span class=\"sy0\">-</span><span class=\"kw1\">d</span><span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"sy0\">=</span> <span class=\"br0\">(</span><span class=\"kw1\">car</span> a<span class=\"sy0\">-</span><span class=\"kw1\">d</span><span class=\"br0\">)</span> i<span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>zip assignments data<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>           <span class=\"br0\">(</span>length<span class=\"sy0\">-</span>cluster <span class=\"br0\">(</span><span class=\"kw1\">length</span> cluster<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>      <span class=\"co1\">; compute centroid for cluster</span><br/>      <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>vals<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"sy0\">/</span> <span class=\"br0\">(</span>apply <span class=\"sy0\">+</span> vals<span class=\"br0\">)</span> length<span class=\"sy0\">-</span>cluster<span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>apply zip cluster<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>  <span class=\"co1\">;</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>update<span class=\"sy0\">-</span>centres assignments<span class=\"br0\">)</span><br/>    <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>i<span class=\"br0\">)</span> <span class=\"br0\">(</span>centroid<span class=\"sy0\">-</span>for<span class=\"sy0\">-</span>cluster i assignments<span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>iota K<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>  <span class=\"co1\">;</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">let</span> <span class=\"br0\">(</span><span class=\"br0\">(</span>initial<span class=\"sy0\">-</span>centres <span class=\"br0\">(</span>kmeans<span class=\"sy0\">++</span> K data<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>    <span class=\"br0\">(</span><span class=\"kw1\">let</span> loop <span class=\"br0\">(</span><span class=\"br0\">(</span>centres initial<span class=\"sy0\">-</span>centres<span class=\"br0\">)</span><br/>               <span class=\"br0\">(</span>assignments <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>datum<span class=\"br0\">)</span> <span class=\"br0\">(</span>assign<span class=\"sy0\">-</span>cluster datum initial<span class=\"sy0\">-</span>centres<span class=\"br0\">)</span><span class=\"br0\">)</span> data<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>      <span class=\"br0\">(</span><span class=\"kw1\">let*</span> <span class=\"br0\">(</span><span class=\"br0\">(</span>new<span class=\"sy0\">-</span>centres <span class=\"br0\">(</span>update<span class=\"sy0\">-</span>centres assignments<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>             <span class=\"br0\">(</span>new<span class=\"sy0\">-</span>assignments <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>datum<span class=\"br0\">)</span> <span class=\"br0\">(</span>assign<span class=\"sy0\">-</span>cluster datum new<span class=\"sy0\">-</span>centres<span class=\"br0\">)</span><span class=\"br0\">)</span> data<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>        <span class=\"br0\">(</span><span class=\"kw1\">if</span> <span class=\"br0\">(</span><span class=\"kw1\">equal?</span> assignments new<span class=\"sy0\">-</span>assignments<span class=\"br0\">)</span><br/>          new<span class=\"sy0\">-</span>centres<br/>          <span class=\"br0\">(</span>loop new<span class=\"sy0\">-</span>centres new<span class=\"sy0\">-</span>assignments<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;; using eps output, based on that in C - only works for 2D points</span><br/><span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>save<span class=\"sy0\">-</span>as<span class=\"sy0\">-</span>eps filename data clusters K<span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span>when <span class=\"br0\">(</span>file<span class=\"sy0\">-</span>exists? filename<span class=\"br0\">)</span> <span class=\"br0\">(</span>delete<span class=\"sy0\">-</span>file filename<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">with-output-to-file</span><br/>    filename<br/>    <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span><span class=\"br0\">)</span><br/>      <span class=\"br0\">(</span><span class=\"kw1\">let*</span> <span class=\"br0\">(</span><span class=\"br0\">(</span>W <span class=\"nu0\">400</span><span class=\"br0\">)</span><br/>             <span class=\"br0\">(</span>H <span class=\"nu0\">400</span><span class=\"br0\">)</span><br/>             <span class=\"br0\">(</span>colours <span class=\"br0\">(</span><span class=\"kw1\">make-vector</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> <span class=\"nu0\">3</span> K<span class=\"br0\">)</span> <span class=\"nu0\">0.0</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>             <span class=\"br0\">(</span>max<span class=\"sy0\">-</span>x <span class=\"br0\">(</span>apply <span class=\"kw1\">max</span> <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"kw1\">car</span> data<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>             <span class=\"br0\">(</span>min<span class=\"sy0\">-</span>x <span class=\"br0\">(</span>apply <span class=\"kw1\">min</span> <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"kw1\">car</span> data<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>             <span class=\"br0\">(</span>max<span class=\"sy0\">-</span>y <span class=\"br0\">(</span>apply <span class=\"kw1\">max</span> <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"kw1\">cadr</span> data<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>             <span class=\"br0\">(</span>min<span class=\"sy0\">-</span>y <span class=\"br0\">(</span>apply <span class=\"kw1\">min</span> <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"kw1\">cadr</span> data<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>             <span class=\"br0\">(</span>scale <span class=\"br0\">(</span><span class=\"kw1\">min</span> <span class=\"br0\">(</span><span class=\"sy0\">/</span> W <span class=\"br0\">(</span><span class=\"sy0\">-</span> max<span class=\"sy0\">-</span>x min<span class=\"sy0\">-</span>x<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                         <span class=\"br0\">(</span><span class=\"sy0\">/</span> H <span class=\"br0\">(</span><span class=\"sy0\">-</span> max<span class=\"sy0\">-</span>y min<span class=\"sy0\">-</span>y<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>             <span class=\"br0\">(</span>cx <span class=\"br0\">(</span><span class=\"sy0\">/</span> <span class=\"br0\">(</span><span class=\"sy0\">+</span> max<span class=\"sy0\">-</span>x min<span class=\"sy0\">-</span>x<span class=\"br0\">)</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>             <span class=\"br0\">(</span>cy <span class=\"br0\">(</span><span class=\"sy0\">/</span> <span class=\"br0\">(</span><span class=\"sy0\">+</span> max<span class=\"sy0\">-</span>y min<span class=\"sy0\">-</span>y<span class=\"br0\">)</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/>        <span class=\"co1\">;; set up colours</span><br/>        <span class=\"br0\">(</span><span class=\"kw1\">for-each</span> <br/>          <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>i<span class=\"br0\">)</span> <br/>            <span class=\"br0\">(</span><span class=\"kw1\">vector-set!</span> colours <span class=\"br0\">(</span><span class=\"sy0\">+</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> i <span class=\"nu0\">3</span><span class=\"br0\">)</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>inexact <span class=\"br0\">(</span><span class=\"sy0\">/</span> <span class=\"br0\">(</span><span class=\"kw1\">modulo</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> <span class=\"nu0\">3</span> <span class=\"br0\">(</span><span class=\"sy0\">+</span> i <span class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"nu0\">11</span><span class=\"br0\">)</span> <span class=\"nu0\">11</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>            <span class=\"br0\">(</span><span class=\"kw1\">vector-set!</span> colours <span class=\"br0\">(</span><span class=\"sy0\">+</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> i <span class=\"nu0\">3</span><span class=\"br0\">)</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>inexact <span class=\"br0\">(</span><span class=\"sy0\">/</span> <span class=\"br0\">(</span><span class=\"kw1\">modulo</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> <span class=\"nu0\">7</span> i<span class=\"br0\">)</span> <span class=\"nu0\">11</span><span class=\"br0\">)</span> <span class=\"nu0\">11</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>            <span class=\"br0\">(</span><span class=\"kw1\">vector-set!</span> colours <span class=\"br0\">(</span><span class=\"sy0\">+</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> i <span class=\"nu0\">3</span><span class=\"br0\">)</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>inexact <span class=\"br0\">(</span><span class=\"sy0\">/</span> <span class=\"br0\">(</span><span class=\"kw1\">modulo</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> <span class=\"nu0\">9</span> i<span class=\"br0\">)</span> <span class=\"nu0\">11</span><span class=\"br0\">)</span> <span class=\"nu0\">11</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>          <span class=\"br0\">(</span>iota K<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/>        <span class=\"br0\">(</span><span class=\"kw1\">display</span> <span class=\"co1\">;; display header</span><br/>          <span class=\"br0\">(</span><span class=\"kw1\">string-append</span> <br/>            <span class=\"st0\">\"%!PS-Adobe-3.0<span class=\"es0\">\\n</span>%%BoundingBox: -5 -5 \"</span> <br/>            <span class=\"br0\">(</span>number<span class=\"sy0\">-&gt;</span><span class=\"kw1\">string</span> <span class=\"br0\">(</span><span class=\"sy0\">+</span> <span class=\"nu0\">10</span> W<span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"st0\">\" \"</span> <span class=\"br0\">(</span>number<span class=\"sy0\">-&gt;</span><span class=\"kw1\">string</span> <span class=\"br0\">(</span><span class=\"sy0\">+</span> <span class=\"nu0\">10</span> H<span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"st0\">\"<span class=\"es0\">\\n</span>\"</span><br/>            <span class=\"st0\">\"/l {rlineto} def /m {rmoveto} def<span class=\"es0\">\\n</span>\"</span><br/>            <span class=\"st0\">\"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def<span class=\"es0\">\\n</span>\"</span><br/>            <span class=\"st0\">\"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \"</span><br/>            <span class=\"st0\">\"\tgsave 1 setgray fill grestore gsave 3 setlinewidth\"</span><br/>            <span class=\"st0\">\" 1 setgray stroke grestore 0 setgray stroke }def<span class=\"es0\">\\n</span>\"</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/>        <span class=\"co1\">;; display points</span><br/>        <span class=\"br0\">(</span><span class=\"kw1\">for-each</span> <span class=\"co1\">; top loop runs over the clusters</span><br/>          <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>i<span class=\"br0\">)</span><br/>            <span class=\"br0\">(</span><span class=\"kw1\">display</span><br/>              <span class=\"br0\">(</span><span class=\"kw1\">string-append</span> <span class=\"br0\">(</span>number<span class=\"sy0\">-&gt;</span><span class=\"kw1\">string</span> <span class=\"br0\">(</span><span class=\"kw1\">vector-ref</span> colours <span class=\"br0\">(</span><span class=\"sy0\">*</span> i <span class=\"nu0\">3</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                             <span class=\"st0\">\" \"</span><br/>                             <span class=\"br0\">(</span>number<span class=\"sy0\">-&gt;</span><span class=\"kw1\">string</span> <span class=\"br0\">(</span><span class=\"kw1\">vector-ref</span> colours <span class=\"br0\">(</span><span class=\"sy0\">+</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> i <span class=\"nu0\">3</span><span class=\"br0\">)</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                             <span class=\"st0\">\" \"</span><br/>                             <span class=\"br0\">(</span>number<span class=\"sy0\">-&gt;</span><span class=\"kw1\">string</span> <span class=\"br0\">(</span><span class=\"kw1\">vector-ref</span> colours <span class=\"br0\">(</span><span class=\"sy0\">+</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> i <span class=\"nu0\">3</span><span class=\"br0\">)</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                             <span class=\"st0\">\" setrgbcolor<span class=\"es0\">\\n</span>\"</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>            <span class=\"br0\">(</span><span class=\"kw1\">for-each</span> <span class=\"co1\">;loop over points in cluster</span><br/>              <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>pt<span class=\"br0\">)</span><br/>                <span class=\"br0\">(</span>when <span class=\"br0\">(</span><span class=\"sy0\">=</span> i <span class=\"br0\">(</span>assign<span class=\"sy0\">-</span>cluster pt clusters<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                  <span class=\"br0\">(</span><span class=\"kw1\">display</span><br/>                    <span class=\"br0\">(</span><span class=\"kw1\">string-append</span> <span class=\"br0\">(</span>number<span class=\"sy0\">-&gt;</span><span class=\"kw1\">string</span> <span class=\"br0\">(</span><span class=\"sy0\">+</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> <span class=\"br0\">(</span><span class=\"sy0\">-</span> <span class=\"br0\">(</span><span class=\"kw1\">car</span> pt<span class=\"br0\">)</span> cx<span class=\"br0\">)</span> scale<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"sy0\">/</span> W <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                                   <span class=\"st0\">\" \"</span><br/>                                   <span class=\"br0\">(</span>number<span class=\"sy0\">-&gt;</span><span class=\"kw1\">string</span> <span class=\"br0\">(</span><span class=\"sy0\">+</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> <span class=\"br0\">(</span><span class=\"sy0\">-</span> <span class=\"br0\">(</span><span class=\"kw1\">cadr</span> pt<span class=\"br0\">)</span> cy<span class=\"br0\">)</span> scale<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"sy0\">/</span> H <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                                   <span class=\"st0\">\" c<span class=\"es0\">\\n</span>\"</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>              data<span class=\"br0\">)</span><br/>            <span class=\"br0\">(</span><span class=\"kw1\">let</span> <span class=\"br0\">(</span><span class=\"br0\">(</span>center <span class=\"br0\">(</span><span class=\"kw1\">list-ref</span> clusters i<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"co1\">; display cluster centre</span><br/>              <span class=\"br0\">(</span><span class=\"kw1\">display</span> <br/>                <span class=\"br0\">(</span><span class=\"kw1\">string-append</span> <span class=\"st0\">\"<span class=\"es0\">\\n</span>0 setgray \"</span><br/>                               <span class=\"br0\">(</span>number<span class=\"sy0\">-&gt;</span><span class=\"kw1\">string</span> <span class=\"br0\">(</span><span class=\"sy0\">+</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> <span class=\"br0\">(</span><span class=\"sy0\">-</span> <span class=\"br0\">(</span><span class=\"kw1\">car</span> center<span class=\"br0\">)</span> cx<span class=\"br0\">)</span> scale<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"sy0\">/</span> W <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                               <span class=\"st0\">\" \"</span><br/>                               <span class=\"br0\">(</span>number<span class=\"sy0\">-&gt;</span><span class=\"kw1\">string</span> <span class=\"br0\">(</span><span class=\"sy0\">+</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> <span class=\"br0\">(</span><span class=\"sy0\">-</span> <span class=\"br0\">(</span><span class=\"kw1\">cadr</span> center<span class=\"br0\">)</span> cy<span class=\"br0\">)</span> scale<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"sy0\">/</span> H <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                               <span class=\"st0\">\" s<span class=\"es0\">\\n</span>\"</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>          <span class=\"br0\">(</span>iota K<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>        <span class=\"br0\">(</span><span class=\"kw1\">display</span> <span class=\"st0\">\"<span class=\"es0\">\\n</span>%%EOF\"</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;; extra credit 1: creates a list of n random points in n-D unit square</span><br/><span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>make<span class=\"sy0\">-</span>data num<span class=\"sy0\">-</span>points num<span class=\"sy0\">-</span>dimensions<span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span>random<span class=\"sy0\">-</span>source<span class=\"sy0\">-</span>randomize<span class=\"sy0\">!</span> default<span class=\"sy0\">-</span>random<span class=\"sy0\">-</span>source<span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>i<span class=\"br0\">)</span> <span class=\"br0\">(</span>list<span class=\"sy0\">-</span>tabulate num<span class=\"sy0\">-</span>dimensions <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>i<span class=\"br0\">)</span> <span class=\"br0\">(</span>random<span class=\"sy0\">-</span>real<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>iota num<span class=\"sy0\">-</span>points<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;; extra credit 2, uses eps visualisation to display result</span><br/><span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>tester<span class=\"sy0\">-</span><span class=\"nu0\">1</span> num<span class=\"sy0\">-</span>points K<span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">let</span> <span class=\"br0\">(</span><span class=\"br0\">(</span>data <span class=\"br0\">(</span>make<span class=\"sy0\">-</span>data num<span class=\"sy0\">-</span>points <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>    <span class=\"br0\">(</span>save<span class=\"sy0\">-</span>as<span class=\"sy0\">-</span>eps <span class=\"st0\">\"clusters-1.eps\"</span> data <span class=\"br0\">(</span>cluster K data<span class=\"br0\">)</span> K<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;; extra credit 3: uses radians instead to make data</span><br/><span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>tester<span class=\"sy0\">-</span><span class=\"nu0\">2</span> num<span class=\"sy0\">-</span>points K radius<span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span>random<span class=\"sy0\">-</span>source<span class=\"sy0\">-</span>randomize<span class=\"sy0\">!</span> default<span class=\"sy0\">-</span>random<span class=\"sy0\">-</span>source<span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">let</span> <span class=\"br0\">(</span><span class=\"br0\">(</span>data <span class=\"br0\">(</span><span class=\"kw1\">map</span> <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span>i<span class=\"br0\">)</span> <br/>                     <span class=\"br0\">(</span><span class=\"kw1\">let</span> <span class=\"br0\">(</span><span class=\"br0\">(</span>ang <span class=\"br0\">(</span><span class=\"sy0\">*</span> <span class=\"br0\">(</span>random<span class=\"sy0\">-</span>real<span class=\"br0\">)</span> <span class=\"nu0\">2</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> <span class=\"nu0\">4</span> <span class=\"br0\">(</span><span class=\"kw1\">atan</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                           <span class=\"br0\">(</span>rad <span class=\"br0\">(</span><span class=\"sy0\">*</span> radius <span class=\"br0\">(</span>random<span class=\"sy0\">-</span>real<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                       <span class=\"br0\">(</span><span class=\"kw1\">list</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> rad <span class=\"br0\">(</span><span class=\"kw1\">cos</span> ang<span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span> rad <span class=\"br0\">(</span><span class=\"kw1\">sin</span> ang<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                   <span class=\"br0\">(</span>iota num<span class=\"sy0\">-</span>points<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>    <span class=\"co1\">;; extra credit 2, uses eps visualisation to display result</span><br/>    <span class=\"br0\">(</span>save<span class=\"sy0\">-</span>as<span class=\"sy0\">-</span>eps <span class=\"st0\">\"clusters-2.eps\"</span> data <span class=\"br0\">(</span>cluster K data<span class=\"br0\">)</span> K<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;; extra credit 4: arbitrary dimensions - already handled, as all points are lists</span><br/><span class=\"br0\">(</span><span class=\"kw1\">define</span> <span class=\"br0\">(</span>tester<span class=\"sy0\">-</span><span class=\"nu0\">3</span> num<span class=\"sy0\">-</span>points K num<span class=\"sy0\">-</span>dimensions<span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">display</span> <span class=\"st0\">\"Results:<span class=\"es0\">\\n</span>\"</span><span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">display</span> <span class=\"br0\">(</span>cluster K <span class=\"br0\">(</span>make<span class=\"sy0\">-</span>data num<span class=\"sy0\">-</span>points num<span class=\"sy0\">-</span>dimensions<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <br/>  <span class=\"br0\">(</span><span class=\"kw1\">newline</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>tester<span class=\"sy0\">-</span><span class=\"nu0\">1</span> <span class=\"nu0\">30000</span> <span class=\"nu0\">6</span><span class=\"br0\">)</span><br/><span class=\"br0\">(</span>tester<span class=\"sy0\">-</span><span class=\"nu0\">2</span> <span class=\"nu0\">30000</span> <span class=\"nu0\">6</span> <span class=\"nu0\">10</span><span class=\"br0\">)</span><br/><span class=\"br0\">(</span>tester<span class=\"sy0\">-</span><span class=\"nu0\">3</span> <span class=\"nu0\">30000</span> <span class=\"nu0\">6</span> <span class=\"nu0\">5</span><span class=\"br0\">)</span><br/>\u00a0</pre>"}, {"lang": "SequenceL", "loc": 139, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>import &lt;Utilities/Sequence.sl&gt;;<br/>import &lt;Utilities/Random.sl&gt;;<br/>import &lt;Utilities/Math.sl&gt;;<br/>import &lt;Utilities/Conversion.sl&gt;;<br/>\u00a0<br/>Point\u00a0::= (x\u00a0: float, y\u00a0: float);<br/>Pair&lt;T1, T2&gt;\u00a0::= (first\u00a0: T1, second\u00a0: T2);<br/>\u00a0<br/>W\u00a0:= 400;<br/>H\u00a0:= 400;<br/>\u00a0<br/>// ------------ Utilities --------------<br/>distance(a, b)\u00a0:= (a.x-b.x)^2 + (a.y-b.y)^2;<br/>\u00a0<br/>nearestDistance(point, centers(1))\u00a0:=<br/>    nearestCenterHelper(point, centers, 2, distance(point, centers[1]), 1).second;<br/>\u00a0<br/>nearestCenter(point, centers(1))\u00a0:=<br/>    nearestCenterHelper(point, centers, 2, distance(point, centers[1]), 1).first;<br/>\u00a0<br/>nearestCenterHelper(point, centers(1), counter, minDistance, minIndex)\u00a0:=<br/>    let<br/>        d\u00a0:= distance(point, centers[counter]);<br/>    in<br/>    (first\u00a0: minIndex, second\u00a0: minDistance) when counter &gt; size(centers) else<br/>    nearestCenterHelper(point, centers, counter + 1, d, counter) when minDistance &gt; d else<br/>    nearestCenterHelper(point, centers, counter + 1, minDistance, minIndex);<br/>\u00a0<br/>// ------------ KPP --------------<br/>kpp(points(1), k, RG)\u00a0:=<br/>    let<br/>        randomValues\u00a0:= getRandomSequence(RG, k).Value;<br/>        centers\u00a0:= initialCenters(points, k, randomValues / (RG.RandomMax - 1.0),<br/>                    [points[randomValues[1] mod size(points)]]);<br/>    in<br/>        nearestCenter(points, centers);<br/>\u00a0<br/>initialCenters(points(1), k, randoms(1), centers(1))\u00a0:=<br/>    let<br/>        distances\u00a0:= nearestDistance(points, centers);<br/>        randomSum\u00a0:= randoms[size(centers) + 1] * sum(distances);<br/>        newCenter\u00a0:= points[findNewCenter(randomSum, distances, 1)];<br/>    in<br/>        centers when size(centers) = k else<br/>        initialCenters(points, k, randoms, centers++[newCenter]);<br/>\u00a0<br/>findNewCenter(s, distances(1), counter)\u00a0:=<br/>    let<br/>        new_s\u00a0:= s - distances[counter];<br/>    in<br/>    counter when new_s &lt;= 0 else<br/>    findNewCenter(new_s, distances, counter + 1);<br/>\u00a0<br/>// ------------ K Means --------------<br/>kMeans(points(1), groups(1), k)\u00a0:=<br/>    let<br/>        newCenters\u00a0:= clusterAverage(points, groups, k);<br/>        newGroups\u00a0:= nearestCenter(points, newCenters);<br/>        threshold\u00a0:= size(points)/1024;<br/>        // Calculate the number of changes between iterations<br/>        changes[i]\u00a0:= 1 when groups[i] /= newGroups[i] else 0;<br/>    in<br/>        (first\u00a0: newGroups, second\u00a0: newCenters) when sum(changes) &lt; threshold else<br/>        kMeans(points, newGroups, k);<br/>\u00a0<br/>clusterAverage(points(1), groups(1), k)\u00a0:=<br/>        clusterAverageHelper(points, groups, 1, duplicate((x:0.0, y:0.0), k), duplicate(0, k));<br/>\u00a0<br/>clusterAverageHelper(points(1), groups(1), counter, averages(1), sizes(1))\u00a0:=<br/>    let<br/>        group\u00a0:= groups[counter];<br/>        result[i]\u00a0:= (x\u00a0: averages[i].x / sizes[i], y\u00a0: averages[i].y / sizes[i]);<br/>    in<br/>    result when counter &gt; size(points) else<br/>    clusterAverageHelper(points, groups, counter + 1,<br/>        setElementAt(averages, group,<br/>                          (x\u00a0: averages[group].x + points[counter].x,<br/>                           y\u00a0: averages[group].y + points[counter].y)),<br/>        setElementAt(sizes, group, sizes[group] + 1));<br/>\u00a0<br/>// ------------ Generate Points --------------<br/>gen2DPoints(count, radius, RG)\u00a0:=<br/>    let<br/>        randA\u00a0:= getRandomSequence(RG, count);<br/>        randR\u00a0:= getRandomSequence(randA.Generator, count);<br/>        angles\u00a0:= 2*pi*(randA.Value / (RG.RandomMax - 1.0));<br/>        radiuses\u00a0:= radius * (randR.Value / (RG.RandomMax - 1.0));<br/>        points[i]\u00a0:= (x: radiuses[i] * cos(angles[i]), y\u00a0: radiuses[i] * sin(angles[i]));<br/>    in<br/>        (first\u00a0: points, second\u00a0: randR.Generator);<br/>\u00a0<br/>// ------------ Visualize --------------<br/>printEPS(points(1),groups(1),centers(1),k,maxVal)\u00a0:=<br/>    let<br/>          scale\u00a0:= min(W / (maxVal * 2), H / (maxVal * 2));<br/>          printedGroups\u00a0:= printGroup(points, groups, centers, k, 0.0, scale, 1 ... k);<br/>    in<br/>        \"%!-PS-Adobe-3.0\\n%%BoundingBox: -5 -5 \" ++ toString(W + 10) ++ \" \" ++<br/>        toString(H + 10) ++<br/>        \"\\n/l {rlineto} def /m {rmoveto} def\\n\" ++<br/>        \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\" ++<br/>        \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \" ++<br/>        \"   gsave 1 setgray fill grestore gsave 3 setlinewidth\" ++<br/>        \" 1 setgray stroke grestore 0 setgray stroke }def\\n\" ++<br/>        join(printedGroups) ++<br/>        \"\\n%%EOF\";<br/>\u00a0<br/>printGroup(points(1), groups(1), centers(1), k, maxVal, scale, group)\u00a0:=<br/>    let<br/>        printedPoints[i]\u00a0:=<br/>            toString((points[i].x - maxVal) * scale + W/2) ++ \" \" ++<br/>            toString((points[i].y - maxVal) * scale + H/2) ++ \" c\\n\"<br/>                when groups[i] = group;<br/>\u00a0<br/>        colors\u00a0:= toString((3 * group mod k) / (k * 1.0)) ++ \" \" ++<br/>                  toString((7 * (group - 1) mod k) / (k * 1.0)) ++ \" \" ++<br/>                  toString((9 * (group - 1) mod k) / (k * 1.0)) ++<br/>                  \" setrgbcolor\\n\";<br/>\u00a0<br/>        printedCenters\u00a0:= \"\\n0 setgray \" ++<br/>                   toString((centers[group].x - maxVal) * scale + W/2) ++ \" \" ++<br/>                   toString((centers[group].y - maxVal) * scale + H/2) ++ \" s\\n\";<br/>    in<br/>        colors ++ join(printedPoints) ++ printedCenters;<br/>\u00a0<br/>// Take number of points, K and seed for random data as command line inputs<br/>main(args(2))\u00a0:= <br/>    let<br/>        n\u00a0:= stringToInt(args[1]) when size(args) &gt;= 1 else 1000;<br/>        k\u00a0:= stringToInt(args[2]) when size(args) &gt;= 2 else 7;<br/>        seed\u00a0:= stringToInt(args[3]) when size(args) &gt;= 3 else 13;<br/>\u00a0<br/>        points\u00a0:= gen2DPoints(n, 10.0, seedRandom(seed));<br/>        initialGroups\u00a0:= kpp(points.first, k, points.second);<br/>        result\u00a0:= kMeans(points.first, initialGroups, k);<br/>    in<br/>        printEPS(points.first, result.first, result.second,k,10.0);<br/>\u00a0</pre>"}, {"lang": "Tcl", "loc": 103, "block": "<pre class=\"tcl highlighted_source\"><span class=\"kw2\">package</span> require Tcl <span class=\"nu0\">8.5</span><br/><span class=\"kw2\">package</span> require math::<span class=\"me1\">constants</span><br/>math::<span class=\"me1\">constants</span>::<span class=\"me1\">constants</span> pi<br/><span class=\"kw1\">proc</span> tcl::<span class=\"me1\">mathfunc</span>::<span class=\"me1\">randf</span> m <span class=\"br0\">{</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span><span class=\"re0\">$m</span> <span class=\"sy0\">*</span> rand<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">}</span><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw1\">proc</span> genXY <span class=\"br0\">{</span>count radius<span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>    <span class=\"kw1\">global</span> pi<br/>    <span class=\"kw1\">for</span> <span class=\"br0\">{</span><span class=\"kw1\">set</span> i <span class=\"nu0\">0</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><span class=\"re0\">$i</span> <span class=\"sy0\">&lt;</span> <span class=\"re0\">$count</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><span class=\"kw2\">incr</span> i<span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t<span class=\"kw1\">set</span> ang <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span>randf<span class=\"br0\">(</span><span class=\"nu0\">2</span> <span class=\"sy0\">*</span> <span class=\"re0\">$pi</span><span class=\"br0\">)</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/>\t<span class=\"kw1\">set</span> r <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span>randf<span class=\"br0\">(</span><span class=\"re0\">$radius</span><span class=\"br0\">)</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/>\t<span class=\"kw2\">lappend</span> pt <span class=\"br0\">[</span><span class=\"kw2\">list</span> <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span><span class=\"re0\">$r</span><span class=\"sy0\">*</span>cos<span class=\"br0\">(</span><span class=\"re0\">$ang</span><span class=\"br0\">)</span><span class=\"br0\">}</span><span class=\"br0\">]</span> <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span><span class=\"re0\">$r</span><span class=\"sy0\">*</span>sin<span class=\"br0\">(</span><span class=\"re0\">$ang</span><span class=\"br0\">)</span><span class=\"br0\">}</span><span class=\"br0\">]</span> -<span class=\"nu0\">1</span><span class=\"br0\">]</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"kw1\">return</span> <span class=\"re0\">$pt</span><br/><span class=\"br0\">}</span><br/><span class=\"kw1\">proc</span> dist2 <span class=\"br0\">{</span>a b<span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>    lassign <span class=\"re0\">$a</span> ax ay<br/>    lassign <span class=\"re0\">$b</span> bx by<br/>    <span class=\"kw1\">return</span> <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span><span class=\"br0\">(</span><span class=\"re0\">$ax</span>-<span class=\"re0\">$bx</span><span class=\"br0\">)</span><span class=\"sy0\">**</span><span class=\"nu0\">2</span> + <span class=\"br0\">(</span><span class=\"re0\">$ay</span>-<span class=\"re0\">$by</span><span class=\"br0\">)</span><span class=\"sy0\">**</span><span class=\"nu0\">2</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw1\">proc</span> nearest <span class=\"br0\">{</span>pt cent <span class=\"br0\">{</span>d2var <span class=\"st0\">\"\"</span><span class=\"br0\">}</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>    <span class=\"kw1\">set</span> minD 1e30<br/>    <span class=\"kw1\">set</span> minI <span class=\"br0\">[</span><span class=\"kw2\">lindex</span> <span class=\"re0\">$pt</span> <span class=\"nu0\">2</span><span class=\"br0\">]</span><br/>    <span class=\"kw1\">set</span> i -<span class=\"nu0\">1</span><br/>    <span class=\"kw1\">foreach</span> c <span class=\"re0\">$cent</span> <span class=\"br0\">{</span><br/>\t<span class=\"kw2\">incr</span> i<br/>\t<span class=\"kw1\">set</span> d <span class=\"br0\">[</span>dist2 <span class=\"re0\">$c</span> <span class=\"re0\">$pt</span><span class=\"br0\">]</span><br/>\t<span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"re0\">$minD</span> <span class=\"sy0\">&gt;</span> <span class=\"re0\">$d</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t    <span class=\"kw1\">set</span> minD <span class=\"re0\">$d</span><br/>\t    <span class=\"kw1\">set</span> minI <span class=\"re0\">$i</span><br/>\t<span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"re0\">$d2var</span> ne <span class=\"st0\">\"\"</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t<span class=\"kw1\">upvar</span> <span class=\"nu0\">1</span> <span class=\"re0\">$d2var</span> d2<br/>\t<span class=\"kw1\">set</span> d2 <span class=\"re0\">$minD</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"kw1\">return</span> <span class=\"re0\">$minI</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw1\">proc</span> kpp <span class=\"br0\">{</span>ptsVar centVar numClusters<span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>    <span class=\"kw1\">upvar</span> <span class=\"nu0\">1</span> <span class=\"re0\">$ptsVar</span> pts <span class=\"re0\">$centVar</span> cent<br/>    <span class=\"kw1\">set</span> idx <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span>int<span class=\"br0\">(</span><span class=\"br0\">[</span><span class=\"kw2\">llength</span> <span class=\"re0\">$pts</span><span class=\"br0\">]</span> <span class=\"sy0\">*</span> rand<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/>    <span class=\"kw1\">set</span> cent <span class=\"br0\">[</span><span class=\"kw2\">list</span> <span class=\"br0\">[</span><span class=\"kw2\">lindex</span> <span class=\"re0\">$pts</span> <span class=\"re0\">$idx</span><span class=\"br0\">]</span><span class=\"br0\">]</span><br/>    <span class=\"kw1\">for</span> <span class=\"br0\">{</span><span class=\"kw1\">set</span> nCent <span class=\"nu0\">1</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><span class=\"re0\">$nCent</span> <span class=\"sy0\">&lt;</span> <span class=\"re0\">$numClusters</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><span class=\"kw2\">incr</span> nCent<span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t<span class=\"kw1\">set</span> sum <span class=\"nu0\">0</span><br/>\t<span class=\"kw1\">set</span> d <span class=\"br0\">{</span><span class=\"br0\">}</span><br/>\t<span class=\"kw1\">foreach</span> p <span class=\"re0\">$pts</span> <span class=\"br0\">{</span><br/>\t    nearest <span class=\"re0\">$p</span> <span class=\"re0\">$cent</span> dd<br/>\t    <span class=\"kw1\">set</span> sum <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span><span class=\"re0\">$sum</span> + <span class=\"re0\">$dd</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/>\t    <span class=\"kw2\">lappend</span> d <span class=\"re0\">$dd</span><br/>\t<span class=\"br0\">}</span><br/>\t<span class=\"kw1\">set</span> sum <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span>randf<span class=\"br0\">(</span><span class=\"re0\">$sum</span><span class=\"br0\">)</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/>\t<span class=\"kw1\">foreach</span> p <span class=\"re0\">$pts</span> dj <span class=\"re0\">$d</span> <span class=\"br0\">{</span><br/>\t    <span class=\"kw1\">set</span> sum <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span><span class=\"re0\">$sum</span> - <span class=\"re0\">$dj</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/>\t    <span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"re0\">$sum</span> <span class=\"sy0\">&lt;</span>= <span class=\"nu0\">0</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t\t<span class=\"kw2\">lappend</span> cent <span class=\"re0\">$p</span><br/>\t\t<span class=\"kw1\">break</span><br/>\t    <span class=\"br0\">}</span><br/>\t<span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"kw1\">set</span> i -<span class=\"nu0\">1</span><br/>    <span class=\"kw1\">foreach</span> p <span class=\"re0\">$pts</span> <span class=\"br0\">{</span><br/>\t<span class=\"kw2\">lset</span> pts <span class=\"br0\">[</span><span class=\"kw2\">incr</span> i<span class=\"br0\">]</span> <span class=\"nu0\">2</span> <span class=\"br0\">[</span>nearest <span class=\"re0\">$p</span> <span class=\"re0\">$cent</span><span class=\"br0\">]</span><br/>    <span class=\"br0\">}</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw1\">proc</span> lloyd <span class=\"br0\">{</span>ptsVar numClusters<span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>    <span class=\"kw1\">upvar</span> <span class=\"nu0\">1</span> <span class=\"re0\">$ptsVar</span> pts<br/>    kpp pts cent <span class=\"re0\">$numClusters</span><br/>    <span class=\"kw1\">while</span> <span class=\"nu0\">1</span> <span class=\"br0\">{</span><br/>\t<span class=\"co1\"># Find centroids for round</span><br/>\t<span class=\"kw1\">set</span> groupCounts <span class=\"br0\">[</span>lrepeat <span class=\"br0\">[</span><span class=\"kw2\">llength</span> <span class=\"re0\">$cent</span><span class=\"br0\">]</span> <span class=\"nu0\">0</span><span class=\"br0\">]</span><br/>\t<span class=\"kw1\">foreach</span> p <span class=\"re0\">$pts</span> <span class=\"br0\">{</span><br/>\t    lassign <span class=\"re0\">$p</span> cx cy group<br/>\t    <span class=\"kw2\">lset</span> groupCounts <span class=\"re0\">$group</span> <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span><span class=\"br0\">[</span><span class=\"kw2\">lindex</span> <span class=\"re0\">$groupCounts</span> <span class=\"re0\">$group</span><span class=\"br0\">]</span> + <span class=\"nu0\">1</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/>\t    <span class=\"kw2\">lset</span> cent <span class=\"re0\">$group</span> <span class=\"nu0\">0</span> <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span><span class=\"br0\">[</span><span class=\"kw2\">lindex</span> <span class=\"re0\">$cent</span> <span class=\"re0\">$group</span> <span class=\"nu0\">0</span><span class=\"br0\">]</span> + <span class=\"re0\">$cx</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/>\t    <span class=\"kw2\">lset</span> cent <span class=\"re0\">$group</span> <span class=\"nu0\">1</span> <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span><span class=\"br0\">[</span><span class=\"kw2\">lindex</span> <span class=\"re0\">$cent</span> <span class=\"re0\">$group</span> <span class=\"nu0\">1</span><span class=\"br0\">]</span> + <span class=\"re0\">$cy</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/>\t<span class=\"br0\">}</span><br/>\t<span class=\"kw1\">set</span> i -<span class=\"nu0\">1</span><br/>\t<span class=\"kw1\">foreach</span> groupn <span class=\"re0\">$groupCounts</span> <span class=\"br0\">{</span><br/>\t    <span class=\"kw2\">incr</span> i<br/>\t    <span class=\"kw2\">lset</span> cent <span class=\"re0\">$i</span> <span class=\"nu0\">0</span> <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span><span class=\"br0\">[</span><span class=\"kw2\">lindex</span> <span class=\"re0\">$cent</span> <span class=\"re0\">$i</span> <span class=\"nu0\">0</span><span class=\"br0\">]</span> / <span class=\"re0\">$groupn</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/>\t    <span class=\"kw2\">lset</span> cent <span class=\"re0\">$i</span> <span class=\"nu0\">1</span> <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span><span class=\"br0\">[</span><span class=\"kw2\">lindex</span> <span class=\"re0\">$cent</span> <span class=\"re0\">$i</span> <span class=\"nu0\">1</span><span class=\"br0\">]</span> / <span class=\"re0\">$groupn</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/>\t<span class=\"br0\">}</span><br/>\u00a0<br/>\t<span class=\"kw1\">set</span> changed <span class=\"nu0\">0</span><br/>\t<span class=\"kw1\">set</span> i -<span class=\"nu0\">1</span><br/>\t<span class=\"kw1\">foreach</span> p <span class=\"re0\">$pts</span> <span class=\"br0\">{</span><br/>\t    <span class=\"kw2\">incr</span> i<br/>\t    <span class=\"kw1\">set</span> minI <span class=\"br0\">[</span>nearest <span class=\"re0\">$p</span> <span class=\"re0\">$cent</span><span class=\"br0\">]</span><br/>\t    <span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"re0\">$minI</span> <span class=\"sy0\">!</span>= <span class=\"br0\">[</span><span class=\"kw2\">lindex</span> <span class=\"re0\">$p</span> <span class=\"nu0\">2</span><span class=\"br0\">]</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t\t<span class=\"kw2\">incr</span> changed<br/>\t\t<span class=\"kw2\">lset</span> pts <span class=\"re0\">$i</span> <span class=\"nu0\">2</span> <span class=\"re0\">$minI</span><br/>\t    <span class=\"br0\">}</span><br/>\t<span class=\"br0\">}</span><br/>\t<span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"re0\">$changed</span> <span class=\"sy0\">&lt;</span> <span class=\"br0\">(</span><span class=\"br0\">[</span><span class=\"kw2\">llength</span> <span class=\"re0\">$pts</span><span class=\"br0\">]</span> <span class=\"sy0\">&gt;&gt;</span> <span class=\"nu0\">10</span><span class=\"br0\">)</span><span class=\"br0\">}</span> <span class=\"kw1\">break</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"kw1\">set</span> i -<span class=\"nu0\">1</span><br/>    <span class=\"kw1\">foreach</span> c <span class=\"re0\">$cent</span> <span class=\"br0\">{</span><br/>\t<span class=\"kw2\">lset</span> cent <span class=\"br0\">[</span><span class=\"kw2\">incr</span> i<span class=\"br0\">]</span> <span class=\"nu0\">2</span> <span class=\"re0\">$i</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"kw1\">return</span> <span class=\"re0\">$cent</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "XPL0", "loc": 67, "block": "<pre class=\"text highlighted_source\">include c:\\cxpl\\codes;  \\intrinsic 'code' declarations<br/>\u00a0<br/>def     N = 30000;              \\number of points<br/>def     K = 6;                  \\number of clusters<br/>int     Px(N), Py(N), Pc(N),    \\coordinates of points and their cluster<br/>        Cx(K), Cy(K);           \\coordinates of centroid of cluster<br/>\u00a0<br/>\u00a0<br/>func Centroid;  \\Find new centroids of points grouped with current centroids<br/>int  Change, Cx0(K), Cy0(K), C, Count, I;<br/>[Change:= false;<br/>for C:= 0 to K-1 do                       \\for each centroid...<br/>        [Cx0(C):= Cx(C);  Cy0(C):= Cy(C); \\save current centroid<br/>        Cx(C):= 0;  Cx(C):= 0;  Count:= 0;\\find new centroid<br/>        for I:= 0 to N-1 do               \\for all points<br/>            if Pc(I) = C then             \\ grouped with current centroid...<br/>                [Cx(C):= Cx(C) + Px(I);<br/>                 Cy(C):= Cy(C) + Py(I);<br/>                 Count:= Count+1;<br/>                ];<br/>        Cx(C):= Cx(C)/Count;  Cy(C):= Cy(C)/Count;<br/>        if Cx(C)#Cx0(C) or Cy(C)#Cy0(C) then Change:= true;<br/>        ];<br/>return Change;<br/>];<br/>\u00a0<br/>\u00a0<br/>proc Voronoi;                   \\Group points with their nearest centroid<br/>int  D2, MinD2, I, C;           \\distance squared, minimum distance squared<br/>[for I:= 0 to N-1 do            \\for each point...<br/>        [MinD2:= -1&gt;&gt;1;         \\find closest centroid<br/>        for C:= 0 to K-1 do<br/>                [D2:= sq(Px(I)-Cx(C)) + sq(Py(I)-Cy(C));<br/>                if D2 &lt; MinD2 then<br/>                        [MinD2:= D2;  Pc(I):= C];  \\update closest centroid<br/>                ];<br/>        ];<br/>];<br/>\u00a0<br/>\u00a0<br/>proc KMeans;                    \\Group points into K clusters<br/>int  Change, I;<br/>repeat  Voronoi;<br/>        Change:= Centroid;<br/>        SetVid($101);           \\show result on 640x480x8 screen<br/>        for I:= 0 to N-1 do Point(Px(I), Py(I), Pc(I)+1);<br/>        for I:= 0 to K-1 do Point(Cx(I), Cy(I), \\bright white\\ $F);<br/>until   Change = false;<br/>\u00a0<br/>\u00a0<br/>proc Random(X, Y);              \\Return random X,Y biased for polar coordinates<br/>int  X, Y;<br/>real A, D;<br/>[D:= float(Ran(240));                   \\distance: 0..239<br/>A:= float(Ran(314159*2)) / 10000.0;     \\angle:    0..2pi<br/>X(0):= fix(D*Cos(A)) + 320;             \\rectangular coords centered on screen<br/>Y(0):= fix(D*Sin(A)) + 240;<br/>];<br/>\u00a0<br/>\u00a0<br/>int  I;<br/>[for I:= 0 to N-1 do Random(@Px(I), @Py(I));    \\random set of points<br/> for I:= 0 to K-1 do Random(@Cx(I), @Cy(I));    \\random set of cluster centroids<br/>KMeans;<br/>I:= ChIn(1);                    \\wait for keystroke<br/>SetVid($03);                    \\restore normal text screen<br/>]</pre>"}]}