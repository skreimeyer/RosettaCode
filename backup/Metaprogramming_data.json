{"task": "Metaprogramming", "blocks": [{"lang": "ALGOL 68", "loc": 131, "block": "<pre class=\"algol68 highlighted_source\"><span class=\"coMULTI\"># This example uses ALGOL 68 user defined operators to add a COBOL-style     #</span><br/><span class=\"coMULTI\"># \"INSPECT statement\" to ALGOL 68                                            #</span><br/><span class=\"coMULTI\">#                                                                            #</span><br/><span class=\"coMULTI\"># The (partial) syntax of the COBOL INSPECT is:                              #</span><br/><span class=\"coMULTI\">#    INSPECT string-variable REPLACING ALL     string BY string              #</span><br/><span class=\"coMULTI\"># or INSPECT string-variable REPLACING LEADING string BY string              #</span><br/><span class=\"coMULTI\"># or INSPECT string-variable REPLACING FIRST   string BY string              #</span><br/><span class=\"coMULTI\">#                                                                            #</span><br/><span class=\"coMULTI\"># Because \"BY\" is a reserved bold word in ALGOL 68, we use \"WITH\" instead    #</span><br/><span class=\"coMULTI\">#                                                                            #</span><br/><span class=\"coMULTI\"># We define unary  operators INSPECT, ALL, LEADING and FIRST                 #</span><br/><span class=\"coMULTI\">#       and binary operators REPLACING and WITH                              #</span><br/><span class=\"coMULTI\"># We choose the priorities of REPLACING and WITH so that parenthesis is not  #</span><br/><span class=\"coMULTI\"># needed to ensure the correct interpretation of the \"statement\"             #</span><br/><span class=\"coMULTI\">#                                                                            #</span><br/><span class=\"coMULTI\"># We also provide a unary DISPLAY operator for a partial COBOL DISPLAY       #</span><br/><span class=\"coMULTI\"># statement                                                                  #</span><br/>\u00a0<br/><span class=\"coMULTI\"># INSPECTEE is returned by the INSPECT unary operator                        #</span><br/><span class=\"kw4\">MODE</span> INSPECTEE   <span class=\"sy1\">=</span> <span class=\"kw6\">STRUCT</span><span class=\"br0\">(</span> <span class=\"kw4\">REF</span> <span class=\"kw3\">STRING</span> item<span class=\"sy1\">,</span> <span class=\"kw3\">INT</span> option <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>\u00a0<br/><span class=\"coMULTI\"># INSPECTTOREPLACE is returned by the binary REPLACING operator              #</span><br/><span class=\"kw4\">MODE</span> INSPECTTOREPLACE<br/>                 <span class=\"sy1\">=</span> <span class=\"kw6\">STRUCT</span><span class=\"br0\">(</span> <span class=\"kw4\">REF</span> <span class=\"kw3\">STRING</span> item<span class=\"sy1\">,</span> <span class=\"kw3\">INT</span> option<span class=\"sy1\">,</span> <span class=\"kw3\">STRING</span> to replace <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/><span class=\"coMULTI\"># REPLACEMENT is returned by the unary ALL, LEADING and FIRST operators      #</span><br/><span class=\"kw4\">MODE</span> REPLACEMENT <span class=\"sy1\">=</span> <span class=\"kw6\">STRUCT</span><span class=\"br0\">(</span> <span class=\"kw3\">INT</span> option<span class=\"sy1\">,</span> <span class=\"kw3\">STRING</span> replace <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>\u00a0<br/><span class=\"coMULTI\"># REPLACING option codes, these are the option values for a REPLACEMENT      #</span><br/><span class=\"kw3\">INT</span>  replace all     <span class=\"sy1\">=</span> 1<span class=\"sy1\">;</span><br/><span class=\"kw3\">INT</span>  replace leading <span class=\"sy1\">=</span> 2<span class=\"sy1\">;</span><br/><span class=\"kw3\">INT</span>  replace first   <span class=\"sy1\">=</span> 3<span class=\"sy1\">;</span><br/>\u00a0<br/><span class=\"kw4\">OP</span>   INSPECT   <span class=\"sy1\">=</span> <span class=\"br0\">(</span> <span class=\"kw4\">REF</span> <span class=\"kw3\">STRING</span> s <span class=\"br0\">)</span>INSPECTEE<span class=\"sy1\">:</span> <span class=\"br0\">(</span> s<span class=\"sy1\">,</span> 0 <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/><span class=\"kw4\">OP</span>   ALL       <span class=\"sy1\">=</span> <span class=\"br0\">(</span> <span class=\"kw3\">STRING</span> replace <span class=\"br0\">)</span>REPLACEMENT<span class=\"sy1\">:</span> <span class=\"br0\">(</span> replace all<span class=\"sy1\">,</span>     replace <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/><span class=\"kw4\">OP</span>   LEADING   <span class=\"sy1\">=</span> <span class=\"br0\">(</span> <span class=\"kw3\">STRING</span> replace <span class=\"br0\">)</span>REPLACEMENT<span class=\"sy1\">:</span> <span class=\"br0\">(</span> replace leading<span class=\"sy1\">,</span> replace <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/><span class=\"kw4\">OP</span>   FIRST     <span class=\"sy1\">=</span> <span class=\"br0\">(</span> <span class=\"kw3\">STRING</span> replace <span class=\"br0\">)</span>REPLACEMENT<span class=\"sy1\">:</span> <span class=\"br0\">(</span> replace first<span class=\"sy1\">,</span>   replace <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/><span class=\"kw4\">OP</span>   ALL       <span class=\"sy1\">=</span> <span class=\"br0\">(</span> <span class=\"kw3\">CHAR</span>   replace <span class=\"br0\">)</span>REPLACEMENT<span class=\"sy1\">:</span> <span class=\"br0\">(</span> replace all<span class=\"sy1\">,</span>     replace <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/><span class=\"kw4\">OP</span>   LEADING   <span class=\"sy1\">=</span> <span class=\"br0\">(</span> <span class=\"kw3\">CHAR</span>   replace <span class=\"br0\">)</span>REPLACEMENT<span class=\"sy1\">:</span> <span class=\"br0\">(</span> replace leading<span class=\"sy1\">,</span> replace <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/><span class=\"kw4\">OP</span>   FIRST     <span class=\"sy1\">=</span> <span class=\"br0\">(</span> <span class=\"kw3\">CHAR</span>   replace <span class=\"br0\">)</span>REPLACEMENT<span class=\"sy1\">:</span> <span class=\"br0\">(</span> replace first<span class=\"sy1\">,</span>   replace <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>\u00a0<br/><span class=\"kw4\">OP</span>   REPLACING <span class=\"sy1\">=</span> <span class=\"br0\">(</span> INSPECTEE inspected<span class=\"sy1\">,</span> REPLACEMENT replace <span class=\"br0\">)</span>INSPECTTOREPLACE<span class=\"sy1\">:</span><br/>                     <span class=\"br0\">(</span> item    <span class=\"kw6\">OF</span> inspected<br/>                     <span class=\"sy1\">,</span> option  <span class=\"kw6\">OF</span> replace<br/>                     <span class=\"sy1\">,</span> replace <span class=\"kw6\">OF</span> replace<br/>                     <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>\u00a0<br/><span class=\"kw4\">OP</span>   WITH      <span class=\"sy1\">=</span> <span class=\"br0\">(</span> INSPECTTOREPLACE inspected<span class=\"sy1\">,</span> <span class=\"kw3\">CHAR</span>   replace with <span class=\"br0\">)</span><span class=\"kw4\">REF</span> <span class=\"kw3\">STRING</span><span class=\"sy1\">:</span><br/>    <span class=\"kw2\">BEGIN</span><br/>        <span class=\"kw3\">STRING</span> with <span class=\"sy1\">:=</span> replace with<span class=\"sy1\">;</span><br/>        inspected WITH with<br/>    <span class=\"kw2\">END</span><span class=\"sy1\">;</span> <span class=\"coMULTI\"># WITH #</span><br/>\u00a0<br/><span class=\"kw4\">OP</span>   WITH      <span class=\"sy1\">=</span> <span class=\"br0\">(</span> INSPECTTOREPLACE inspected<span class=\"sy1\">,</span> <span class=\"kw3\">STRING</span> replace with <span class=\"br0\">)</span><span class=\"kw4\">REF</span> <span class=\"kw3\">STRING</span><span class=\"sy1\">:</span><br/>    <span class=\"kw2\">BEGIN</span><br/>\u00a0<br/>        <span class=\"kw3\">STRING</span>    to replace  <span class=\"sy1\">=</span> to replace <span class=\"kw6\">OF</span> inspected<span class=\"sy1\">;</span><br/>        <span class=\"kw3\">INT</span>       pos        <span class=\"sy1\">:=</span> 0<span class=\"sy1\">;</span><br/>        <span class=\"kw3\">STRING</span>    rest       <span class=\"sy1\">:=</span> item <span class=\"kw6\">OF</span> inspected<span class=\"sy1\">;</span><br/>        <span class=\"kw3\">STRING</span>    result     <span class=\"sy1\">:=</span> <span class=\"st0\">\"\"</span><span class=\"sy1\">;</span><br/>\u00a0<br/>        <span class=\"kw2\">IF</span>   option <span class=\"kw6\">OF</span> inspected <span class=\"sy1\">=</span> replace all<br/>        <span class=\"kw2\">THEN</span><br/>            <span class=\"coMULTI\"># replace all occurances of \"to replace\" with \"replace with\"     #</span><br/>            <span class=\"kw2\">WHILE</span> <span class=\"kw26\">string in string</span><span class=\"br0\">(</span> to replace<span class=\"sy1\">,</span> pos<span class=\"sy1\">,</span> rest <span class=\"br0\">)</span><br/>            <span class=\"kw2\">DO</span><br/>                result <span class=\"sy1\">+:=</span> rest<span class=\"br0\">[</span> 1 <span class=\"sy1\">:</span> pos <span class=\"sy1\">-</span> 1 <span class=\"br0\">]</span> <span class=\"sy1\">+</span> replace with<span class=\"sy1\">;</span><br/>                rest    <span class=\"sy1\">:=</span> rest<span class=\"br0\">[</span> pos <span class=\"sy1\">+</span> <span class=\"kw8\">UPB</span> to replace <span class=\"sy1\">:</span> <span class=\"br0\">]</span><br/>            <span class=\"kw2\">OD</span><br/>\u00a0<br/>        <span class=\"kw2\">ELIF</span> option <span class=\"kw6\">OF</span> inspected <span class=\"sy1\">=</span> replace leading<br/>        <span class=\"kw2\">THEN</span><br/>            <span class=\"coMULTI\"># replace leading occurances of \"to replace\" with \"replace with\" #</span><br/>            <span class=\"kw2\">WHILE</span> <span class=\"kw2\">IF</span> <span class=\"kw26\">string in string</span><span class=\"br0\">(</span> to replace<span class=\"sy1\">,</span> pos<span class=\"sy1\">,</span> rest <span class=\"br0\">)</span><br/>                  <span class=\"kw2\">THEN</span><br/>                      pos <span class=\"sy1\">=</span> 1<br/>                  <span class=\"kw2\">ELSE</span><br/>                      <span class=\"kw7\">FALSE</span><br/>                  <span class=\"kw2\">FI</span><br/>            <span class=\"kw2\">DO</span><br/>                result <span class=\"sy1\">+:=</span> replace with<span class=\"sy1\">;</span><br/>                rest    <span class=\"sy1\">:=</span> rest<span class=\"br0\">[</span> 1 <span class=\"sy1\">+</span> <span class=\"kw8\">UPB</span> to replace <span class=\"sy1\">:</span> <span class=\"br0\">]</span><br/>            <span class=\"kw2\">OD</span><br/>\u00a0<br/>        <span class=\"kw2\">ELIF</span> option <span class=\"kw6\">OF</span> inspected <span class=\"sy1\">=</span> replace first<br/>        <span class=\"kw2\">THEN</span><br/>            <span class=\"coMULTI\"># replace first occurance of \"to replace\" with \"replace with\"    #</span><br/>            <span class=\"kw2\">IF</span> <span class=\"kw26\">string in string</span><span class=\"br0\">(</span> to replace<span class=\"sy1\">,</span> pos<span class=\"sy1\">,</span> rest <span class=\"br0\">)</span><br/>            <span class=\"kw2\">THEN</span><br/>                result <span class=\"sy1\">+:=</span> rest<span class=\"br0\">[</span> 1 <span class=\"sy1\">:</span> pos <span class=\"sy1\">-</span> 1 <span class=\"br0\">]</span> <span class=\"sy1\">+</span> replace with<span class=\"sy1\">;</span><br/>                rest    <span class=\"sy1\">:=</span> rest<span class=\"br0\">[</span> pos <span class=\"sy1\">+</span> <span class=\"kw8\">UPB</span> to replace <span class=\"sy1\">:</span> <span class=\"br0\">]</span><br/>            <span class=\"kw2\">FI</span><br/>\u00a0<br/>        <span class=\"kw2\">ELSE</span><br/>            <span class=\"coMULTI\"># unsupported replace option #</span><br/>            write<span class=\"br0\">(</span> <span class=\"br0\">(</span> <span class=\"kw22\">newline</span><span class=\"sy1\">,</span> <span class=\"st0\">\"*** unsupported INSPECT REPLACING...\"</span><span class=\"sy1\">,</span> <span class=\"kw22\">newline</span> <span class=\"br0\">)</span> <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>            stop<br/>        <span class=\"kw2\">FI</span><span class=\"sy1\">;</span><br/>\u00a0<br/>        result <span class=\"sy1\">+:=</span> rest<span class=\"sy1\">;</span><br/>        item <span class=\"kw6\">OF</span> inspected <span class=\"sy1\">:=</span> result<br/>    <span class=\"kw2\">END</span><span class=\"sy1\">;</span> <span class=\"coMULTI\"># WITH #</span><br/>\u00a0<br/><span class=\"kw4\">OP</span>   DISPLAY <span class=\"sy1\">=</span> <span class=\"br0\">(</span> <span class=\"kw3\">STRING</span> s <span class=\"br0\">)</span><span class=\"kw3\">VOID</span><span class=\"sy1\">:</span> write<span class=\"br0\">(</span> <span class=\"br0\">(</span> s<span class=\"sy1\">,</span> <span class=\"kw22\">newline</span> <span class=\"br0\">)</span> <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>\u00a0<br/>\u00a0<br/><span class=\"kw4\">PRIO</span> REPLACING <span class=\"sy1\">=</span> 2<span class=\"sy1\">,</span> WITH <span class=\"sy1\">=</span> 1<span class=\"sy1\">;</span><br/>\u00a0<br/>\u00a0<br/>\u00a0<br/>\u00a0<br/>main<span class=\"sy1\">:</span> <span class=\"br0\">(</span><br/>\u00a0<br/>    <span class=\"coMULTI\"># test the INSPECT and DISPLAY \"verbs\" #</span><br/>\u00a0<br/>    <span class=\"kw3\">STRING</span>  text <span class=\"sy1\">:=</span> <span class=\"st0\">\"some text\"</span><span class=\"sy1\">;</span><br/>    DISPLAY text<span class=\"sy1\">;</span><br/>\u00a0<br/>    INSPECT text REPLACING FIRST   <span class=\"st0\">\"e\"</span>    WITH <span class=\"st0\">\"bbc\"</span><span class=\"sy1\">;</span><br/>    DISPLAY text<span class=\"sy1\">;</span><br/>\u00a0<br/>    INSPECT text REPLACING ALL     <span class=\"st0\">\"b\"</span>    WITH <span class=\"st0\">\"X\"</span><span class=\"sy1\">;</span><br/>    DISPLAY text<span class=\"sy1\">;</span><br/>\u00a0<br/>    INSPECT text REPLACING ALL     <span class=\"st0\">\"text\"</span> WITH <span class=\"st0\">\"some\"</span><span class=\"sy1\">;</span><br/>    DISPLAY text<span class=\"sy1\">;</span><br/>\u00a0<br/>    INSPECT text REPLACING LEADING <span class=\"st0\">\"som\"</span>  WITH <span class=\"st0\">\"k\"</span><span class=\"sy1\">;</span><br/>    DISPLAY text<br/>\u00a0<br/>\u00a0<br/><span class=\"br0\">)</span></pre>"}, {"lang": "C", "loc": 14, "block": "<pre class=\"c highlighted_source\">\u00a0<br/><span class=\"co1\">// http://stackoverflow.com/questions/3385515/static-assert-in-c</span><br/><span class=\"co2\">#define STATIC_ASSERT(COND,MSG) typedef char static_assertion_##MSG[(!!(COND))*2-1]</span><br/><span class=\"co1\">// token pasting madness:</span><br/><span class=\"co2\">#define COMPILE_TIME_ASSERT3(X,L) STATIC_ASSERT(X,static_assertion_at_line_##L)</span><br/><span class=\"co2\">#define COMPILE_TIME_ASSERT2(X,L) COMPILE_TIME_ASSERT3(X,L)</span><br/><span class=\"co2\">#define COMPILE_TIME_ASSERT(X)    COMPILE_TIME_ASSERT2(X,__LINE__)</span><br/>\u00a0<br/>COMPILE_TIME_ASSERT<span class=\"br0\">(</span><span class=\"kw4\">sizeof</span><span class=\"br0\">(</span><span class=\"kw4\">long</span><span class=\"br0\">)</span><span class=\"sy0\">==</span><span class=\"nu0\">8</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <br/><span class=\"kw4\">int</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>    COMPILE_TIME_ASSERT<span class=\"br0\">(</span><span class=\"kw4\">sizeof</span><span class=\"br0\">(</span><span class=\"kw4\">int</span><span class=\"br0\">)</span><span class=\"sy0\">==</span><span class=\"nu0\">4</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <br/><span class=\"br0\">}</span><br/>\u00a0</pre>"}, {"lang": "C#", "loc": 11, "block": "<pre class=\"lisp highlighted_source\">\u00a0<br/><span class=\"br0\">(</span>loop for count from <span class=\"nu0\">1</span><br/>      for x in '<span class=\"br0\">(</span><span class=\"nu0\">1</span> <span class=\"nu0\">2</span> <span class=\"nu0\">3</span> <span class=\"nu0\">4</span> <span class=\"nu0\">5</span><span class=\"br0\">)</span><br/>      summing x into sum<br/>      summing <span class=\"br0\">(</span>* x x<span class=\"br0\">)</span> into sum-of-squares<br/>      finally<br/>        <span class=\"br0\">(</span><span class=\"kw1\">return</span><br/>          <span class=\"br0\">(</span><span class=\"kw1\">let</span>* <span class=\"br0\">(</span><span class=\"br0\">(</span>mean <span class=\"br0\">(</span>/ sum count<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                 <span class=\"br0\">(</span>spl-var <span class=\"br0\">(</span>- <span class=\"br0\">(</span>* count sum-of-squares<span class=\"br0\">)</span> <span class=\"br0\">(</span>* sum sum<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                 <span class=\"br0\">(</span>spl-dev <span class=\"br0\">(</span><span class=\"kw1\">sqrt</span> <span class=\"br0\">(</span>/ spl-var <span class=\"br0\">(</span><span class=\"nu0\">1</span>- count<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <br/>            <span class=\"br0\">(</span>values mean spl-var spl-dev<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> </pre>"}, {"lang": "Clojure", "loc": 11, "block": "<pre class=\"lisp highlighted_source\">\u00a0<br/><span class=\"br0\">(</span>loop for count from <span class=\"nu0\">1</span><br/>      for x in '<span class=\"br0\">(</span><span class=\"nu0\">1</span> <span class=\"nu0\">2</span> <span class=\"nu0\">3</span> <span class=\"nu0\">4</span> <span class=\"nu0\">5</span><span class=\"br0\">)</span><br/>      summing x into sum<br/>      summing <span class=\"br0\">(</span>* x x<span class=\"br0\">)</span> into sum-of-squares<br/>      finally<br/>        <span class=\"br0\">(</span><span class=\"kw1\">return</span><br/>          <span class=\"br0\">(</span><span class=\"kw1\">let</span>* <span class=\"br0\">(</span><span class=\"br0\">(</span>mean <span class=\"br0\">(</span>/ sum count<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                 <span class=\"br0\">(</span>spl-var <span class=\"br0\">(</span>- <span class=\"br0\">(</span>* count sum-of-squares<span class=\"br0\">)</span> <span class=\"br0\">(</span>* sum sum<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                 <span class=\"br0\">(</span>spl-dev <span class=\"br0\">(</span><span class=\"kw1\">sqrt</span> <span class=\"br0\">(</span>/ spl-var <span class=\"br0\">(</span><span class=\"nu0\">1</span>- count<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <br/>            <span class=\"br0\">(</span>values mean spl-var spl-dev<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> </pre>"}, {"lang": "Common Lisp", "loc": 11, "block": "<pre class=\"lisp highlighted_source\">\u00a0<br/><span class=\"br0\">(</span>loop for count from <span class=\"nu0\">1</span><br/>      for x in '<span class=\"br0\">(</span><span class=\"nu0\">1</span> <span class=\"nu0\">2</span> <span class=\"nu0\">3</span> <span class=\"nu0\">4</span> <span class=\"nu0\">5</span><span class=\"br0\">)</span><br/>      summing x into sum<br/>      summing <span class=\"br0\">(</span>* x x<span class=\"br0\">)</span> into sum-of-squares<br/>      finally<br/>        <span class=\"br0\">(</span><span class=\"kw1\">return</span><br/>          <span class=\"br0\">(</span><span class=\"kw1\">let</span>* <span class=\"br0\">(</span><span class=\"br0\">(</span>mean <span class=\"br0\">(</span>/ sum count<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                 <span class=\"br0\">(</span>spl-var <span class=\"br0\">(</span>- <span class=\"br0\">(</span>* count sum-of-squares<span class=\"br0\">)</span> <span class=\"br0\">(</span>* sum sum<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>                 <span class=\"br0\">(</span>spl-dev <span class=\"br0\">(</span><span class=\"kw1\">sqrt</span> <span class=\"br0\">(</span>/ spl-var <span class=\"br0\">(</span><span class=\"nu0\">1</span>- count<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <br/>            <span class=\"br0\">(</span>values mean spl-var spl-dev<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> </pre>"}, {"lang": "D", "loc": 10, "block": "<pre class=\"d highlighted_source\"><span class=\"kw4\">enum</span> GenStruct<span class=\"br0\">(</span><span class=\"kw4\">string</span> name<span class=\"sy0\">,</span> <span class=\"kw4\">string</span> fieldName<span class=\"br0\">)</span> <span class=\"sy0\">=</span><br/>    <span class=\"st0\">\"struct \"</span> <span class=\"sy0\">~</span> name <span class=\"sy0\">~</span> <span class=\"st0\">\"{ int \"</span> <span class=\"sy0\">~</span> fieldName <span class=\"sy0\">~</span> <span class=\"st0\">\"; }\"</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"co1\">// Equivalent to:  struct Foo { int bar; }</span><br/><span class=\"kw2\">mixin</span><span class=\"br0\">(</span>GenStruct<span class=\"sy0\">!</span><span class=\"br0\">(</span><span class=\"st0\">\"Foo\"</span><span class=\"sy0\">,</span> <span class=\"st0\">\"bar\"</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"kw4\">void</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    Foo f<span class=\"sy0\">;</span><br/>    f.<span class=\"me1\">bar</span> <span class=\"sy0\">=</span> <span class=\"nu0\">10</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "E", "loc": 35, "block": "<pre class=\"text highlighted_source\">\\ BRANCH and LOOP COMPILERS<br/>\u00a0<br/>\\ branch offset computation operators<br/>: AHEAD    ( -- addr)  HERE   0 ,\u00a0;<br/>: BACK     ( addr -- ) HERE   - ,\u00a0;<br/>: RESOLVE  ( addr -- ) HERE OVER - SWAP\u00a0!\u00a0;<br/>\u00a0<br/>\\ LEAVE stack is called L0. It is initialized by QUIT.<br/>: &gt;L        ( x -- ) ( L: -- x )  2 LP +!  LP @\u00a0!\u00a0;<br/>: L&gt;        ( -- x )  ( L: x -- ) LP @ @   -2 LP +!\u00a0;<br/>\u00a0<br/>\\ finite loop compilers<br/>: DO        ( -- ) POSTPONE &lt;DO&gt;     HERE 0 &gt;L   3\u00a0;  IMMEDIATE<br/>:\u00a0?DO       ( -- ) POSTPONE &lt;?DO&gt;    HERE 0 &gt;L   3\u00a0;  IMMEDIATE<br/>: LEAVE     ( -- ) ( L: -- addr )<br/>            POSTPONE UNLOOP   POSTPONE BRANCH AHEAD &gt;L\u00a0; IMMEDIATE<br/>\u00a0<br/>: RAKE      ( -- ) ( L: 0 a1 a2 .. aN -- )<br/>            BEGIN  L&gt;\u00a0?DUP WHILE  RESOLVE  REPEAT\u00a0;   IMMEDIATE<br/>\u00a0<br/>: LOOP      ( -- )  3\u00a0?PAIRS POSTPONE &lt;LOOP&gt;  BACK  RAKE\u00a0; IMMEDIATE<br/>: +LOOP     ( -- )  3\u00a0?PAIRS POSTPONE &lt;+LOOP&gt; BACK  RAKE\u00a0; IMMEDIATE<br/>\u00a0<br/>\\ conditional branches<br/>: IF          (\u00a0? -- ) POSTPONE\u00a0?BRANCH AHEAD 2\u00a0;        IMMEDIATE<br/>: THEN        ( -- ) \u00a0?COMP  2\u00a0?PAIRS RESOLVE\u00a0;          IMMEDIATE<br/>: ELSE        ( -- )  2\u00a0?PAIRS  POSTPONE BRANCH AHEAD SWAP 2<br/>                      POSTPONE THEN 2\u00a0;                  IMMEDIATE<br/>\u00a0<br/>\\ infinite loop compilers<br/>: BEGIN       ( -- addr n)\u00a0?COMP HERE  1 \u00a0;              IMMEDIATE<br/>: AGAIN       ( -- )   1\u00a0?PAIRS POSTPONE BRANCH BACK  \u00a0;  IMMEDIATE<br/>: UNTIL       (\u00a0? -- ) 1\u00a0?PAIRS POSTPONE\u00a0?BRANCH BACK \u00a0;  IMMEDIATE<br/>: WHILE       (\u00a0? -- ) POSTPONE IF  2+ \u00a0;                IMMEDIATE<br/>: REPEAT      ( -- )   2&gt;R POSTPONE AGAIN  2R&gt; 2- POSTPONE THEN\u00a0; IMMEDIATE</pre>"}, {"lang": "Erlang", "loc": 35, "block": "<pre class=\"text highlighted_source\">\\ BRANCH and LOOP COMPILERS<br/>\u00a0<br/>\\ branch offset computation operators<br/>: AHEAD    ( -- addr)  HERE   0 ,\u00a0;<br/>: BACK     ( addr -- ) HERE   - ,\u00a0;<br/>: RESOLVE  ( addr -- ) HERE OVER - SWAP\u00a0!\u00a0;<br/>\u00a0<br/>\\ LEAVE stack is called L0. It is initialized by QUIT.<br/>: &gt;L        ( x -- ) ( L: -- x )  2 LP +!  LP @\u00a0!\u00a0;<br/>: L&gt;        ( -- x )  ( L: x -- ) LP @ @   -2 LP +!\u00a0;<br/>\u00a0<br/>\\ finite loop compilers<br/>: DO        ( -- ) POSTPONE &lt;DO&gt;     HERE 0 &gt;L   3\u00a0;  IMMEDIATE<br/>:\u00a0?DO       ( -- ) POSTPONE &lt;?DO&gt;    HERE 0 &gt;L   3\u00a0;  IMMEDIATE<br/>: LEAVE     ( -- ) ( L: -- addr )<br/>            POSTPONE UNLOOP   POSTPONE BRANCH AHEAD &gt;L\u00a0; IMMEDIATE<br/>\u00a0<br/>: RAKE      ( -- ) ( L: 0 a1 a2 .. aN -- )<br/>            BEGIN  L&gt;\u00a0?DUP WHILE  RESOLVE  REPEAT\u00a0;   IMMEDIATE<br/>\u00a0<br/>: LOOP      ( -- )  3\u00a0?PAIRS POSTPONE &lt;LOOP&gt;  BACK  RAKE\u00a0; IMMEDIATE<br/>: +LOOP     ( -- )  3\u00a0?PAIRS POSTPONE &lt;+LOOP&gt; BACK  RAKE\u00a0; IMMEDIATE<br/>\u00a0<br/>\\ conditional branches<br/>: IF          (\u00a0? -- ) POSTPONE\u00a0?BRANCH AHEAD 2\u00a0;        IMMEDIATE<br/>: THEN        ( -- ) \u00a0?COMP  2\u00a0?PAIRS RESOLVE\u00a0;          IMMEDIATE<br/>: ELSE        ( -- )  2\u00a0?PAIRS  POSTPONE BRANCH AHEAD SWAP 2<br/>                      POSTPONE THEN 2\u00a0;                  IMMEDIATE<br/>\u00a0<br/>\\ infinite loop compilers<br/>: BEGIN       ( -- addr n)\u00a0?COMP HERE  1 \u00a0;              IMMEDIATE<br/>: AGAIN       ( -- )   1\u00a0?PAIRS POSTPONE BRANCH BACK  \u00a0;  IMMEDIATE<br/>: UNTIL       (\u00a0? -- ) 1\u00a0?PAIRS POSTPONE\u00a0?BRANCH BACK \u00a0;  IMMEDIATE<br/>: WHILE       (\u00a0? -- ) POSTPONE IF  2+ \u00a0;                IMMEDIATE<br/>: REPEAT      ( -- )   2&gt;R POSTPONE AGAIN  2R&gt; 2- POSTPONE THEN\u00a0; IMMEDIATE</pre>"}, {"lang": "Forth", "loc": 35, "block": "<pre class=\"text highlighted_source\">\\ BRANCH and LOOP COMPILERS<br/>\u00a0<br/>\\ branch offset computation operators<br/>: AHEAD    ( -- addr)  HERE   0 ,\u00a0;<br/>: BACK     ( addr -- ) HERE   - ,\u00a0;<br/>: RESOLVE  ( addr -- ) HERE OVER - SWAP\u00a0!\u00a0;<br/>\u00a0<br/>\\ LEAVE stack is called L0. It is initialized by QUIT.<br/>: &gt;L        ( x -- ) ( L: -- x )  2 LP +!  LP @\u00a0!\u00a0;<br/>: L&gt;        ( -- x )  ( L: x -- ) LP @ @   -2 LP +!\u00a0;<br/>\u00a0<br/>\\ finite loop compilers<br/>: DO        ( -- ) POSTPONE &lt;DO&gt;     HERE 0 &gt;L   3\u00a0;  IMMEDIATE<br/>:\u00a0?DO       ( -- ) POSTPONE &lt;?DO&gt;    HERE 0 &gt;L   3\u00a0;  IMMEDIATE<br/>: LEAVE     ( -- ) ( L: -- addr )<br/>            POSTPONE UNLOOP   POSTPONE BRANCH AHEAD &gt;L\u00a0; IMMEDIATE<br/>\u00a0<br/>: RAKE      ( -- ) ( L: 0 a1 a2 .. aN -- )<br/>            BEGIN  L&gt;\u00a0?DUP WHILE  RESOLVE  REPEAT\u00a0;   IMMEDIATE<br/>\u00a0<br/>: LOOP      ( -- )  3\u00a0?PAIRS POSTPONE &lt;LOOP&gt;  BACK  RAKE\u00a0; IMMEDIATE<br/>: +LOOP     ( -- )  3\u00a0?PAIRS POSTPONE &lt;+LOOP&gt; BACK  RAKE\u00a0; IMMEDIATE<br/>\u00a0<br/>\\ conditional branches<br/>: IF          (\u00a0? -- ) POSTPONE\u00a0?BRANCH AHEAD 2\u00a0;        IMMEDIATE<br/>: THEN        ( -- ) \u00a0?COMP  2\u00a0?PAIRS RESOLVE\u00a0;          IMMEDIATE<br/>: ELSE        ( -- )  2\u00a0?PAIRS  POSTPONE BRANCH AHEAD SWAP 2<br/>                      POSTPONE THEN 2\u00a0;                  IMMEDIATE<br/>\u00a0<br/>\\ infinite loop compilers<br/>: BEGIN       ( -- addr n)\u00a0?COMP HERE  1 \u00a0;              IMMEDIATE<br/>: AGAIN       ( -- )   1\u00a0?PAIRS POSTPONE BRANCH BACK  \u00a0;  IMMEDIATE<br/>: UNTIL       (\u00a0? -- ) 1\u00a0?PAIRS POSTPONE\u00a0?BRANCH BACK \u00a0;  IMMEDIATE<br/>: WHILE       (\u00a0? -- ) POSTPONE IF  2+ \u00a0;                IMMEDIATE<br/>: REPEAT      ( -- )   2&gt;R POSTPONE AGAIN  2R&gt; 2- POSTPONE THEN\u00a0; IMMEDIATE</pre>"}, {"lang": "FreeBASIC", "loc": 16, "block": "<pre class=\"freebasic highlighted_source\"><span class=\"co1\">' FB 1.05.0 Win64</span><br/>\u00a0<br/><span class=\"co2\">#Macro ForAll(C, S)</span><br/><span class=\"kw1\">For</span> _i <span class=\"kw1\">as</span> <span class=\"kw1\">integer</span> = <span class=\"nu0\">0</span> <span class=\"kw1\">To</span> <span class=\"kw1\">Len</span><span class=\"br0\">(</span>s<span class=\"br0\">)</span> <br/><span class=\"co2\">#Define C (Chr(s[_i]))</span><br/><span class=\"co2\">#EndMacro</span><br/>\u00a0<br/><span class=\"co2\">#Define In ,</span><br/>\u00a0<br/><span class=\"kw1\">Dim</span> s <span class=\"kw1\">As</span> <span class=\"kw1\">String</span> = <span class=\"st0\">\"Rosetta\"</span><br/>ForAll<span class=\"br0\">(</span>c in s<span class=\"br0\">)</span><br/>  <span class=\"kw1\">Print</span> c; <span class=\"st0\">\" \"</span>;<br/><span class=\"kw1\">Next</span><br/>\u00a0<br/><span class=\"kw1\">Print</span><br/><span class=\"kw1\">Sleep</span></pre>"}, {"lang": "Haskell", "loc": 8, "block": "<pre class=\"scala highlighted_source\"><span class=\"co1\">// version 1.0.6</span><br/>\u00a0<br/>infix fun Double.<span class=\"me1\">pwr</span><span class=\"br0\">(</span>exp<span class=\"sy0\">:</span> Double<span class=\"br0\">)</span> <span class=\"sy0\">=</span> Math.<span class=\"me1\">pow</span><span class=\"br0\">(</span><a href=\"http://scala-lang.org\"><span class=\"kw1\">this</span></a>, exp<span class=\"br0\">)</span><br/>\u00a0<br/>fun main<span class=\"br0\">(</span>args<span class=\"sy0\">:</span> Array<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>   <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> d <span class=\"sy0\">=</span> <span class=\"nu0\">2.0</span> pwr <span class=\"nu0\">8.0</span><br/>   println<span class=\"br0\">(</span>d<span class=\"br0\">)</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "J", "loc": 8, "block": "<pre class=\"scala highlighted_source\"><span class=\"co1\">// version 1.0.6</span><br/>\u00a0<br/>infix fun Double.<span class=\"me1\">pwr</span><span class=\"br0\">(</span>exp<span class=\"sy0\">:</span> Double<span class=\"br0\">)</span> <span class=\"sy0\">=</span> Math.<span class=\"me1\">pow</span><span class=\"br0\">(</span><a href=\"http://scala-lang.org\"><span class=\"kw1\">this</span></a>, exp<span class=\"br0\">)</span><br/>\u00a0<br/>fun main<span class=\"br0\">(</span>args<span class=\"sy0\">:</span> Array<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>   <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> d <span class=\"sy0\">=</span> <span class=\"nu0\">2.0</span> pwr <span class=\"nu0\">8.0</span><br/>   println<span class=\"br0\">(</span>d<span class=\"br0\">)</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Kotlin", "loc": 8, "block": "<pre class=\"scala highlighted_source\"><span class=\"co1\">// version 1.0.6</span><br/>\u00a0<br/>infix fun Double.<span class=\"me1\">pwr</span><span class=\"br0\">(</span>exp<span class=\"sy0\">:</span> Double<span class=\"br0\">)</span> <span class=\"sy0\">=</span> Math.<span class=\"me1\">pow</span><span class=\"br0\">(</span><a href=\"http://scala-lang.org\"><span class=\"kw1\">this</span></a>, exp<span class=\"br0\">)</span><br/>\u00a0<br/>fun main<span class=\"br0\">(</span>args<span class=\"sy0\">:</span> Array<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>   <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> d <span class=\"sy0\">=</span> <span class=\"nu0\">2.0</span> pwr <span class=\"nu0\">8.0</span><br/>   println<span class=\"br0\">(</span>d<span class=\"br0\">)</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Lingo", "loc": 3, "block": "<pre class=\"text highlighted_source\">r = RETURN<br/>str = \"on halt\"&amp;r&amp;\"--do nothing\"&amp;r&amp;\"end\"<br/>new(#script).scripttext = str</pre>"}, {"lang": "Lua", "loc": 6, "block": "<pre class=\"lua highlighted_source\">\u00a0<br/>class <span class=\"st0\">\"foo\"</span> <span class=\"sy0\">:</span> inherits <span class=\"st0\">\"bar\"</span><br/><span class=\"br0\">{</span><br/>\u00a0<br/><span class=\"br0\">}</span> <br/>\u00a0</pre>"}, {"lang": "M2000 Interpreter", "loc": 16, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>Module Meta {<br/>      FunName$=\"Alfa\"<br/>      Code1$=FunName$+\"=lambda (X)-&gt;{\"<br/>      Code2$={<br/>            =x**2<br/>      }<br/>      Code3$=\"}\"<br/>\u00a0<br/>      Inline code1$+code2$+code3$<br/>\u00a0<br/>      Print Function(FunName$, 4)=16<br/>\u00a0<br/>}<br/>Meta<br/>\u00a0</pre>"}, {"lang": "Mathematica", "loc": 2, "block": "<pre class=\"text highlighted_source\">CircleTimes[x_, y_]\u00a0:= Mod[x, 10] Mod[y, 10]<br/>14\\[CircleTimes]13</pre>"}, {"lang": "Nemerle", "loc": 11, "block": "<pre class=\"text highlighted_source\">proc `^`*[T: SomeInteger](base, exp: T): T =<br/>  var (base, exp) = (base, exp)<br/>  result = 1<br/>\u00a0<br/>  while exp\u00a0!= 0:<br/>    if (exp and 1)\u00a0!= 0:<br/>      result *= base<br/>    exp = exp shr 1<br/>    base *= base<br/>\u00a0<br/>echo 2 ^ 10 # 1024</pre>"}, {"lang": "Nim", "loc": 11, "block": "<pre class=\"text highlighted_source\">proc `^`*[T: SomeInteger](base, exp: T): T =<br/>  var (base, exp) = (base, exp)<br/>  result = 1<br/>\u00a0<br/>  while exp\u00a0!= 0:<br/>    if (exp and 1)\u00a0!= 0:<br/>      result *= base<br/>    exp = exp shr 1<br/>    base *= base<br/>\u00a0<br/>echo 2 ^ 10 # 1024</pre>"}, {"lang": "PARI/GP", "loc": 1, "block": "<pre>Function: <a class=\"__cf_email__\" data-cfemail=\"441b04\" href=\"/cdn-cgi/l/email-protection\">[email\u00a0protected]</a>_\nHelp: <a class=\"__cf_email__\" data-cfemail=\"740c340d\" href=\"/cdn-cgi/l/email-protection\">[email\u00a0protected]</a>: compute the lesser of x and y, or 0, whichever is larger.\nSection: symbolic_operators\nC-Name: gmin0\nPrototype: GG\nDescription:\n (small, small):small\t smin0ss($1, $2)\n (mp, mp):mp            gmin0($1, $2)\n (gen, gen):gen     \t gmin0($1, $2)</pre>"}, {"lang": "Perl", "loc": 5, "block": "<pre class=\"perl highlighted_source\"><a href=\"http://perldoc.perl.org/functions/package.html\"><span class=\"kw3\">package</span></a> UnicodeEllipsis<span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"kw2\">use</span> Filter<span class=\"sy0\">::</span><span class=\"me2\">Simple</span><span class=\"sy0\">;</span><br/>\u00a0<br/>FILTER_ONLY code <span class=\"sy0\">=&gt;</span> <span class=\"kw2\">sub</span> <span class=\"br0\">{</span> <span class=\"co2\">s/\u2026/../g</span> <span class=\"br0\">}</span><span class=\"sy0\">;</span></pre>"}, {"lang": "Perl 6", "loc": 2, "block": "<pre class=\"perl6 highlighted_source\"><span class=\"kw2\">sub</span> postfix<span class=\"sy0\">:&lt;!&gt;</span> <span class=\"br0\">{</span> <span class=\"br0\">[</span><span class=\"sy0\">*</span><span class=\"br0\">]</span> <span class=\"nu0\">1</span><span class=\"sy0\">..</span><span class=\"re0\">$^n</span> <span class=\"br0\">}</span><br/><span class=\"kw3\">say</span> <span class=\"nu0\">5</span><span class=\"sy0\">!;</span>  <span class=\"co1\"># prints 120</span></pre>"}, {"lang": "PicoLisp", "loc": 14, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>\u00a0<br/>/ift {<br/>4 dict begin<br/>    [/.if /.then] let*<br/>    count array astore /.stack exch def<br/>    /_restore {clear .stack aload pop}.<br/>    .stack aload pop .if {<br/>       _restore .then<br/>    } {<br/>       _restore<br/>    } ifelse<br/>end}.<br/>\u00a0</pre>"}, {"lang": "PostScript", "loc": 14, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>\u00a0<br/>/ift {<br/>4 dict begin<br/>    [/.if /.then] let*<br/>    count array astore /.stack exch def<br/>    /_restore {clear .stack aload pop}.<br/>    .stack aload pop .if {<br/>       _restore .then<br/>    } {<br/>       _restore<br/>    } ifelse<br/>end}.<br/>\u00a0</pre>"}, {"lang": "Python", "loc": 11, "block": "<pre class=\"python highlighted_source\">\u00a0<br/><span class=\"kw1\">from</span> macropy.<span class=\"me1\">core</span>.<span class=\"me1\">macros</span> <span class=\"kw1\">import</span> *<br/><span class=\"kw1\">from</span> macropy.<span class=\"me1\">core</span>.<span class=\"me1\">quotes</span> <span class=\"kw1\">import</span> macros<span class=\"sy0\">,</span> q<span class=\"sy0\">,</span> ast<span class=\"sy0\">,</span> u<br/>\u00a0<br/>macros <span class=\"sy0\">=</span> Macros<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"sy0\">@</span>macros.<span class=\"me1\">expr</span><br/><span class=\"kw1\">def</span> expand<span class=\"br0\">(</span>tree<span class=\"sy0\">,</span> **kw<span class=\"br0\">)</span>:<br/>    addition <span class=\"sy0\">=</span> <span class=\"nu0\">10</span><br/>    <span class=\"kw1\">return</span> q<span class=\"br0\">[</span><span class=\"kw1\">lambda</span> x: x * ast<span class=\"br0\">[</span>tree<span class=\"br0\">]</span> + u<span class=\"br0\">[</span>addition<span class=\"br0\">]</span><span class=\"br0\">]</span><br/>\u00a0</pre>"}, {"lang": "Racket", "loc": 10, "block": "<pre class=\"text highlighted_source\">#lang racket<br/>\u00a0<br/>(define-syntax-rule (list-when test body)<br/>  (if test<br/>      body<br/>      '()))<br/>\u00a0<br/>(let ([not-a-string 42])<br/>  (list-when (string? not-a-string)<br/>    (string-&gt;list not-a-string)))</pre>"}, {"lang": "Rascal", "loc": 14, "block": "<pre class=\"text highlighted_source\">extend ViewParseTree;<br/>\u00a0<br/>layout Whitespace = [\\ \\t\\n]*;<br/>syntax A = \"a\";<br/>syntax B = \"b\";<br/>start syntax C = \"c\" | A C B;<br/>\u00a0<br/>layout Whitespace = [\\ \\t\\n]*;            <br/>lexical Integer = [0-9]+;<br/>start syntax E1 = Integer<br/>               | E \"*\" E<br/>\t       &gt; E \"+\" E<br/>\t       | \"(\" E \")\"<br/>              \u00a0;</pre>"}, {"lang": "REXX", "loc": 53, "block": "<pre class=\"rexx highlighted_source\"><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 The REXX language doesn't allow for the changing or overriding of \u2502<br/>  \u2502 syntax per se,  but any of the built-in-functions (BIFs) can be   \u2502<br/>  \u2502 overridden by just specifying your own.                           \u2502<br/>  \u2502                                                                   \u2502<br/>  \u2502 To use the REXX's version of a built-in-function, you simply just \u2502<br/>  \u2502 enclose the BIF in quotation marks (and uppercase the name).      \u2502<br/>  \u2502                                                                   \u2502<br/>  \u2502 The intent is two-fold:  the REXX language doesn't have any       \u2502<br/>  \u2502 reserved words,  nor reserved  BIFs  (Built-In-Functions).        \u2502<br/>  \u2502                                                                   \u2502<br/>  \u2502 So, if you don't know that  VERIFY  is a BIF,  you can just code  \u2502<br/>  \u2502 a subroutine (or function)  with that name (or any name), and not \u2502<br/>  \u2502 worry about your subroutine being pre-empted.                     \u2502<br/>  \u2502                                                                   \u2502<br/>  \u2502 Second:  if you're not satisfied how a BIF works, you can code    \u2502<br/>  \u2502 your own.   This also allows you to front-end a BIF for debugging \u2502<br/>  \u2502 or modifying the BIF's behavior.                                  \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 */</span><br/>yyy=<span class=\"st0\">'123456789abcdefghi'</span><br/>\u00a0<br/>rrr =  <span class=\"kw6\">substr</span><span class=\"br0\">(</span>yyy,<span class=\"nu0\">5</span><span class=\"br0\">)</span>                   <span class=\"coMULTI\">/*returns  efghi                 */</span><br/>mmm = <span class=\"st0\">'SUBSTR'</span><span class=\"br0\">(</span>yyy,<span class=\"nu0\">5</span><span class=\"br0\">)</span>                  <span class=\"coMULTI\">/*returns  56789abcdefgji        */</span><br/>sss = <span class=\"st0\">\"SUBSTR\"</span><span class=\"br0\">(</span>yyy,<span class=\"nu0\">5</span><span class=\"br0\">)</span>                  <span class=\"coMULTI\">/* (same as above)               */</span><br/><span class=\"kw1\">exit</span>                                   <span class=\"coMULTI\">/*stick a fork in it, we're done.*/</span><br/>\u00a0<br/><span class=\"coMULTI\">/*\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500SUBSTR subroutine\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500*/</span><br/><span class=\"kw6\">substr</span>: <span class=\"kw1\">return</span> <span class=\"kw6\">right</span><span class=\"br0\">(</span><span class=\"kw1\">arg</span><span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span>,<span class=\"kw1\">arg</span><span class=\"br0\">(</span><span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 Also, some REXX interpreters treat whitespace(s) as blanks   when \u2502<br/>  \u2502 performing comparisons.    Some of the whitespace characters are: \u2502<br/>  \u2502                                                                   \u2502<br/>  \u2502           NL  (newLine)                                           \u2502<br/>  \u2502           FF  (formFeed)                                          \u2502<br/>  \u2502           VT  (vertical tab)                                      \u2502<br/>  \u2502           HT  (horizontal tab or TAB)                             \u2502<br/>  \u2502           LF  (lineFeed)                                          \u2502<br/>  \u2502           CR  (carriage return)                                   \u2502<br/>  \u2502           EOF (end-of-file)                                       \u2502<br/>  \u2502         and/or others.                                            \u2502<br/>  \u2502                                                                   \u2502<br/>  \u2502 Note that some of the above are ASCII or EBCDIC specific.         \u2502<br/>  \u2502                                                                   \u2502<br/>  \u2502 Some REXX interpreters use the   OPTIONS   statement to force     \u2502<br/>  \u2502 REXX to only treat blanks as spaces.                              \u2502<br/>  \u2502                                                                   \u2502<br/>  \u2502 (Both the  verb  and  option  may be in lower/upper/mixed case.)  \u2502<br/>  \u2502                                                                   \u2502<br/>  \u2502 REXX interpreters which don't recognize any  option  won't treat  \u2502<br/>  \u2502 the (below) statement as an error.                                \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 */</span><br/><span class=\"kw1\">options</span>  strict_white_space_comparisons   <span class=\"coMULTI\">/*can be in lower/upper/mixed.*/</span></pre>"}, {"lang": "Ring", "loc": 7, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>o1 = new point { x=10 y=20 z=30 }<br/>addmethod(o1,\"print\", func { see x + nl + y + nl + z + nl } )<br/>o1.print()<br/>Class point<br/>        x y z<br/>\u00a0</pre>"}, {"lang": "Ruby", "loc": 12, "block": "<pre class=\"ruby highlighted_source\"><span class=\"kw1\">class</span> IDVictim<br/>\u00a0<br/>  <span class=\"co1\"># Create elements of this man, woman, or child's identification.</span><br/>  attr_accessor <span class=\"re3\">:name</span>, <span class=\"re3\">:birthday</span>, <span class=\"re3\">:gender</span>, <span class=\"re3\">:hometown</span><br/>\u00a0<br/>  <span class=\"co1\"># Allows you to put in a space for anything which is not covered by the</span><br/>  <span class=\"co1\"># preexisting elements.</span><br/>  <span class=\"kw1\">def</span> <span class=\"kw2\">self</span>.<span class=\"me1\">new_element</span><span class=\"br0\">(</span>element<span class=\"br0\">)</span><br/>    attr_accessor element<br/>  <span class=\"kw1\">end</span><br/>\u00a0<br/><span class=\"kw1\">end</span></pre>"}, {"lang": "Run BASIC", "loc": 32, "block": "<pre class=\"text highlighted_source\">' ---------------------------------------------------<br/>' create a file to be run<br/>' RB can run the entire program<br/>'  or execute a function withing the RUNNED program<br/>' ---------------------------------------------------<br/>open \"runned.bas\" for output as #f                      ' open runned.bas as output<br/>\u00a0<br/>print #f, \"text$ = \"\"I'm rinning the complete program.  ' print this program to the output<br/>Or you can run a function.<br/>The program or function within the RUNNED program<br/>can execute all Run BASIC commands.\"\"\"<br/>\u00a0<br/>print #f, \"<br/>x = displayText(text$)\"<br/>\u00a0<br/>print #f, \"                                            ' besides RUNNING the entireprogram<br/>Function displayText(text$)                            ' we will execute this function only<br/>print text$                                            '<br/>end function\"<br/>\u00a0<br/>' ----------------------------------------<br/>' Execute the entire RUNNED program<br/>' ----------------------------------------<br/>RUN \"runned.bas\",#handle          ' setup run command to execute runned.bas and give it a handle<br/>render #handle                    ' render the handle will execute the program<br/>\u00a0<br/>' ----------------------------------------<br/>' Execute a function in the RUNNED program<br/>' ----------------------------------------<br/>RUN \"runned.bas\",#handle          ' setup run command to execute runned.bas and give it a handle<br/>#handle displayText(\"Welcome!\")   ' only execute the function withing the runned program<br/>render #handle                    ' render the handle will execute the program</pre>"}, {"lang": "Rust", "loc": 58, "block": "<pre class=\"text highlighted_source\">// dry.rs<br/>use std::ops::{Add, Mul, Sub};<br/>\u00a0<br/>macro_rules! assert_equal_len {<br/>    // The `tt` (token tree) designator is used for<br/>    // operators and tokens.<br/>    ($a:ident, $b: ident, $func:ident, $op:tt) =&gt; (<br/>        assert!($a.len() == $b.len(),<br/>                \"{:?}: dimension mismatch: {:?} {:?} {:?}\",<br/>                stringify!($func),<br/>                ($a.len(),),<br/>                stringify!($op),<br/>                ($b.len(),));<br/>    )<br/>}<br/>\u00a0<br/>macro_rules! op {<br/>    ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; (<br/>        fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {<br/>            assert_equal_len!(xs, ys, $func, $op);<br/>\u00a0<br/>            for (x, y) in xs.iter_mut().zip(ys.iter()) {<br/>                *x = $bound::$method(*x, *y);<br/>                // *x = x.$method(*y);<br/>            }<br/>        }<br/>    )<br/>}<br/>\u00a0<br/>// Implement `add_assign`, `mul_assign`, and `sub_assign` functions.<br/>op!(add_assign, Add, +=, add);<br/>op!(mul_assign, Mul, *=, mul);<br/>op!(sub_assign, Sub, -=, sub);<br/>\u00a0<br/>mod test {<br/>    use std::iter;<br/>    macro_rules! test {<br/>        ($func: ident, $x:expr, $y:expr, $z:expr) =&gt; {<br/>            #[test]<br/>            fn $func() {<br/>                for size in 0usize..10 {<br/>                    let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();<br/>                    let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();<br/>                    let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();<br/>\u00a0<br/>                    super::$func(&amp;mut x, &amp;y);<br/>\u00a0<br/>                    assert_eq!(x, z);<br/>                }<br/>            }<br/>        }<br/>    }<br/>\u00a0<br/>    // Test `add_assign`, `mul_assign` and `sub_assign`<br/>    test!(add_assign, 1u32, 2u32, 3u32);<br/>    test!(mul_assign, 2u32, 3u32, 6u32);<br/>    test!(sub_assign, 3u32, 2u32, 1u32);<br/>}</pre>"}, {"lang": "Scala", "loc": 11, "block": "<pre class=\"scala highlighted_source\"><a href=\"http://scala-lang.org\"><span class=\"kw1\">import</span></a> scala.<span class=\"me1\">language</span>.<span class=\"me1\">experimental</span>.<span class=\"me1\">macros</span><br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">import</span></a> scala.<span class=\"me1\">reflect</span>.<span class=\"me1\">macros</span>.<span class=\"me1\">Context</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">object</span></a> Macros <span class=\"br0\">{</span><br/>  <a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> impl<span class=\"br0\">(</span>c<span class=\"sy0\">:</span> Context<span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">import</span></a> c.<span class=\"me1\">universe</span>.<span class=\"sy0\">_</span><br/>    c.<span class=\"me1\">Expr</span><span class=\"br0\">[</span>Unit<span class=\"br0\">]</span><span class=\"br0\">(</span>q<span class=\"st0\">\"\"</span><span class=\"st0\">\"println(\"</span>Hello World<span class=\"st0\">\")\"</span><span class=\"st0\">\"\"</span><span class=\"br0\">)</span><br/>  <span class=\"br0\">}</span><br/>\u00a0<br/>  <a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> hello<span class=\"sy0\">:</span> Unit <span class=\"sy0\">=</span> macro impl<br/><span class=\"br0\">}</span></pre>"}, {"lang": "SNOBOL4", "loc": 4, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>        OPSYN('SAME','IDENT')<br/>        OPSYN('$','*',1)<br/>\u00a0</pre>"}, {"lang": "Shen", "loc": 8, "block": "<pre class=\"text highlighted_source\">(define make-list<br/>  [A|D] -&gt; [cons (make-list A) (make-list D)]<br/>  X -&gt; X)<br/>\u00a0<br/>(defmacro info-macro<br/>  [info Exp] -&gt; [output \"~A: ~A~%\" (make-list Exp) Exp])<br/>\u00a0<br/>(info (* 5 6)) \\\\ outputs [* 5 6]: 30</pre>"}, {"lang": "Sidef", "loc": 7, "block": "<pre class=\"ruby highlighted_source\"><span class=\"kw1\">class</span> Number <span class=\"br0\">{</span><br/>    method \u2295<span class=\"br0\">(</span>arg<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw2\">self</span> <span class=\"sy0\">+</span> arg<br/>    <span class=\"br0\">}</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/>say <span class=\"br0\">(</span><span class=\"nu0\">21</span> \u2295 <span class=\"nu0\">42</span><span class=\"br0\">)</span></pre>"}, {"lang": "Tcl", "loc": 14, "block": "<pre class=\"tcl highlighted_source\"><span class=\"kw1\">proc</span> loopVar <span class=\"br0\">{</span>var from lower to upper script<span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>    <span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"re0\">$from</span> ne <span class=\"st0\">\"from\"</span> || <span class=\"re0\">$to</span> ne <span class=\"st0\">\"to\"</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><span class=\"kw1\">error</span> <span class=\"st0\">\"syntax error\"</span><span class=\"br0\">}</span><br/>    <span class=\"kw1\">upvar</span> <span class=\"nu0\">1</span> <span class=\"re0\">$var</span> v<br/>    <span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"re0\">$lower</span> <span class=\"sy0\">&lt;</span>= <span class=\"re0\">$upper</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">for</span> <span class=\"br0\">{</span><span class=\"kw1\">set</span> v <span class=\"re0\">$lower</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><span class=\"re0\">$v</span> <span class=\"sy0\">&lt;</span>= <span class=\"re0\">$upper</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><span class=\"kw2\">incr</span> v<span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">uplevel</span> <span class=\"nu0\">1</span> <span class=\"re0\">$script</span><br/>        <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span> <span class=\"kw1\">else</span> <span class=\"br0\">{</span><br/>        <span class=\"co1\"># $upper and $lower really the other way round here</span><br/>        <span class=\"kw1\">for</span> <span class=\"br0\">{</span><span class=\"kw1\">set</span> v <span class=\"re0\">$lower</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><span class=\"re0\">$v</span> <span class=\"sy0\">&gt;</span>= <span class=\"re0\">$upper</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><span class=\"kw2\">incr</span> v -<span class=\"nu0\">1</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">uplevel</span> <span class=\"nu0\">1</span> <span class=\"re0\">$script</span><br/>        <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "TXR", "loc": 26, "block": "<pre class=\"text highlighted_source\">(defmacro whil ((condition\u00a0: result) . body)<br/>  (let ((cblk (gensym \"cnt-blk-\"))<br/>        (bblk (gensym \"brk-blk-\")))<br/>    ^(macrolet ((break (value) ^(return-from ,',bblk ,value)))<br/>       (symacrolet ((break (return-from ,bblk))<br/>                    (continue (return-from ,cblk)))<br/>         (block ,bblk<br/>           (for () (,condition ,result) ()<br/>             (block ,cblk ,*body)))))))<br/>\u00a0<br/>(let ((i 0))<br/>  (whil ((&lt; i 100))<br/>    (if (&lt; (inc i) 20)<br/>      continue)<br/>    (if (&gt; i 30)<br/>      break)<br/>    (prinl i)))<br/>\u00a0<br/>(prinl<br/>  (sys:expand<br/>    '(whil ((&lt; i 100))<br/>       (if (&lt; (inc i) 20)<br/>         continue)<br/>       (if (&gt; i 30)<br/>         break)<br/>       (prinl i))))</pre>"}, {"lang": "zkl", "loc": 3, "block": "<pre class=\"text highlighted_source\">#define name [0|1]<br/>#if [0|1|name]<br/>#else, #endif</pre>"}]}