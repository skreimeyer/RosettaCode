{"task": "Arena_storage_pool", "blocks": [{"lang": "Ada", "loc": 2, "block": "<pre class=\"ada highlighted_source\"><span class=\"kw3\">type</span> My_Pointer <span class=\"kw1\">is</span> <span class=\"kw3\">access</span> My_Object;<br/><span class=\"kw1\">for</span> My_Pointer'Storage_Pool <span class=\"kw3\">use</span> My_Pool;</pre>"}, {"lang": "C", "loc": 1, "block": "<pre class=\"c highlighted_source\"><span class=\"co2\">#include &lt;stdlib.h&gt;</span></pre>"}, {"lang": "C++", "loc": 1, "block": "<pre class=\"cpp highlighted_source\">T<span class=\"sy2\">*</span> foo <span class=\"sy1\">=</span> <span class=\"kw3\">new</span><span class=\"br0\">(</span>arena<span class=\"br0\">)</span> T<span class=\"sy4\">;</span></pre>"}, {"lang": "Erlang", "loc": 32, "block": "<pre class=\"erlang highlighted_source\">\u00a0<br/><span class=\"sy3\">-</span><span class=\"re2\">module</span><span class=\"br0\">(</span> arena_storage_pool <span class=\"br0\">)</span><span class=\"sy1\">.</span><br/>\u00a0<br/><span class=\"sy3\">-</span><span class=\"re2\">export</span><span class=\"br0\">(</span> <span class=\"br0\">[</span>task<span class=\"sy3\">/</span><span class=\"nu0\">0</span><span class=\"br0\">]</span> <span class=\"br0\">)</span><span class=\"sy1\">.</span><br/>\u00a0<br/><span class=\"re3\">task</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy1\">-&gt;</span><br/>      <span class=\"re5\">Pid</span> <span class=\"sy3\">=</span> <a href=\"http://erlang.org/doc/man/erlang.html\"><span class=\"kw5\">erlang</span></a>:<span class=\"kw3\">spawn</span>_<span class=\"re3\">opt</span><span class=\"br0\">(</span> <span class=\"kw1\">fun</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy1\">-&gt;</span> <span class=\"re3\">loop</span><span class=\"br0\">(</span><span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"br0\">)</span> <span class=\"kw1\">end</span><span class=\"sy1\">,</span> <span class=\"br0\">[</span><span class=\"br0\">{</span>min_heap_size<span class=\"sy1\">,</span> <span class=\"nu0\">10000</span><span class=\"br0\">}</span><span class=\"br0\">]</span> <span class=\"br0\">)</span><span class=\"sy1\">,</span><br/>      <span class=\"re3\">set</span><span class=\"br0\">(</span> <span class=\"re5\">Pid</span><span class=\"sy1\">,</span> <span class=\"nu0\">1</span><span class=\"sy1\">,</span> ett <span class=\"br0\">)</span><span class=\"sy1\">,</span><br/>      <span class=\"re3\">set</span><span class=\"br0\">(</span> <span class=\"re5\">Pid</span><span class=\"sy1\">,</span> <span class=\"st0\">\"kalle\"</span><span class=\"sy1\">,</span> <span class=\"st0\">\"hobbe\"</span> <span class=\"br0\">)</span><span class=\"sy1\">,</span><br/>      <span class=\"re5\">V1</span> <span class=\"sy3\">=</span> <span class=\"kw3\">get</span><span class=\"br0\">(</span> <span class=\"re5\">Pid</span><span class=\"sy1\">,</span> <span class=\"nu0\">1</span> <span class=\"br0\">)</span><span class=\"sy1\">,</span><br/>      <span class=\"re5\">V2</span> <span class=\"sy3\">=</span> <span class=\"kw3\">get</span><span class=\"br0\">(</span> <span class=\"re5\">Pid</span><span class=\"sy1\">,</span> <span class=\"st0\">\"kalle\"</span> <span class=\"br0\">)</span><span class=\"sy1\">,</span><br/>      true <span class=\"sy3\">=</span> <span class=\"br0\">(</span><span class=\"re5\">V1</span> <span class=\"sy3\">=:=</span> ett<span class=\"br0\">)</span> <span class=\"kw2\">and</span> <span class=\"br0\">(</span><span class=\"re5\">V2</span>\t<span class=\"sy3\">=:=</span> <span class=\"st0\">\"hobbe\"</span><span class=\"br0\">)</span><span class=\"sy1\">,</span><br/>      <a href=\"http://erlang.org/doc/man/erlang.html\"><span class=\"kw5\">erlang</span></a>:<span class=\"kw3\">exit</span><span class=\"br0\">(</span> <span class=\"re5\">Pid</span><span class=\"sy1\">,</span> normal <span class=\"br0\">)</span><span class=\"sy1\">.</span><br/>\u00a0<br/>\u00a0<br/>\u00a0<br/><span class=\"kw3\">get</span><span class=\"br0\">(</span> <span class=\"re5\">Pid</span><span class=\"sy1\">,</span> <span class=\"re5\">Key</span> <span class=\"br0\">)</span> <span class=\"sy1\">-&gt;</span><br/>     <span class=\"re5\">Pid</span> <span class=\"sy3\">!</span> <span class=\"br0\">{</span><span class=\"kw3\">get</span><span class=\"sy1\">,</span> <span class=\"re5\">Key</span><span class=\"sy1\">,</span> <a href=\"http://erlang.org/doc/man/erlang.html\"><span class=\"kw5\">erlang</span></a>:<span class=\"kw3\">self</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">}</span><span class=\"sy1\">,</span><br/>     <span class=\"kw1\">receive</span><br/>\t<span class=\"br0\">{</span>value<span class=\"sy1\">,</span> <span class=\"re5\">Value</span><span class=\"sy1\">,</span> <span class=\"re5\">Pid</span><span class=\"br0\">}</span> <span class=\"sy1\">-&gt;</span> <span class=\"re5\">Value</span><br/>     <span class=\"kw1\">end</span><span class=\"sy1\">.</span><br/>\u00a0<br/><span class=\"re3\">loop</span><span class=\"br0\">(</span> <span class=\"re5\">List</span> <span class=\"br0\">)</span> <span class=\"sy1\">-&gt;</span><br/>      <span class=\"kw1\">receive</span><br/>\t<span class=\"br0\">{</span>set<span class=\"sy1\">,</span> <span class=\"re5\">Key</span><span class=\"sy1\">,</span> <span class=\"re5\">Value</span><span class=\"br0\">}</span> <span class=\"sy1\">-&gt;</span> <span class=\"re3\">loop</span><span class=\"br0\">(</span> <span class=\"br0\">[</span><span class=\"br0\">{</span><span class=\"re5\">Key</span><span class=\"sy1\">,</span> <span class=\"re5\">Value</span><span class=\"br0\">}</span> | <a href=\"http://erlang.org/doc/man/proplists.html\"><span class=\"kw5\">proplists</span></a>:<span class=\"re3\">delete</span><span class=\"br0\">(</span><span class=\"re5\">Key</span><span class=\"sy1\">,</span> <span class=\"re5\">List</span><span class=\"br0\">)</span><span class=\"br0\">]</span> <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>\t<span class=\"br0\">{</span><span class=\"kw3\">get</span><span class=\"sy1\">,</span> <span class=\"re5\">Key</span><span class=\"sy1\">,</span> <span class=\"re5\">Pid</span><span class=\"br0\">}</span> <span class=\"sy1\">-&gt;</span><br/>\t      <span class=\"re5\">Pid</span> <span class=\"sy3\">!</span> <span class=\"br0\">{</span>value<span class=\"sy1\">,</span> <a href=\"http://erlang.org/doc/man/proplists.html\"><span class=\"kw5\">proplists</span></a>:<span class=\"kw3\">get</span>_<span class=\"re3\">value</span><span class=\"br0\">(</span><span class=\"re5\">Key</span><span class=\"sy1\">,</span> <span class=\"re5\">List</span><span class=\"br0\">)</span><span class=\"sy1\">,</span> <a href=\"http://erlang.org/doc/man/erlang.html\"><span class=\"kw5\">erlang</span></a>:<span class=\"kw3\">self</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">}</span><span class=\"sy1\">,</span><br/>\t      <span class=\"re3\">loop</span><span class=\"br0\">(</span> <span class=\"re5\">List</span> <span class=\"br0\">)</span><br/>\t<span class=\"kw1\">end</span><span class=\"sy1\">.</span>    <br/>\u00a0<br/><span class=\"re3\">set</span><span class=\"br0\">(</span> <span class=\"re5\">Pid</span><span class=\"sy1\">,</span> <span class=\"re5\">Key</span><span class=\"sy1\">,</span> <span class=\"re5\">Value</span> <span class=\"br0\">)</span> <span class=\"sy1\">-&gt;</span> <span class=\"re5\">Pid</span> <span class=\"sy3\">!</span> <span class=\"br0\">{</span>set<span class=\"sy1\">,</span> <span class=\"re5\">Key</span><span class=\"sy1\">,</span> <span class=\"re5\">Value</span><span class=\"br0\">}</span><span class=\"sy1\">.</span><br/>\u00a0</pre>"}, {"lang": "Fortran", "loc": 13, "block": "<pre class=\"fortran highlighted_source\">      <span class=\"kw1\">SUBROUTINE</span> CHECK<span class=\"br0\">(</span>A,N<span class=\"br0\">)</span>\t<span class=\"co1\">!Inspect matrix A.</span><br/>       <span class=\"kw3\">REAL</span> A<span class=\"br0\">(</span><span class=\"sy0\">:</span>,<span class=\"sy0\">:</span><span class=\"br0\">)</span>\t<span class=\"co1\">!The matrix, whatever size it is.</span><br/>       <span class=\"kw3\">INTEGER</span> N\t<span class=\"co1\">!The order.</span><br/>       <span class=\"kw3\">REAL</span> B<span class=\"br0\">(</span>N,N<span class=\"br0\">)</span>\t<span class=\"co1\">!A scratchpad, size known on entry..</span><br/>       <span class=\"kw3\">INTEGER</span>, <span class=\"kw3\">ALLOCATABLE</span><span class=\"sy0\">::</span><span class=\"me2\">TROUBLE</span><span class=\"br0\">(</span><span class=\"sy0\">:</span><span class=\"br0\">)</span>\t<span class=\"co1\">!But for this, I'll decide later.</span><br/>       <span class=\"kw3\">INTEGER</span> M<br/>\u00a0<br/>        M <span class=\"sy0\">=</span> <span class=\"kw4\">COUNT</span><span class=\"br0\">(</span>A<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">:</span>N,<span class=\"nu0\">1</span><span class=\"sy0\">:</span>N<span class=\"br0\">)</span>.<span class=\"me1\">LE</span>.0<span class=\"br0\">)</span>\t<span class=\"co1\">!Some maximum number of troublemakers.</span><br/>\u00a0<br/>        <span class=\"kw1\">ALLOCATE</span> <span class=\"br0\">(</span>TROUBLE<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">:</span>M<span class=\"sy0\">**</span><span class=\"nu0\">3</span><span class=\"br0\">)</span><span class=\"br0\">)</span>\t<span class=\"co1\">!Just enough.</span><br/>\u00a0<br/>        <span class=\"kw1\">DEALLOCATE</span><span class=\"br0\">(</span>TROUBLE<span class=\"br0\">)</span>\t\t<span class=\"co1\">!Not necessary.</span><br/>      <span class=\"kw1\">END</span> <span class=\"kw1\">SUBROUTINE</span> CHECK\t\t<span class=\"co1\">!As TROUBLE is declared within CHECK.</span></pre>"}, {"lang": "Go", "loc": 56, "block": "<pre class=\"go highlighted_source\"><span class=\"kw1\">package</span> main<br/>\u00a0<br/><span class=\"kw1\">import</span> <span class=\"sy1\">(</span><br/>    <span class=\"st0\">\"fmt\"</span><br/>    <span class=\"st0\">\"runtime\"</span><br/>    <span class=\"st0\">\"sync\"</span><br/><span class=\"sy1\">)</span><br/>\u00a0<br/><span class=\"co1\">// New to Go 1.3 are sync.Pools, basically goroutine-safe free lists.</span><br/><span class=\"co1\">// There is overhead in the goroutine-safety and if you do not need this</span><br/><span class=\"co1\">// you might do better by implementing your own free list.</span><br/>\u00a0<br/><span class=\"kw4\">func</span> main<span class=\"sy1\">()</span> <span class=\"sy1\">{</span><br/>    <span class=\"co1\">// Task 1:  Define a pool (of ints).  Just as the task says, a sync.Pool</span><br/>    <span class=\"co1\">// allocates individually and can free as a group.</span><br/>    p <span class=\"sy2\">:=</span> sync<span class=\"sy3\">.</span>Pool<span class=\"sy1\">{</span>New<span class=\"sy1\">:</span> <span class=\"kw4\">func</span><span class=\"sy1\">()</span> <span class=\"kw4\">interface</span><span class=\"sy1\">{}</span> <span class=\"sy1\">{</span><br/>        fmt<span class=\"sy3\">.</span>Println<span class=\"sy1\">(</span><span class=\"st0\">\"pool empty\"</span><span class=\"sy1\">)</span><br/>        <span class=\"kw1\">return</span> <span class=\"kw3\">new</span><span class=\"sy1\">(</span><span class=\"kw4\">int</span><span class=\"sy1\">)</span><br/>    <span class=\"sy1\">}}</span><br/>    <span class=\"co1\">// Task 2: Allocate some ints.</span><br/>    <span class=\"nu2\">i</span> <span class=\"sy2\">:=</span> <span class=\"kw3\">new</span><span class=\"sy1\">(</span><span class=\"kw4\">int</span><span class=\"sy1\">)</span><br/>    j <span class=\"sy2\">:=</span> <span class=\"kw3\">new</span><span class=\"sy1\">(</span><span class=\"kw4\">int</span><span class=\"sy1\">)</span><br/>    <span class=\"co1\">// Show that they're usable.</span><br/>    <span class=\"sy3\">*</span><span class=\"nu2\">i</span> <span class=\"sy2\">=</span> <span class=\"nu0\">1</span><br/>    <span class=\"sy3\">*</span>j <span class=\"sy2\">=</span> <span class=\"nu0\">2</span><br/>    fmt<span class=\"sy3\">.</span>Println<span class=\"sy1\">(</span><span class=\"sy3\">*</span><span class=\"nu2\">i</span> <span class=\"sy3\">+</span> <span class=\"sy3\">*</span>j<span class=\"sy1\">)</span> <span class=\"co1\">// prints 3</span><br/>    <span class=\"co1\">// Task 2 continued:  Put allocated ints in pool p.</span><br/>    <span class=\"co1\">// Task explanation:  Variable p has a pool as its value.  Another pool</span><br/>    <span class=\"co1\">// could be be created and assigned to a different variable.  You choose</span><br/>    <span class=\"co1\">// a pool simply by using the appropriate variable, p here.</span><br/>    p<span class=\"sy3\">.</span><span class=\"me1\">Put</span><span class=\"sy1\">(</span>i<span class=\"sy1\">)</span><br/>    p<span class=\"sy3\">.</span><span class=\"me1\">Put</span><span class=\"sy1\">(</span>j<span class=\"sy1\">)</span><br/>    <span class=\"co1\">// Drop references to i and j.  This allows them to be garbage collected;</span><br/>    <span class=\"co1\">// that is, freed as a group.</span><br/>    <span class=\"nu2\">i</span> <span class=\"sy2\">=</span> <span class=\"kw2\">nil</span><br/>    j <span class=\"sy2\">=</span> <span class=\"kw2\">nil</span><br/>    <span class=\"co1\">// Get ints for i and j again, this time from the pool.  P.Get may reuse</span><br/>    <span class=\"co1\">// an object allocated above as long as objects haven't been garbage</span><br/>    <span class=\"co1\">// collected yet; otherwise p.Get will allocate a new object.</span><br/>    <span class=\"nu2\">i</span> <span class=\"sy2\">=</span> p<span class=\"sy3\">.</span>Get<span class=\"sy1\">()</span><span class=\"sy3\">.</span><span class=\"sy1\">(</span><span class=\"sy3\">*</span><span class=\"kw4\">int</span><span class=\"sy1\">)</span><br/>    j <span class=\"sy2\">=</span> p<span class=\"sy3\">.</span>Get<span class=\"sy1\">()</span><span class=\"sy3\">.</span><span class=\"sy1\">(</span><span class=\"sy3\">*</span><span class=\"kw4\">int</span><span class=\"sy1\">)</span><br/>    <span class=\"sy3\">*</span><span class=\"nu2\">i</span> <span class=\"sy2\">=</span> <span class=\"nu0\">4</span><br/>    <span class=\"sy3\">*</span>j <span class=\"sy2\">=</span> <span class=\"nu0\">5</span><br/>    fmt<span class=\"sy3\">.</span>Println<span class=\"sy1\">(</span><span class=\"sy3\">*</span><span class=\"nu2\">i</span> <span class=\"sy3\">+</span> <span class=\"sy3\">*</span>j<span class=\"sy1\">)</span> <span class=\"co1\">// prints 9</span><br/>    <span class=\"co1\">// One more test, this time forcing a garbage collection.</span><br/>    p<span class=\"sy3\">.</span>Put<span class=\"sy1\">(</span><span class=\"nu2\">i</span><span class=\"sy1\">)</span><br/>    p<span class=\"sy3\">.</span>Put<span class=\"sy1\">(</span>j<span class=\"sy1\">)</span><br/>    <span class=\"nu2\">i</span> <span class=\"sy2\">=</span> <span class=\"kw2\">nil</span><br/>    j <span class=\"sy2\">=</span> <span class=\"kw2\">nil</span><br/>    runtime<span class=\"sy3\">.</span>GC<span class=\"sy1\">()</span><br/>    <span class=\"nu2\">i</span> <span class=\"sy2\">=</span> p<span class=\"sy3\">.</span>Get<span class=\"sy1\">()</span><span class=\"sy3\">.</span><span class=\"sy1\">(</span><span class=\"sy3\">*</span><span class=\"kw4\">int</span><span class=\"sy1\">)</span><br/>    j <span class=\"sy2\">=</span> p<span class=\"sy3\">.</span>Get<span class=\"sy1\">()</span><span class=\"sy3\">.</span><span class=\"sy1\">(</span><span class=\"sy3\">*</span><span class=\"kw4\">int</span><span class=\"sy1\">)</span><br/>    <span class=\"sy3\">*</span><span class=\"nu2\">i</span> <span class=\"sy2\">=</span> <span class=\"nu0\">7</span><br/>    <span class=\"sy3\">*</span>j <span class=\"sy2\">=</span> <span class=\"nu0\">8</span><br/>    fmt<span class=\"sy3\">.</span>Println<span class=\"sy1\">(</span><span class=\"sy3\">*</span><span class=\"nu2\">i</span> <span class=\"sy3\">+</span> <span class=\"sy3\">*</span>j<span class=\"sy1\">)</span> <span class=\"co1\">// prints 15</span><br/><span class=\"sy1\">}</span></pre>"}, {"lang": "J", "loc": 27, "block": "<pre class=\"j highlighted_source\">coclass <span class=\"st_h\">'integerPool'</span><br/>require <span class=\"st_h\">'jmf'</span><br/>create=: monad define<br/>  Lim=: <span class=\"kw2\">y</span>*SZI_jmf_<br/>  Next=: -SZI_jmf_<br/>  Pool=: mema Lim<br/><span class=\"sy0\">)</span><br/>\u00a0<br/>destroy=: monad define<br/>  memf Pool<br/>  codestroy<span class=\"st_h\">''</span><br/><span class=\"sy0\">)</span><br/>\u00a0<br/>alloc=: monad define<br/>  assert.Lim &gt;: Next=: Next+SZI_jmf_<br/>  r=.Pool,Next,<span class=\"nu0\">1</span>,JINT<br/>  r set <span class=\"kw2\">y</span><br/>  r<br/><span class=\"sy0\">)</span><br/>\u00a0<br/>get=: adverb define<br/>  memr <span class=\"kw2\">m</span><br/><span class=\"sy0\">)</span><br/>\u00a0<br/>set=: adverb define<br/>  <span class=\"kw2\">y</span> memw <span class=\"kw2\">m</span><br/><span class=\"sy0\">)</span></pre>"}, {"lang": "Julia", "loc": 5, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>matrix = zeros(Float64, (1000,1000,1000))<br/># use matrix, then when done set variable to 0 to garbage collect the matrix:<br/>matrix = 0 # large memory pool will now be collected when needed<br/>\u00a0</pre>"}, {"lang": "Kotlin", "loc": 14, "block": "<pre class=\"scala highlighted_source\"><span class=\"co1\">// Kotlin Native v0.5</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">import</span></a> kotlinx.<span class=\"me1\">cinterop</span>.<span class=\"sy0\">*</span><br/>\u00a0<br/>fun main<span class=\"br0\">(</span>args<span class=\"sy0\">:</span> Array<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    memScoped <span class=\"br0\">{</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> intVar1 <span class=\"sy0\">=</span> alloc<span class=\"sy0\">&lt;</span>IntVar<span class=\"sy0\">&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>        intVar1.<span class=\"me1\">value</span> <span class=\"sy0\">=</span> <span class=\"nu0\">1</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> intVar2 <span class=\"sy0\">=</span> alloc<span class=\"sy0\">&lt;</span>IntVar<span class=\"sy0\">&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>        intVar2.<span class=\"me1\">value</span> <span class=\"sy0\">=</span> <span class=\"nu0\">2</span><br/>        println<span class=\"br0\">(</span><span class=\"st0\">\"${intVar1.value} + ${intVar2.value} = ${intVar1.value + intVar2.value}\"</span><span class=\"br0\">)</span><br/>    <span class=\"br0\">}</span> <br/>    <span class=\"co1\">// native memory used by intVar1 &amp; intVar2 is automatically freed when memScoped block ends</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Mathematica", "loc": 1, "block": "<pre class=\"text highlighted_source\">f[x_]\u00a0:= x^2</pre>"}, {"lang": "Oforth", "loc": 2, "block": "<pre class=\"text highlighted_source\">Object Class new: MyClass(a, b, c)<br/>MyClass new</pre>"}, {"lang": "ooRexx", "loc": 33, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>'==============<br/>Class ArenaPool<br/>'==============<br/>\u00a0<br/>string buf<br/>sys    pb,ii<br/>\u00a0<br/>method Setup(sys n) as sys {buf=nuls n\u00a0: pb=strptr buf\u00a0: ii=0\u00a0: return pb}<br/>method Alloc(sys n) as sys {method=pb+ii\u00a0: ii+=n}<br/>method Empty()             {buf=\"\"\u00a0: pb=0\u00a0: ii=0}<br/>\u00a0<br/>end class<br/>\u00a0<br/>macro Create(type,name,qty,pool)<br/>  type name[qty] at (pool##.alloc qty * sizeof type)<br/>end macro<br/>\u00a0<br/>'====<br/>'DEMO<br/>'====<br/>\u00a0<br/>ArenaPool pool\u00a0: pool.setup 1000 * sizeof int<br/>\u00a0<br/>Create int,i,100,pool<br/>Create int,j,100,pool<br/>\u00a0<br/>j[51] &lt;= 1,2,3,4,5<br/>\u00a0<br/>print j[51] j[52] j[53] j[54] j[55] 'result 15<br/>\u00a0<br/>pool.empty<br/>\u00a0</pre>"}, {"lang": "OxygenBasic", "loc": 33, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>'==============<br/>Class ArenaPool<br/>'==============<br/>\u00a0<br/>string buf<br/>sys    pb,ii<br/>\u00a0<br/>method Setup(sys n) as sys {buf=nuls n\u00a0: pb=strptr buf\u00a0: ii=0\u00a0: return pb}<br/>method Alloc(sys n) as sys {method=pb+ii\u00a0: ii+=n}<br/>method Empty()             {buf=\"\"\u00a0: pb=0\u00a0: ii=0}<br/>\u00a0<br/>end class<br/>\u00a0<br/>macro Create(type,name,qty,pool)<br/>  type name[qty] at (pool##.alloc qty * sizeof type)<br/>end macro<br/>\u00a0<br/>'====<br/>'DEMO<br/>'====<br/>\u00a0<br/>ArenaPool pool\u00a0: pool.setup 1000 * sizeof int<br/>\u00a0<br/>Create int,i,100,pool<br/>Create int,j,100,pool<br/>\u00a0<br/>j[51] &lt;= 1,2,3,4,5<br/>\u00a0<br/>print j[51] j[52] j[53] j[54] j[55] 'result 15<br/>\u00a0<br/>pool.empty<br/>\u00a0</pre>"}, {"lang": "PARI/GP", "loc": 3, "block": "<pre class=\"c highlighted_source\">pari_init<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">&lt;&lt;</span><span class=\"nu0\">20</span><span class=\"sy0\">,</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">// Initialize PARI with a stack size of 1 MB.</span><br/>GEN four <span class=\"sy0\">=</span> addii<span class=\"br0\">(</span>gen_2<span class=\"sy0\">,</span> gen_2<span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">// On the stack</span><br/>GEN persist <span class=\"sy0\">=</span> gclone<span class=\"br0\">(</span>four<span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">// On the heap</span></pre>"}, {"lang": "Pascal", "loc": 1, "block": "<pre class=\"pascal highlighted_source\"><span class=\"kw1\">procedure</span> <span class=\"kw3\">New</span> <span class=\"br0\">(</span><span class=\"kw1\">var</span> P<span class=\"sy1\">:</span> <span class=\"kw4\">Pointer</span><span class=\"br0\">)</span><span class=\"sy1\">;</span></pre>"}, {"lang": "Perl 6", "loc": 1, "block": "<pre class=\"text highlighted_source\">atom mem = allocate(size,true)</pre>"}, {"lang": "Phix", "loc": 1, "block": "<pre class=\"text highlighted_source\">atom mem = allocate(size,true)</pre>"}, {"lang": "PicoLisp", "loc": 11, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>(malloc 1000 'raw)            \u00a0; raw allocation, bypass the GC, requires free()-ing<br/>(malloc 1000 'uncollectable)  \u00a0; no GC, for use with other GCs that Racket can be configured with<br/>(malloc 1000 'atomic)         \u00a0; a block of memory without internal pointers<br/>(malloc 1000 'nonatomic)      \u00a0; a block of pointers<br/>(malloc 1000 'eternal)        \u00a0; uncollectable &amp; atomic, similar to raw malloc but no freeing<br/>(malloc 1000 'stubborn)       \u00a0; can be declared immutable when mutation is done<br/>(malloc 1000 'interior)       \u00a0; allocate an immovable block with possible pointers into it<br/>(malloc 1000 'atomic-interior)\u00a0; same for atomic chunks<br/>(malloc-immobile-cell v)      \u00a0; allocates a single cell that the GC will not move<br/>\u00a0</pre>"}, {"lang": "PL/I", "loc": 11, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>(malloc 1000 'raw)            \u00a0; raw allocation, bypass the GC, requires free()-ing<br/>(malloc 1000 'uncollectable)  \u00a0; no GC, for use with other GCs that Racket can be configured with<br/>(malloc 1000 'atomic)         \u00a0; a block of memory without internal pointers<br/>(malloc 1000 'nonatomic)      \u00a0; a block of pointers<br/>(malloc 1000 'eternal)        \u00a0; uncollectable &amp; atomic, similar to raw malloc but no freeing<br/>(malloc 1000 'stubborn)       \u00a0; can be declared immutable when mutation is done<br/>(malloc 1000 'interior)       \u00a0; allocate an immovable block with possible pointers into it<br/>(malloc 1000 'atomic-interior)\u00a0; same for atomic chunks<br/>(malloc-immobile-cell v)      \u00a0; allocates a single cell that the GC will not move<br/>\u00a0</pre>"}, {"lang": "Python", "loc": 11, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>(malloc 1000 'raw)            \u00a0; raw allocation, bypass the GC, requires free()-ing<br/>(malloc 1000 'uncollectable)  \u00a0; no GC, for use with other GCs that Racket can be configured with<br/>(malloc 1000 'atomic)         \u00a0; a block of memory without internal pointers<br/>(malloc 1000 'nonatomic)      \u00a0; a block of pointers<br/>(malloc 1000 'eternal)        \u00a0; uncollectable &amp; atomic, similar to raw malloc but no freeing<br/>(malloc 1000 'stubborn)       \u00a0; can be declared immutable when mutation is done<br/>(malloc 1000 'interior)       \u00a0; allocate an immovable block with possible pointers into it<br/>(malloc 1000 'atomic-interior)\u00a0; same for atomic chunks<br/>(malloc-immobile-cell v)      \u00a0; allocates a single cell that the GC will not move<br/>\u00a0</pre>"}, {"lang": "Racket", "loc": 11, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>(malloc 1000 'raw)            \u00a0; raw allocation, bypass the GC, requires free()-ing<br/>(malloc 1000 'uncollectable)  \u00a0; no GC, for use with other GCs that Racket can be configured with<br/>(malloc 1000 'atomic)         \u00a0; a block of memory without internal pointers<br/>(malloc 1000 'nonatomic)      \u00a0; a block of pointers<br/>(malloc 1000 'eternal)        \u00a0; uncollectable &amp; atomic, similar to raw malloc but no freeing<br/>(malloc 1000 'stubborn)       \u00a0; can be declared immutable when mutation is done<br/>(malloc 1000 'interior)       \u00a0; allocate an immovable block with possible pointers into it<br/>(malloc 1000 'atomic-interior)\u00a0; same for atomic chunks<br/>(malloc-immobile-cell v)      \u00a0; allocates a single cell that the GC will not move<br/>\u00a0</pre>"}, {"lang": "REXX", "loc": 11, "block": "<pre class=\"rexx highlighted_source\"><span class=\"coMULTI\">/*REXX doesn't have declarations/allocations of variables, */</span><br/><span class=\"coMULTI\">/*     but this is the closest to an allocation:           */</span><br/>\u00a0<br/>stemmed_array<span class=\"sy0\">.</span>= <span class=\"nu0\">0</span>    <span class=\"coMULTI\">/*any undefined element will have this value. */</span><br/>\u00a0<br/>stemmed_array<span class=\"sy0\">.</span>1    = <span class=\"st0\">'1st entry'</span><br/>stemmed_array<span class=\"sy0\">.</span>2    = <span class=\"st0\">'2nd entry'</span><br/>stemmed_array<span class=\"sy0\">.</span>6000 = <span class=\"nu0\">12</span> <span class=\"sy0\">**</span> <span class=\"nu0\">2</span><br/>stemmed_array<span class=\"sy0\">.</span>dog  = stemmed_array<span class=\"sy0\">.</span>6000 <span class=\"sy0\">/</span> <span class=\"nu0\">2</span><br/>\u00a0<br/><span class=\"kw1\">drop</span> stemmed_array<span class=\"sy0\">.</span></pre>"}, {"lang": "Rust", "loc": 27, "block": "<pre class=\"text highlighted_source\">#![feature(rustc_private)]<br/>\u00a0<br/>extern crate arena;<br/>\u00a0<br/>use arena::TypedArena;<br/>\u00a0<br/>fn main() {<br/>    // Memory is allocated using the default allocator (currently jemalloc).  The memory is<br/>    // allocated in chunks, and when one chunk is full another is allocated.  This ensures that<br/>    // references to an arena don't become invalid when the original chunk runs out of space.  The<br/>    // chunk size is configurable as an argument to TypedArena::with_capacity if necessary.<br/>    let arena = TypedArena::new();<br/>\u00a0<br/>    // The arena crate contains two types of arenas: TypedArena and Arena.  Arena is<br/>    // reflection-basd and slower, but can allocate objects of any type.  TypedArena is faster, and<br/>    // can allocate only objects of one type.  The type is determined by type inference--if you try<br/>    // to allocate an integer, then Rust's compiler knows it is an integer arena.<br/>    let v1 = arena.alloc(1i32);<br/>\u00a0<br/>    // TypedArena returns a mutable reference<br/>    let v2 = arena.alloc(3);<br/>    *v2 += 38;<br/>    println!(\"{}\", *v1 + *v2);<br/>\u00a0<br/>    // The arena's destructor is called as it goes out of scope, at which point it deallocates<br/>    // everything stored within it at once.<br/>}</pre>"}, {"lang": "Tcl", "loc": 81, "block": "<pre class=\"tcl highlighted_source\"><span class=\"kw2\">package</span> require Tcl <span class=\"nu0\">8.6</span><br/>oo::<span class=\"me1\">class</span> create Pool <span class=\"br0\">{</span><br/>    superclass oo::<span class=\"me1\">class</span><br/>    <span class=\"kw1\">variable</span> capacity pool busy<br/>    unexport create<br/>    constructor args <span class=\"br0\">{</span><br/>\tnext <span class=\"br0\">{</span><span class=\"sy0\">*</span><span class=\"br0\">}</span><span class=\"re0\">$args</span><br/>\t<span class=\"kw1\">set</span> capacity <span class=\"nu0\">100</span><br/>\t<span class=\"kw1\">set</span> pool <span class=\"br0\">[</span><span class=\"kw1\">set</span> busy <span class=\"br0\">{</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"kw1\">method</span> new <span class=\"br0\">{</span>args<span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t<span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"br0\">[</span><span class=\"kw2\">llength</span> <span class=\"re0\">$pool</span><span class=\"br0\">]</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t    <span class=\"kw1\">set</span> pool <span class=\"br0\">[</span>lassign <span class=\"re0\">$pool</span> obj<span class=\"br0\">]</span><br/>\t<span class=\"br0\">}</span> <span class=\"kw1\">else</span> <span class=\"br0\">{</span><br/>\t    <span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"br0\">[</span><span class=\"kw2\">llength</span> <span class=\"re0\">$busy</span><span class=\"br0\">]</span> <span class=\"sy0\">&gt;</span>= <span class=\"re0\">$capacity</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t\tthrow <span class=\"br0\">{</span>POOL CAPACITY<span class=\"br0\">}</span> <span class=\"st0\">\"exceeded capacity: $capacity\"</span><br/>\t    <span class=\"br0\">}</span><br/>\t    <span class=\"kw1\">set</span> obj <span class=\"br0\">[</span>next<span class=\"br0\">]</span><br/>\t    <span class=\"kw1\">set</span> newobj <span class=\"br0\">[</span><span class=\"kw1\">namespace</span> current<span class=\"br0\">]</span>::<span class=\"br0\">[</span><span class=\"kw1\">namespace</span> tail <span class=\"re0\">$obj</span><span class=\"br0\">]</span><br/>\t    <span class=\"kw1\">rename</span> <span class=\"re0\">$obj</span> <span class=\"re0\">$newobj</span><br/>\t    <span class=\"kw1\">set</span> obj <span class=\"re0\">$newobj</span><br/>\t<span class=\"br0\">}</span><br/>\ttry <span class=\"br0\">{</span><br/>\t    <span class=\"br0\">[</span><span class=\"kw2\">info</span> object <span class=\"kw1\">namespace</span> <span class=\"re0\">$obj</span><span class=\"br0\">]</span>::<span class=\"me1\">my</span> Init <span class=\"br0\">{</span><span class=\"sy0\">*</span><span class=\"br0\">}</span><span class=\"re0\">$args</span><br/>\t<span class=\"br0\">}</span> on <span class=\"kw1\">error</span> <span class=\"br0\">{</span>msg opt<span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t    <span class=\"kw2\">lappend</span> pool <span class=\"re0\">$obj</span><br/>\t    <span class=\"kw1\">return</span> -options <span class=\"re0\">$opt</span> <span class=\"re0\">$msg</span><br/>\t<span class=\"br0\">}</span><br/>\t<span class=\"kw2\">lappend</span> busy <span class=\"re0\">$obj</span><br/>\t<span class=\"kw1\">return</span> <span class=\"re0\">$obj</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"kw1\">method</span> ReturnToPool obj <span class=\"br0\">{</span><br/>\ttry <span class=\"br0\">{</span><br/>\t    <span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"st0\">\"Finalize\"</span> <span class=\"kw1\">in</span> <span class=\"br0\">[</span><span class=\"kw2\">info</span> object methods <span class=\"re0\">$obj</span> -all -private<span class=\"br0\">]</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t\t<span class=\"br0\">[</span><span class=\"kw2\">info</span> object <span class=\"kw1\">namespace</span> <span class=\"re0\">$obj</span><span class=\"br0\">]</span>::<span class=\"me1\">my</span> Finalize<br/>\t    <span class=\"br0\">}</span><br/>\t<span class=\"br0\">}</span> on <span class=\"kw1\">error</span> <span class=\"br0\">{</span>msg opt<span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t    after <span class=\"nu0\">0</span> <span class=\"br0\">[</span><span class=\"kw2\">list</span> <span class=\"kw1\">return</span> -options <span class=\"re0\">$opt</span> <span class=\"re0\">$msg</span><span class=\"br0\">]</span><br/>\t    <span class=\"kw1\">return</span> false<br/>\t<span class=\"br0\">}</span><br/>\t<span class=\"kw1\">set</span> idx <span class=\"br0\">[</span><span class=\"kw2\">lsearch</span> -exact <span class=\"re0\">$busy</span> <span class=\"re0\">$obj</span><span class=\"br0\">]</span><br/>\t<span class=\"kw1\">set</span> busy <span class=\"br0\">[</span><span class=\"kw2\">lreplace</span> <span class=\"re0\">$busy</span> <span class=\"re0\">$idx</span> <span class=\"re0\">$idx</span><span class=\"br0\">]</span><br/>\t<span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"br0\">[</span><span class=\"kw2\">llength</span> <span class=\"re0\">$pool</span><span class=\"br0\">]</span> + <span class=\"br0\">[</span><span class=\"kw2\">llength</span> <span class=\"re0\">$busy</span><span class=\"br0\">]</span> + <span class=\"nu0\">1</span> <span class=\"sy0\">&lt;</span>= <span class=\"re0\">$capacity</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t    <span class=\"kw2\">lappend</span> pool <span class=\"re0\">$obj</span><br/>\t    <span class=\"kw1\">return</span> true<br/>\t<span class=\"br0\">}</span> <span class=\"kw1\">else</span> <span class=\"br0\">{</span><br/>\t    <span class=\"kw1\">return</span> false<br/>\t<span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"kw1\">method</span> capacity <span class=\"br0\">{</span><span class=\"br0\">{</span>value <span class=\"br0\">{</span><span class=\"br0\">}</span><span class=\"br0\">}</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t<span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"br0\">[</span><span class=\"kw2\">llength</span> <span class=\"br0\">[</span><span class=\"kw2\">info</span> level <span class=\"nu0\">0</span><span class=\"br0\">]</span><span class=\"br0\">]</span> == <span class=\"nu0\">3</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t    <span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"re0\">$value</span> <span class=\"sy0\">&lt;</span> <span class=\"re0\">$capacity</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t\t<span class=\"kw1\">while</span> <span class=\"br0\">{</span><span class=\"br0\">[</span><span class=\"kw2\">llength</span> <span class=\"re0\">$pool</span><span class=\"br0\">]</span> <span class=\"sy0\">&gt;</span> <span class=\"nu0\">0</span> <span class=\"sy0\">&amp;&amp;</span> <span class=\"br0\">[</span><span class=\"kw2\">llength</span> <span class=\"re0\">$pool</span><span class=\"br0\">]</span> + <span class=\"br0\">[</span><span class=\"kw2\">llength</span> <span class=\"re0\">$busy</span><span class=\"br0\">]</span> <span class=\"sy0\">&gt;</span> <span class=\"re0\">$value</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t\t    <span class=\"kw1\">set</span> pool <span class=\"br0\">[</span>lassign <span class=\"re0\">$pool</span> obj<span class=\"br0\">]</span><br/>\t\t    <span class=\"kw1\">rename</span> <span class=\"re0\">$obj</span> <span class=\"br0\">{</span><span class=\"br0\">}</span><br/>\t\t<span class=\"br0\">}</span><br/>\t    <span class=\"br0\">}</span><br/>\t    <span class=\"kw1\">set</span> capacity <span class=\"br0\">[</span><span class=\"kw1\">expr</span> <span class=\"br0\">{</span><span class=\"re0\">$value</span> <span class=\"sy0\">&gt;&gt;</span> <span class=\"nu0\">0</span><span class=\"br0\">}</span><span class=\"br0\">]</span><br/>\t<span class=\"br0\">}</span> <span class=\"kw1\">else</span> <span class=\"br0\">{</span><br/>\t    <span class=\"kw1\">return</span> <span class=\"re0\">$capacity</span><br/>\t<span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"kw1\">method</span> clearPool <span class=\"br0\">{</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t<span class=\"kw1\">foreach</span> obj <span class=\"re0\">$busy</span> <span class=\"br0\">{</span><br/>\t    <span class=\"re0\">$obj</span> destroy<br/>\t<span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"kw1\">method</span> destroy <span class=\"br0\">{</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\tmy clearPool<br/>\tnext<br/>    <span class=\"br0\">}</span><br/>    self <span class=\"kw1\">method</span> create <span class=\"br0\">{</span>class <span class=\"br0\">{</span>definition <span class=\"br0\">{</span><span class=\"br0\">}</span><span class=\"br0\">}</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t<span class=\"kw1\">set</span> cls <span class=\"br0\">[</span>next <span class=\"re0\">$class</span> <span class=\"re0\">$definition</span><span class=\"br0\">]</span><br/>\too::<span class=\"me1\">define</span> <span class=\"re0\">$cls</span> <span class=\"kw1\">method</span> destroy <span class=\"br0\">{</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t    <span class=\"kw1\">if</span> <span class=\"br0\">{</span><span class=\"sy0\">!</span><span class=\"br0\">[</span><span class=\"br0\">[</span><span class=\"kw2\">info</span> object <span class=\"kw1\">namespace</span> <span class=\"br0\">[</span>self class<span class=\"br0\">]</span><span class=\"br0\">]</span>::<span class=\"me1\">my</span> ReturnToPool <span class=\"br0\">[</span>self<span class=\"br0\">]</span><span class=\"br0\">]</span><span class=\"br0\">}</span> <span class=\"br0\">{</span><br/>\t\tnext<br/>\t    <span class=\"br0\">}</span><br/>\t<span class=\"br0\">}</span><br/>\t<span class=\"kw1\">return</span> <span class=\"re0\">$cls</span><br/>    <span class=\"br0\">}</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "zkl", "loc": 3, "block": "<pre class=\"text highlighted_source\">var pool=List();  // pool could be any mutable container<br/>pool.append(Data(0,1234));   // allocate mem blob and add to pool<br/>pool=Void; // free the pool and everything in it.</pre>"}]}