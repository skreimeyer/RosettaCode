{"task": "Call_a_function", "blocks": [{"lang": "360 Assembly", "loc": 3, "block": "<pre class=\"text highlighted_source\">X        DS     F<br/>Y        DS     F<br/>Z        DS     F</pre>"}, {"lang": "ActionScript", "loc": 3, "block": "<pre class=\"actionscript highlighted_source\">  myfunction<span class=\"br0\">(</span><span class=\"br0\">)</span>;       <span class=\"coMULTI\">/* function with no arguments in statement context */</span><br/>  myfunction<span class=\"br0\">(</span><span class=\"nu0\">6</span>,b<span class=\"br0\">)</span>;    <span class=\"co1\">// function with two arguments in statement context</span><br/>  stringit<span class=\"br0\">(</span><span class=\"st0\">\"apples\"</span><span class=\"br0\">)</span>;    <span class=\"co1\">//function with a string argument</span></pre>"}, {"lang": "Ada", "loc": 1, "block": "<pre class=\"ada highlighted_source\">S: String\u00a0:= Ada.<span class=\"me1\">Text_IO</span>.<span class=\"me1\">Get_Line</span>;</pre>"}, {"lang": "ALGOL 68", "loc": 39, "block": "<pre class=\"algol68 highlighted_source\"><span class=\"coMULTI\"># Note functions and subroutines are called procedures (or PROCs) in Algol 68 #</span><br/><span class=\"coMULTI\"># A function called without arguments: #</span><br/>f<span class=\"sy1\">;</span><br/><span class=\"coMULTI\"># Algol 68 does not expect an empty parameter list for calls with no arguments, \"f()\" is a syntax error #</span><br/><span class=\"coMULTI\"># A function with a fixed number of arguments: #</span><br/>f<span class=\"br0\">(</span>1<span class=\"sy1\">,</span> x<span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>\u00a0<br/><span class=\"coMULTI\"># variable number of arguments: #</span><br/><span class=\"coMULTI\"># functions that accept an array as a parameter can effectively provide variable numbers of arguments #</span><br/><span class=\"coMULTI\"># a \"literal array\" (called a row-display in Algol 68) can be passed, as is often the case for the I/O #</span><br/><span class=\"coMULTI\"># functions - e.g.: #</span><br/><span class=\"kw22\">print</span><span class=\"br0\">(</span> <span class=\"br0\">(</span> <span class=\"st0\">\"the result is: \"</span><span class=\"sy1\">,</span> r<span class=\"sy1\">,</span> <span class=\"st0\">\" after \"</span><span class=\"sy1\">,</span> n<span class=\"sy1\">,</span> <span class=\"st0\">\" iterations\"</span><span class=\"sy1\">,</span> <span class=\"kw22\">newline</span> <span class=\"br0\">)</span> <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/><span class=\"coMULTI\"># the outer brackets indicate the parameters of print, the inner brackets indicates the contents are a \"literal array\" #</span><br/>\u00a0<br/><span class=\"coMULTI\"># ALGOL 68 does not support optional arguments, though in some cases an empty array could be passed to a function #</span><br/><span class=\"coMULTI\"># expecting an array, e.g.: #</span><br/>f<span class=\"br0\">(</span> <span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>\u00a0<br/><span class=\"coMULTI\"># named arguments - see the Algol 68 sample in: http://rosettacode.org/wiki/Named_parameters #</span><br/>\u00a0<br/><span class=\"coMULTI\"># In \"Talk:Call a function\" a statement context is explained as<br/>\"The function is used as an instruction (with a void context),<br/>rather than used within an expression.\"<br/>Based on that, the examples above are already in a statement context.<br/>Technically, when a function that returns other than VOID (i.e. is not a subroutine)<br/>is called in a statement context, the result of the call is \"voided\" i.e. discarded.<br/>If desired, this can be made explicit using a cast, e.g.: #</span><br/><span class=\"kw3\">VOID</span><span class=\"br0\">(</span>f<span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>\u00a0<br/><span class=\"coMULTI\"># A function's return value being used: #</span><br/>x <span class=\"sy1\">:=</span> f<span class=\"br0\">(</span>y<span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>\u00a0<br/><span class=\"coMULTI\"># There is no distinction between built-in functions and user-defined functions. #</span><br/>\u00a0<br/><span class=\"coMULTI\"># A subroutine is simply a function that returns VOID. #</span><br/>\u00a0<br/><span class=\"coMULTI\"># If the function is declared with argument(s) of mode REF MODE,<br/>then those arguments are being passed by reference. #</span><br/><span class=\"coMULTI\"># Technically, all parameters are passed by value, however the value of a REF MODE is a reference... #</span></pre>"}, {"lang": "ALGOL W", "loc": 38, "block": "<pre class=\"text highlighted_source\">% Note, in Algol W, functions are called procedures\u00a0%<br/>% calling a function with no parameters:\u00a0%<br/>f;<br/>\u00a0<br/>% calling a function with a fixed number of parameters\u00a0%<br/>g( 1, 2.3, \"4\" );<br/>\u00a0<br/>% Algol W does not support optional parameters in general, however constructors for records can\u00a0%<br/>% be called wither with parameters (one for each field in the record) or no parameters #<br/>\u00a0<br/>% Algol W does not support variable numbers of parameters, except for the built-in I/O functions #<br/>% Algol W does not support named arguments\u00a0%<br/>\u00a0<br/>% A function can be used in a statement context by calling it, as in the examples above\u00a0%<br/>\u00a0<br/>% First class context: A function can be passed as a parameter to another procedure, e.g.:\u00a0%<br/>v\u00a0:= integrate( sin, 0, 1 )<br/>% assuming a suitable definition of integrate\u00a0%<br/>% Algol W does not support functions returning functions\u00a0%<br/>\u00a0<br/>% obtaining the return value of a function: e.g.:\u00a0%<br/>v\u00a0:= g( x, y, z );<br/>\u00a0<br/>% There is no syntactic distinction between user-defined and built-in functions\u00a0%<br/>\u00a0<br/>% Subroutines and functions are both procedures, a subroutine is a procedure with no return type\u00a0%<br/>% (called a proper procedure in Algol W)\u00a0%<br/>% There is no syntactic distinction between a call to a function and a call to a subroutine\u00a0%<br/>% other than the context\u00a0%<br/>\u00a0<br/>% In Algol W, parameters are passed by value, result or value result. This must be stated in the\u00a0%<br/>% definition of the function/subroutine. Value parameters are passed by value, result and value result\u00a0%<br/>% are effectively passed by reference and assigned on function exit. Result parameters are \"out\" parameters\u00a0%<br/>% and value result parameters are \"in out\".\u00a0%<br/>% Algol W also has \"name\" parameters (not to be confused with named parameters). Functions with name\u00a0%<br/>% parameters are somewhat like macros\u00a0%<br/>\u00a0<br/>% Partial application is not possible in Algol W\u00a0%</pre>"}, {"lang": "AntLang", "loc": 1, "block": "<pre class=\"text highlighted_source\">2*2+9</pre>"}, {"lang": "ARM Assembly", "loc": 175, "block": "<pre class=\"arm highlighted_source\">\u00a0<br/>\u00a0<br/><span class=\"sy0\">/*</span> ARM assembly Raspberry PI  <span class=\"sy0\">*/</span><br/><span class=\"sy0\">/*</span>  program callfonct<span class=\"sy0\">.</span>s   <span class=\"sy0\">*/</span><br/>\u00a0<br/><span class=\"sy0\">/*</span> Constantes    <span class=\"sy0\">*/</span><br/><span class=\"sy0\">.</span>equ STDOUT<span class=\"sy0\">,</span> <span class=\"nu0\">1</span><br/><span class=\"sy0\">.</span>equ WRITE<span class=\"sy0\">,</span>  <span class=\"nu0\">4</span><br/><span class=\"sy0\">.</span>equ EXIT<span class=\"sy0\">,</span>   <span class=\"nu0\">1</span><br/>\u00a0<br/><span class=\"sy0\">/***********************/</span><br/><span class=\"sy0\">/*</span> Initialized data <span class=\"sy0\">*/</span><br/><span class=\"sy0\">/***********************/</span><br/><span class=\"sy0\">.</span>data<br/>szMessage<span class=\"sy0\">:</span>      <span class=\"sy0\">.</span>asciz <span class=\"st0\">\"Hello. \\n\"</span>       @ message<br/>szRetourLigne<span class=\"sy0\">:</span> <span class=\"sy0\">.</span>asciz <span class=\"st0\">\"\\n\"</span><br/>szMessResult<span class=\"sy0\">:</span>  <span class=\"sy0\">.</span>ascii <span class=\"st0\">\"Resultat\u00a0: \"</span>      @ message result<br/>sMessValeur<span class=\"sy0\">:</span>   <span class=\"sy0\">.</span>fill <span class=\"nu0\">12</span><span class=\"sy0\">,</span> <span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"st0\">' '</span><br/>                   <span class=\"sy0\">.</span>asciz <span class=\"st0\">\"\\n\"</span><br/><span class=\"sy0\">/***********************/</span>\t\t\t\t   <br/><span class=\"sy0\">/*</span> No Initialized data <span class=\"sy0\">*/</span><br/><span class=\"sy0\">/***********************/</span><br/><span class=\"sy0\">.</span>bss<br/>iValeur<span class=\"sy0\">:</span>  <span class=\"sy0\">.</span>skip  <span class=\"nu0\">4</span>     @ reserve <span class=\"nu0\">4</span> bytes in memory<br/>\u00a0<br/><span class=\"sy0\">.</span>text<br/><span class=\"sy0\">.</span>global main <br/>main<span class=\"sy0\">:</span><br/>    <span class=\"kw3\">ldr</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span>=szMessage          @ adresse of message  short program<br/>    <span class=\"kw7\">bl</span> affichageMess            @ call function with <span class=\"nu0\">1</span> parameter <span class=\"br0\">(</span><span class=\"kw35\">r0</span><span class=\"br0\">)</span><br/>\u00a0<br/>    @ call function with parameters in register<br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span>#<span class=\"nu0\">5</span><br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r1</span><span class=\"sy0\">,</span>#<span class=\"nu0\">10</span><br/>    <span class=\"kw7\">bl</span> fonction1            @ call function with <span class=\"nu0\">2</span> parameters <span class=\"br0\">(</span><span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r1</span><span class=\"br0\">)</span><br/>    <span class=\"kw3\">ldr</span> <span class=\"kw35\">r1</span><span class=\"sy0\">,</span>=sMessValeur                           @ result in <span class=\"kw35\">r0</span><br/>    <span class=\"kw7\">bl</span> conversion10S       @ call function with <span class=\"nu0\">2</span> parameter <span class=\"br0\">(</span><span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r1</span><span class=\"br0\">)</span><br/>    <span class=\"kw3\">ldr</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span>=szMessResult<br/>    <span class=\"kw7\">bl</span> affichageMess            @ call function with <span class=\"nu0\">1</span> parameter <span class=\"br0\">(</span><span class=\"kw35\">r0</span><span class=\"br0\">)</span><br/>\u00a0<br/>    @ call function with parameters on stack<br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span>#<span class=\"nu0\">5</span><br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r1</span><span class=\"sy0\">,</span>#<span class=\"nu0\">10</span><br/>    <span class=\"kw3\">push</span> <span class=\"br0\">{</span><span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r1</span><span class=\"br0\">}</span><br/>    <span class=\"kw7\">bl</span> fonction2            @ call function with <span class=\"nu0\">2</span> parameters on the stack<br/>                              @ result in <span class=\"kw35\">r0</span><br/>    <span class=\"kw3\">ldr</span> <span class=\"kw35\">r1</span><span class=\"sy0\">,</span>=sMessValeur                 <br/>    <span class=\"kw7\">bl</span> conversion10S       @ call function with <span class=\"nu0\">2</span> parameter <span class=\"br0\">(</span><span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r1</span><span class=\"br0\">)</span><br/>    <span class=\"kw3\">ldr</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span>=szMessResult<br/>    <span class=\"kw7\">bl</span> affichageMess            @ call function with <span class=\"nu0\">1</span> parameter <span class=\"br0\">(</span><span class=\"kw35\">r0</span><span class=\"br0\">)</span><br/>\u00a0<br/>\u00a0<br/> <span class=\"sy0\">/*</span> end of  program <span class=\"sy0\">*/</span><br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span> #<span class=\"nu0\">0</span>                  @ return code<br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r7</span><span class=\"sy0\">,</span> #EXIT              @ request to exit program<br/>    swi <span class=\"nu0\">0</span>                       @ perform the system call<br/>\u00a0<br/><span class=\"sy0\">/******************************************************************/</span><br/><span class=\"sy0\">/*</span>     call function parameter in register             <span class=\"sy0\">*/</span> <br/><span class=\"sy0\">/******************************************************************/</span><br/><span class=\"sy0\">/*</span> <span class=\"kw35\">r0</span> value one <span class=\"sy0\">*/</span><br/><span class=\"sy0\">/*</span> <span class=\"kw35\">r1</span> value two <span class=\"sy0\">*/</span><br/><span class=\"sy0\">/*</span> return in <span class=\"kw35\">r0</span> <span class=\"sy0\">*/</span><br/>fonction1<span class=\"sy0\">:</span><br/>    <span class=\"kw3\">push</span> <span class=\"br0\">{</span><span class=\"kw35\">fp</span><span class=\"sy0\">,</span><span class=\"kw35\">lr</span><span class=\"br0\">}</span>    <span class=\"sy0\">/*</span> save des  <span class=\"nu0\">2</span> registres <span class=\"sy0\">*/</span> <br/>    <span class=\"kw3\">push</span> <span class=\"br0\">{</span><span class=\"kw35\">r1</span><span class=\"sy0\">,</span><span class=\"kw35\">r2</span><span class=\"br0\">}</span>    <span class=\"sy0\">/*</span> save des autres registres <span class=\"sy0\">*/</span><br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r2</span><span class=\"sy0\">,</span>#<span class=\"nu0\">20</span><br/>    <span class=\"kw1\">mul</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r2</span><br/>    <span class=\"kw1\">add</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r1</span><br/>    <span class=\"kw3\">pop</span> <span class=\"br0\">{</span><span class=\"kw35\">r1</span><span class=\"sy0\">,</span><span class=\"kw35\">r2</span><span class=\"br0\">}</span>     <span class=\"sy0\">/*</span> restaur des autres registres <span class=\"sy0\">*/</span><br/>    <span class=\"kw3\">pop</span> <span class=\"br0\">{</span><span class=\"kw35\">fp</span><span class=\"sy0\">,</span><span class=\"kw35\">lr</span><span class=\"br0\">}</span>    <span class=\"sy0\">/*</span> restaur des  <span class=\"nu0\">2</span> registres <span class=\"sy0\">*/</span> <br/>    <span class=\"kw7\">bx</span> <span class=\"kw35\">lr</span>           <span class=\"sy0\">/*</span> retour procedure <span class=\"sy0\">*/</span>\t<br/>\u00a0<br/><span class=\"sy0\">/******************************************************************/</span><br/><span class=\"sy0\">/*</span>     call function parameter in the stack             <span class=\"sy0\">*/</span> <br/><span class=\"sy0\">/******************************************************************/</span><br/><span class=\"sy0\">/*</span> return in <span class=\"kw35\">r0</span> <span class=\"sy0\">*/</span><br/>fonction2<span class=\"sy0\">:</span><br/>    <span class=\"kw3\">push</span> <span class=\"br0\">{</span><span class=\"kw35\">fp</span><span class=\"sy0\">,</span><span class=\"kw35\">lr</span><span class=\"br0\">}</span>    <span class=\"sy0\">/*</span> save des  <span class=\"nu0\">2</span> registres <span class=\"sy0\">*/</span> <br/>    <span class=\"kw1\">add</span> <span class=\"kw35\">fp</span><span class=\"sy0\">,</span><span class=\"kw35\">sp</span><span class=\"sy0\">,</span>#<span class=\"nu0\">8</span>    <span class=\"sy0\">/*</span> address parameters in the stack<span class=\"sy0\">*/</span><br/>    <span class=\"kw3\">push</span> <span class=\"br0\">{</span><span class=\"kw35\">r1</span><span class=\"sy0\">,</span><span class=\"kw35\">r2</span><span class=\"br0\">}</span>    <span class=\"sy0\">/*</span> save des autres registres <span class=\"sy0\">*/</span><br/>    <span class=\"kw3\">ldr</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"br0\">[</span><span class=\"kw35\">fp</span><span class=\"br0\">]</span><br/>    <span class=\"kw3\">ldr</span> <span class=\"kw35\">r1</span><span class=\"sy0\">,</span><span class=\"br0\">[</span><span class=\"kw35\">fp</span><span class=\"sy0\">,</span>#<span class=\"nu0\">4</span><span class=\"br0\">]</span><br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r2</span><span class=\"sy0\">,</span>#<span class=\"sy0\">-</span><span class=\"nu0\">20</span><br/>    <span class=\"kw1\">mul</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r2</span><br/>    <span class=\"kw1\">add</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r1</span><br/>    <span class=\"kw3\">pop</span> <span class=\"br0\">{</span><span class=\"kw35\">r1</span><span class=\"sy0\">,</span><span class=\"kw35\">r2</span><span class=\"br0\">}</span>     <span class=\"sy0\">/*</span> restaur des autres registres <span class=\"sy0\">*/</span><br/>    <span class=\"kw3\">pop</span> <span class=\"br0\">{</span><span class=\"kw35\">fp</span><span class=\"sy0\">,</span><span class=\"kw35\">lr</span><span class=\"br0\">}</span>    <span class=\"sy0\">/*</span> restaur des  <span class=\"nu0\">2</span> registres <span class=\"sy0\">*/</span> <br/>    <span class=\"kw1\">add</span> <span class=\"kw35\">sp</span><span class=\"sy0\">,</span>#<span class=\"nu0\">8</span>      <span class=\"sy0\">/*</span> very important<span class=\"sy0\">,</span> for stack aligned <span class=\"sy0\">*/</span><br/>    <span class=\"kw7\">bx</span> <span class=\"kw35\">lr</span>          <span class=\"sy0\">/*</span> retour procedure <span class=\"sy0\">*/</span>\t<br/>\u00a0<br/><span class=\"sy0\">/******************************************************************/</span><br/><span class=\"sy0\">/*</span>     affichage des messages   avec calcul longueur              <span class=\"sy0\">*/</span> <br/><span class=\"sy0\">/******************************************************************/</span><br/><span class=\"sy0\">/*</span> <span class=\"kw35\">r0</span> contient l adresse du message <span class=\"sy0\">*/</span><br/>affichageMess<span class=\"sy0\">:</span><br/>    <span class=\"kw3\">push</span> <span class=\"br0\">{</span><span class=\"kw35\">fp</span><span class=\"sy0\">,</span><span class=\"kw35\">lr</span><span class=\"br0\">}</span>    <span class=\"sy0\">/*</span> save des  <span class=\"nu0\">2</span> registres <span class=\"sy0\">*/</span> <br/>    <span class=\"kw3\">push</span> <span class=\"br0\">{</span><span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r1</span><span class=\"sy0\">,</span><span class=\"kw35\">r2</span><span class=\"sy0\">,</span><span class=\"kw35\">r7</span><span class=\"br0\">}</span>    <span class=\"sy0\">/*</span> save des autres registres <span class=\"sy0\">*/</span><br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r2</span><span class=\"sy0\">,</span>#<span class=\"nu0\">0</span>   <span class=\"sy0\">/*</span> compteur longueur <span class=\"sy0\">*/</span><br/><span class=\"nu0\">1</span><span class=\"sy0\">:</span>       <span class=\"sy0\">/*</span>calcul de la longueur <span class=\"sy0\">*/</span><br/>    <span class=\"kw3\">ldrb</span> <span class=\"kw35\">r1</span><span class=\"sy0\">,</span><span class=\"br0\">[</span><span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r2</span><span class=\"br0\">]</span>  <span class=\"sy0\">/*</span> recup octet position debut <span class=\"sy0\">+</span> indice <span class=\"sy0\">*/</span><br/>    <span class=\"kw5\">cmp</span> <span class=\"kw35\">r1</span><span class=\"sy0\">,</span>#<span class=\"nu0\">0</span>       <span class=\"sy0\">/*</span> si <span class=\"nu0\">0</span> c est fini <span class=\"sy0\">*/</span><br/>    <span class=\"kw8\">beq</span> <span class=\"nu0\">1f</span><br/>    <span class=\"kw1\">add</span> <span class=\"kw35\">r2</span><span class=\"sy0\">,</span><span class=\"kw35\">r2</span><span class=\"sy0\">,</span>#<span class=\"nu0\">1</span>   <span class=\"sy0\">/*</span> sinon on ajoute <span class=\"nu0\">1</span> <span class=\"sy0\">*/</span><br/>    <span class=\"kw7\">b</span> <span class=\"nu0\">1b</span><br/><span class=\"nu0\">1</span><span class=\"sy0\">:</span>  <span class=\"sy0\">/*</span> donc ici <span class=\"kw35\">r2</span> contient la longueur du message <span class=\"sy0\">*/</span><br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r1</span><span class=\"sy0\">,</span><span class=\"kw35\">r0</span>        <span class=\"sy0\">/*</span> adresse du message en <span class=\"kw35\">r1</span> <span class=\"sy0\">*/</span><br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span>#STDOUT      <span class=\"sy0\">/*</span> code pour \u00e9crire sur la sortie standard Linux <span class=\"sy0\">*/</span><br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r7</span><span class=\"sy0\">,</span> #WRITE                  <span class=\"sy0\">/*</span> code de l appel systeme <span class=\"st0\">'write'</span> <span class=\"sy0\">*/</span><br/>    swi #<span class=\"nu0\">0</span>                      <span class=\"sy0\">/*</span> appel systeme <span class=\"sy0\">*/</span><br/>    <span class=\"kw3\">pop</span> <span class=\"br0\">{</span><span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r1</span><span class=\"sy0\">,</span><span class=\"kw35\">r2</span><span class=\"sy0\">,</span><span class=\"kw35\">r7</span><span class=\"br0\">}</span>     <span class=\"sy0\">/*</span> restaur des autres registres <span class=\"sy0\">*/</span><br/>    <span class=\"kw3\">pop</span> <span class=\"br0\">{</span><span class=\"kw35\">fp</span><span class=\"sy0\">,</span><span class=\"kw35\">lr</span><span class=\"br0\">}</span>    <span class=\"sy0\">/*</span> restaur des  <span class=\"nu0\">2</span> registres <span class=\"sy0\">*/</span> <br/>    <span class=\"kw7\">bx</span> <span class=\"kw35\">lr</span>\t        <span class=\"sy0\">/*</span> retour procedure <span class=\"sy0\">*/</span>\t<br/><span class=\"sy0\">/***************************************************/</span><br/><span class=\"sy0\">/*</span>   conversion registre en d\u00e9cimal   sign\u00e9  <span class=\"sy0\">*/</span><br/><span class=\"sy0\">/***************************************************/</span><br/><span class=\"sy0\">/*</span> <span class=\"kw35\">r0</span> contient le registre   <span class=\"sy0\">*/</span><br/><span class=\"sy0\">/*</span> <span class=\"kw35\">r1</span> contient l adresse de la zone de conversion <span class=\"sy0\">*/</span><br/>conversion10S<span class=\"sy0\">:</span><br/>    <span class=\"kw3\">push</span> <span class=\"br0\">{</span><span class=\"kw35\">fp</span><span class=\"sy0\">,</span><span class=\"kw35\">lr</span><span class=\"br0\">}</span>    <span class=\"sy0\">/*</span> save des  <span class=\"nu0\">2</span> registres frame et retour <span class=\"sy0\">*/</span><br/>    <span class=\"kw3\">push</span> <span class=\"br0\">{</span><span class=\"kw35\">r0</span><span class=\"sy0\">-</span><span class=\"kw35\">r5</span><span class=\"br0\">}</span>   <span class=\"sy0\">/*</span> save autres registres  <span class=\"sy0\">*/</span><br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r2</span><span class=\"sy0\">,</span><span class=\"kw35\">r1</span>       <span class=\"sy0\">/*</span> debut zone stockage <span class=\"sy0\">*/</span><br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r5</span><span class=\"sy0\">,</span>#<span class=\"st0\">'+'</span>     <span class=\"sy0\">/*</span> par defaut le signe est <span class=\"sy0\">+</span> <span class=\"sy0\">*/</span><br/>    <span class=\"kw5\">cmp</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span>#<span class=\"nu0\">0</span>       <span class=\"sy0\">/*</span> nombre n\u00e9gatif\u00a0? <span class=\"sy0\">*/</span><br/>    <span class=\"kw2\">movlt</span> <span class=\"kw35\">r5</span><span class=\"sy0\">,</span>#<span class=\"st0\">'-'</span>     <span class=\"sy0\">/*</span> oui le signe est <span class=\"sy0\">-</span> <span class=\"sy0\">*/</span><br/>    <span class=\"kw2\">mvnlt</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r0</span>       <span class=\"sy0\">/*</span> et inversion en valeur positive <span class=\"sy0\">*/</span><br/>    <span class=\"kw2\">addlt</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span>#<span class=\"nu0\">1</span><br/>\u00a0<br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r4</span><span class=\"sy0\">,</span>#<span class=\"nu0\">10</span>   <span class=\"sy0\">/*</span> longueur de la zone <span class=\"sy0\">*/</span><br/><span class=\"nu0\">1</span><span class=\"sy0\">:</span> <span class=\"sy0\">/*</span> debut de boucle de conversion <span class=\"sy0\">*/</span><br/>    <span class=\"kw7\">bl</span> divisionpar10 <span class=\"sy0\">/*</span> division  <span class=\"sy0\">*/</span><br/>    <span class=\"kw1\">add</span> <span class=\"kw35\">r1</span><span class=\"sy0\">,</span>#<span class=\"nu0\">48</span>        <span class=\"sy0\">/*</span> ajout de <span class=\"nu0\">48</span> au reste pour conversion ascii <span class=\"sy0\">*/</span>\t<br/>    <span class=\"kw3\">strb</span> <span class=\"kw35\">r1</span><span class=\"sy0\">,</span><span class=\"br0\">[</span><span class=\"kw35\">r2</span><span class=\"sy0\">,</span><span class=\"kw35\">r4</span><span class=\"br0\">]</span>  <span class=\"sy0\">/*</span> stockage du byte en d\u00e9but de zone <span class=\"kw35\">r5</span> <span class=\"sy0\">+</span> la position <span class=\"kw35\">r4</span> <span class=\"sy0\">*/</span><br/>    <span class=\"kw1\">sub</span> <span class=\"kw35\">r4</span><span class=\"sy0\">,</span><span class=\"kw35\">r4</span><span class=\"sy0\">,</span>#<span class=\"nu0\">1</span>      <span class=\"sy0\">/*</span> position pr\u00e9cedente <span class=\"sy0\">*/</span><br/>    <span class=\"kw5\">cmp</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span>#<span class=\"nu0\">0</span>     <br/>    <span class=\"kw8\">bne</span> <span class=\"nu0\">1b</span>\t       <span class=\"sy0\">/*</span> boucle si quotient different de z\u00e9ro <span class=\"sy0\">*/</span><br/>    <span class=\"kw3\">strb</span> <span class=\"kw35\">r5</span><span class=\"sy0\">,</span><span class=\"br0\">[</span><span class=\"kw35\">r2</span><span class=\"sy0\">,</span><span class=\"kw35\">r4</span><span class=\"br0\">]</span>  <span class=\"sy0\">/*</span> stockage du signe \u00e0 la position courante <span class=\"sy0\">*/</span><br/>    <span class=\"kw5\">subs</span> <span class=\"kw35\">r4</span><span class=\"sy0\">,</span><span class=\"kw35\">r4</span><span class=\"sy0\">,</span>#<span class=\"nu0\">1</span>   <span class=\"sy0\">/*</span> position pr\u00e9cedente <span class=\"sy0\">*/</span><br/>    <span class=\"kw8\">blt</span>  <span class=\"nu0\">100f</span>         <span class=\"sy0\">/*</span> si <span class=\"kw35\">r4</span> &lt; <span class=\"nu0\">0</span>  fin  <span class=\"sy0\">*/</span><br/>    <span class=\"sy0\">/*</span> sinon il faut completer le debut de la zone avec des blancs <span class=\"sy0\">*/</span><br/>    <span class=\"kw1\">mov</span> <span class=\"kw35\">r3</span><span class=\"sy0\">,</span>#<span class=\"st0\">' '</span>   <span class=\"sy0\">/*</span> caractere espace <span class=\"sy0\">*/</span>\t<br/><span class=\"nu0\">2</span><span class=\"sy0\">:</span><br/>    <span class=\"kw3\">strb</span> <span class=\"kw35\">r3</span><span class=\"sy0\">,</span><span class=\"br0\">[</span><span class=\"kw35\">r2</span><span class=\"sy0\">,</span><span class=\"kw35\">r4</span><span class=\"br0\">]</span>  <span class=\"sy0\">/*</span> stockage du byte  <span class=\"sy0\">*/</span><br/>    <span class=\"kw5\">subs</span> <span class=\"kw35\">r4</span><span class=\"sy0\">,</span><span class=\"kw35\">r4</span><span class=\"sy0\">,</span>#<span class=\"nu0\">1</span>   <span class=\"sy0\">/*</span> position pr\u00e9cedente <span class=\"sy0\">*/</span><br/>    <span class=\"kw8\">bge</span> 2b        <span class=\"sy0\">/*</span> boucle si <span class=\"kw35\">r4</span> plus grand ou egal a zero <span class=\"sy0\">*/</span><br/><span class=\"nu0\">100</span><span class=\"sy0\">:</span>  <span class=\"sy0\">/*</span> fin standard de la fonction  <span class=\"sy0\">*/</span><br/>    <span class=\"kw3\">pop</span> <span class=\"br0\">{</span><span class=\"kw35\">r0</span><span class=\"sy0\">-</span><span class=\"kw35\">r5</span><span class=\"br0\">}</span>   <span class=\"sy0\">/*</span>restaur des autres registres <span class=\"sy0\">*/</span><br/>    <span class=\"kw3\">pop</span> <span class=\"br0\">{</span><span class=\"kw35\">fp</span><span class=\"sy0\">,</span><span class=\"kw35\">lr</span><span class=\"br0\">}</span>   <span class=\"sy0\">/*</span> restaur des  <span class=\"nu0\">2</span> registres frame et retour  <span class=\"sy0\">*/</span><br/>    <span class=\"kw7\">bx</span> <span class=\"kw35\">lr</span>   <br/>\u00a0<br/><span class=\"sy0\">/***************************************************/</span><br/><span class=\"sy0\">/*</span>   division par <span class=\"nu0\">10</span>   sign\u00e9                       <span class=\"sy0\">*/</span><br/><span class=\"sy0\">/*</span> Thanks to http<span class=\"sy0\">://</span>thinkingeek<span class=\"sy0\">.</span>com<span class=\"sy0\">/</span>arm<span class=\"sy0\">-</span>assembler<span class=\"sy0\">-</span>raspberry<span class=\"sy0\">-</span>pi<span class=\"sy0\">/*</span>  <br/><span class=\"sy0\">/*</span> <span class=\"kw1\">and</span>   http<span class=\"sy0\">://</span>www<span class=\"sy0\">.</span>hackersdelight<span class=\"sy0\">.</span>org<span class=\"sy0\">/</span>            <span class=\"sy0\">*/</span><br/><span class=\"sy0\">/***************************************************/</span><br/><span class=\"sy0\">/*</span> <span class=\"kw35\">r0</span> contient le dividende   <span class=\"sy0\">*/</span><br/><span class=\"sy0\">/*</span> <span class=\"kw35\">r0</span> retourne le quotient <span class=\"sy0\">*/</span>\t<br/><span class=\"sy0\">/*</span> <span class=\"kw35\">r1</span> retourne le reste  <span class=\"sy0\">*/</span><br/>divisionpar10<span class=\"sy0\">:</span>\t<br/>  <span class=\"sy0\">/*</span> <span class=\"kw35\">r0</span> contains the argument to be divided by <span class=\"nu0\">10</span> <span class=\"sy0\">*/</span><br/>   <span class=\"kw3\">push</span> <span class=\"br0\">{</span><span class=\"kw35\">r2</span><span class=\"sy0\">-</span><span class=\"kw35\">r4</span><span class=\"br0\">}</span>   <span class=\"sy0\">/*</span> save autres registres  <span class=\"sy0\">*/</span><br/>   <span class=\"kw1\">mov</span> <span class=\"kw35\">r4</span><span class=\"sy0\">,</span><span class=\"kw35\">r0</span> <br/>   <span class=\"kw3\">ldr</span> <span class=\"kw35\">r3</span><span class=\"sy0\">,</span> <span class=\"sy0\">.</span>Ls_magic_number_10 <span class=\"sy0\">/*</span> <span class=\"kw35\">r1</span> &lt;<span class=\"sy0\">-</span> magic_number <span class=\"sy0\">*/</span><br/>   <span class=\"kw1\">smull</span> <span class=\"kw35\">r1</span><span class=\"sy0\">,</span> <span class=\"kw35\">r2</span><span class=\"sy0\">,</span> <span class=\"kw35\">r3</span><span class=\"sy0\">,</span> <span class=\"kw35\">r0</span>   <span class=\"sy0\">/*</span> <span class=\"kw35\">r1</span> &lt;<span class=\"sy0\">-</span> Lower32Bits<span class=\"br0\">(</span><span class=\"kw35\">r1</span><span class=\"sy0\">*</span><span class=\"kw35\">r0</span><span class=\"br0\">)</span><span class=\"sy0\">.</span> <span class=\"kw35\">r2</span> &lt;<span class=\"sy0\">-</span> Upper32Bits<span class=\"br0\">(</span><span class=\"kw35\">r1</span><span class=\"sy0\">*</span><span class=\"kw35\">r0</span><span class=\"br0\">)</span> <span class=\"sy0\">*/</span><br/>   <span class=\"kw1\">mov</span> <span class=\"kw35\">r2</span><span class=\"sy0\">,</span> <span class=\"kw35\">r2</span><span class=\"sy0\">,</span> <span class=\"kw1\">ASR</span> #<span class=\"nu0\">2</span>     <span class=\"sy0\">/*</span> <span class=\"kw35\">r2</span> &lt;<span class=\"sy0\">-</span> <span class=\"kw35\">r2</span> &gt;&gt; <span class=\"nu0\">2</span> <span class=\"sy0\">*/</span><br/>   <span class=\"kw1\">mov</span> <span class=\"kw35\">r1</span><span class=\"sy0\">,</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span> <span class=\"kw1\">LSR</span> #<span class=\"nu0\">31</span>    <span class=\"sy0\">/*</span> <span class=\"kw35\">r1</span> &lt;<span class=\"sy0\">-</span> <span class=\"kw35\">r0</span> &gt;&gt; <span class=\"nu0\">31</span> <span class=\"sy0\">*/</span><br/>   <span class=\"kw1\">add</span> <span class=\"kw35\">r0</span><span class=\"sy0\">,</span> <span class=\"kw35\">r2</span><span class=\"sy0\">,</span> <span class=\"kw35\">r1</span>         <span class=\"sy0\">/*</span> <span class=\"kw35\">r0</span> &lt;<span class=\"sy0\">-</span> <span class=\"kw35\">r2</span> <span class=\"sy0\">+</span> <span class=\"kw35\">r1</span> <span class=\"sy0\">*/</span><br/>   <span class=\"kw1\">add</span> <span class=\"kw35\">r2</span><span class=\"sy0\">,</span><span class=\"kw35\">r0</span><span class=\"sy0\">,</span><span class=\"kw35\">r0</span><span class=\"sy0\">,</span> <span class=\"kw1\">lsl</span> #<span class=\"nu0\">2</span>   <span class=\"sy0\">/*</span> <span class=\"kw35\">r2</span> &lt;<span class=\"sy0\">-</span> <span class=\"kw35\">r0</span> <span class=\"sy0\">*</span> <span class=\"nu0\">5</span> <span class=\"sy0\">*/</span><br/>   <span class=\"kw1\">sub</span> <span class=\"kw35\">r1</span><span class=\"sy0\">,</span><span class=\"kw35\">r4</span><span class=\"sy0\">,</span><span class=\"kw35\">r2</span><span class=\"sy0\">,</span> <span class=\"kw1\">lsl</span> #<span class=\"nu0\">1</span>   <span class=\"sy0\">/*</span> <span class=\"kw35\">r1</span> &lt;<span class=\"sy0\">-</span> <span class=\"kw35\">r4</span> <span class=\"sy0\">-</span> <span class=\"br0\">(</span><span class=\"kw35\">r2</span> <span class=\"sy0\">*</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span>  = <span class=\"kw35\">r4</span> <span class=\"sy0\">-</span> <span class=\"br0\">(</span><span class=\"kw35\">r0</span> <span class=\"sy0\">*</span> <span class=\"nu0\">10</span><span class=\"br0\">)</span> <span class=\"sy0\">*/</span><br/>   <span class=\"kw3\">pop</span> <span class=\"br0\">{</span><span class=\"kw35\">r2</span><span class=\"sy0\">-</span><span class=\"kw35\">r4</span><span class=\"br0\">}</span><br/>   <span class=\"kw7\">bx</span> <span class=\"kw35\">lr</span>                  <span class=\"sy0\">/*</span> leave function <span class=\"sy0\">*/</span><br/>   <span class=\"sy0\">.</span>align <span class=\"nu0\">4</span><br/><span class=\"sy0\">.</span>Ls_magic_number_10<span class=\"sy0\">:</span> <span class=\"sy0\">.</span>word <span class=\"nu0\">0x66666667</span><br/>\u00a0<br/>\u00a0</pre>"}, {"lang": "AutoHotkey", "loc": 40, "block": "<pre class=\"ahk highlighted_source\"><span class=\"co1\">; Call a function without arguments:</span><br/>f<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">; Call a function with a fixed number of arguments:</span><br/>f<span class=\"br0\">(</span><span class=\"st0\">\"string\"</span><span class=\"sy0\">,</span> var<span class=\"sy0\">,</span> <span class=\"nu0\">15.5</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">; Call a function with optional arguments:</span><br/>f<span class=\"br0\">(</span><span class=\"st0\">\"string\"</span><span class=\"sy0\">,</span> var<span class=\"sy0\">,</span> <span class=\"nu0\">15.5</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">; Call a function with a variable number of arguments:</span><br/>f<span class=\"br0\">(</span><span class=\"st0\">\"string\"</span><span class=\"sy0\">,</span> var<span class=\"sy0\">,</span> <span class=\"nu0\">15.5</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">; Call a function with named arguments:</span><br/>    <span class=\"co1\">; AutoHotkey does not have named arguments. However, in v1.1+,</span><br/>    <span class=\"co1\">; we can pass an object to the function:</span><br/>f<span class=\"br0\">(</span><span class=\"br0\">{</span><span class=\"re2\">named: </span><span class=\"st0\">\"string\"</span><span class=\"sy0\">,</span> <span class=\"re2\">otherName: </span>var<span class=\"sy0\">,</span> <span class=\"re2\">thirdName: </span><span class=\"nu0\">15.5</span><span class=\"br0\">}</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">; Use a function in statement context:</span><br/>f<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">,</span> f<span class=\"br0\">(</span><span class=\"nu0\">2</span><span class=\"br0\">)</span> <span class=\"co1\">; What is statement context?</span><br/>\u00a0<br/><span class=\"co1\">; No first-class functions in AHK</span><br/>\u00a0<br/><span class=\"co1\">; Obtaining the return value of a function:</span><br/>varThatGetsReturnValue <span class=\"sy0\">:=</span> f<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"st0\">\"a\"</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">; Cannot distinguish built-in functions</span><br/>\u00a0<br/><span class=\"co1\">; Subroutines are called with GoSub; functions are called as above.</span><br/><span class=\"co1\">; Subroutines cannot be passed variables</span><br/>\u00a0<br/><span class=\"co1\">; Stating whether arguments are passed by value or by reference:</span><br/><span class=\"co1\">; [v1.1.01+]: The IsByRef() function can be used to determine</span><br/><span class=\"co1\">;     whether the caller supplied a variable for a given ByRef parameter.</span><br/><span class=\"co1\">; A variable cannot be passed by value to a byRef parameter. Instead, do this:</span><br/>f<span class=\"br0\">(</span>tmp <span class=\"sy0\">:=</span> varIdoNotWantChanged<span class=\"br0\">)</span><br/><span class=\"co1\">; the function f will receive the value of varIdoNotWantChanged, but any</span><br/><span class=\"co1\">; modifications will be made to the variable tmp.</span><br/>\u00a0<br/><span class=\"co1\">; Partial application is impossible.</span><br/>\u00a0</pre>"}, {"lang": "AWK", "loc": 4, "block": "<pre class=\"awk highlighted_source\"><span class=\"kw2\">BEGIN</span> <span class=\"br0\">{</span><br/>  sayhello<span class=\"br0\">(</span><span class=\"br0\">)</span>       <span class=\"co1\"># Call a function with no parameters in statement context</span><br/>  b=squareit<span class=\"br0\">(</span><span class=\"nu0\">3</span><span class=\"br0\">)</span>    <span class=\"co1\"># Obtain the return value from a function with a single parameter in first class context</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Axe", "loc": 2, "block": "<pre class=\"text highlighted_source\">NOARG()<br/>ARGS(1,5,42)</pre>"}, {"lang": "Batch File", "loc": 15, "block": "<pre class=\"dos highlighted_source\">\u00a0<br/><span class=\"sy0\">@</span><a href=\"http://www.ss64.com/nt/echo.html\"><span class=\"kw3\">echo</span></a> off<br/><span class=\"co2\"><br/>::call a function with no arguments</span><br/><a href=\"http://www.ss64.com/nt/call.html\"><span class=\"kw1\">call</span></a>\u00a0:<span class=\"re0\">myFunction</span><br/><span class=\"co2\"><br/>::call a function with arguments</span><br/><a href=\"http://www.ss64.com/nt/call.html\"><span class=\"kw1\">call</span></a>\u00a0:<span class=\"re0\">myFunction</span> arg1 \"arg 2\"<br/><span class=\"co2\"><br/>::initiate a \"function\".</span><br/>:<span class=\"re0\">myFunction</span><br/><a href=\"http://www.ss64.com/nt/echo.html\"><span class=\"kw3\">echo</span></a> arg1 - <span class=\"sy0\">%</span><span class=\"re3\">1</span><br/><a href=\"http://www.ss64.com/nt/echo.html\"><span class=\"kw3\">echo</span></a> arg2 - <span class=\"sy0\">%</span><span class=\"re3\">~2</span><br/><a href=\"http://www.ss64.com/nt/goto.html\"><span class=\"kw1\">goto</span></a>\u00a0:<span class=\"re0\">eof</span><br/>\u00a0</pre>"}, {"lang": "BBC BASIC", "loc": 1, "block": "<pre class=\"text highlighted_source\">PRINT SQR(2)</pre>"}, {"lang": "Bracmat", "loc": 1, "block": "<pre class=\"text highlighted_source\">aFunctionWithoutArguments$</pre>"}, {"lang": "C", "loc": 65, "block": "<pre class=\"c highlighted_source\"><span class=\"coMULTI\">/* function with no argument */</span><br/>f<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"coMULTI\">/* fix number of arguments */</span><br/>g<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"coMULTI\">/* Optional arguments: err...<br/>   Feel free to make sense of the following.  I can't. */</span><br/><span class=\"kw4\">int</span> op_arg<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"kw4\">int</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>\top_arg<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\top_arg<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\top_arg<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t<span class=\"kw1\">return</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/><span class=\"kw4\">int</span> op_arg<span class=\"br0\">(</span><span class=\"kw4\">int</span> a<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> b<span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>\t<a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/printf.html\"><span class=\"kw3\">printf</span></a><span class=\"br0\">(</span><span class=\"st0\">\"%d\u00a0%d\u00a0%d<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span> a<span class=\"sy0\">,</span> b<span class=\"sy0\">,</span> <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>b<span class=\"br0\">)</span><span class=\"br0\">[</span><span class=\"nu0\">1</span><span class=\"br0\">]</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t<span class=\"kw1\">return</span> a<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span>  <span class=\"coMULTI\">/* end of sensible code */</span><br/>\u00a0<br/><span class=\"coMULTI\">/* Variadic function: how the args list is handled solely depends on the function */</span><br/><span class=\"kw4\">void</span> h<span class=\"br0\">(</span><span class=\"kw4\">int</span> a<span class=\"sy0\">,</span> ...<span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>\tva_list ap<span class=\"sy0\">;</span><br/>\t<a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/va_start.html\"><span class=\"kw3\">va_start</span></a><span class=\"br0\">(</span>ap<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t...<br/><span class=\"br0\">}</span><br/><span class=\"coMULTI\">/* call it as: (if you feed it something it doesn't expect, don't count on it working) */</span><br/>h<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"sy0\">,</span> <span class=\"nu0\">4</span><span class=\"sy0\">,</span> <span class=\"st0\">\"abcd\"</span><span class=\"sy0\">,</span> <span class=\"br0\">(</span><span class=\"kw4\">void</span><span class=\"sy0\">*</span><span class=\"br0\">)</span><span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"coMULTI\">/* named arguments: this is only possible through some pre-processor abuse<br/>*/</span><br/><span class=\"kw4\">struct</span> v_args <span class=\"br0\">{</span><br/>    <span class=\"kw4\">int</span> arg1<span class=\"sy0\">;</span><br/>    <span class=\"kw4\">int</span> arg2<span class=\"sy0\">;</span><br/>    <span class=\"kw4\">char</span> _sentinel<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"kw4\">void</span> _v<span class=\"br0\">(</span><span class=\"kw4\">struct</span> v_args args<span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>    <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/printf.html\"><span class=\"kw3\">printf</span></a><span class=\"br0\">(</span><span class=\"st0\">\"%d,\u00a0%d<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span> args.<span class=\"me1\">arg1</span><span class=\"sy0\">,</span> args.<span class=\"me1\">arg2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"co2\">#define v(...) _v((struct v_args){__VA_ARGS__})</span><br/>\u00a0<br/>v<span class=\"br0\">(</span>.<span class=\"me1\">arg2</span> <span class=\"sy0\">=</span> <span class=\"nu0\">5</span><span class=\"sy0\">,</span> .<span class=\"me1\">arg1</span> <span class=\"sy0\">=</span> <span class=\"nu0\">17</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">// prints \"17,5\"</span><br/><span class=\"coMULTI\">/* NOTE the above implementation gives us optional typesafe optional arguments as well (unspecified arguments are initialized to zero)*/</span><br/>v<span class=\"br0\">(</span>.<span class=\"me1\">arg2</span><span class=\"sy0\">=</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">// prints \"0,1\"</span><br/>v<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span>  <span class=\"co1\">// prints \"0,0\"</span><br/>\u00a0<br/><span class=\"coMULTI\">/* as a first-class object (i.e. function pointer) */</span><br/><a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/printf.html\"><span class=\"kw3\">printf</span></a><span class=\"br0\">(</span><span class=\"st0\">\"%p\"</span><span class=\"sy0\">,</span> f<span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"coMULTI\">/* that's the f() above */</span><br/>\u00a0<br/><span class=\"coMULTI\">/* return value */</span><br/><span class=\"kw4\">double</span> a <span class=\"sy0\">=</span> <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/asin.html\"><span class=\"kw3\">asin</span></a><span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"coMULTI\">/* built-in functions: no such thing. Compiler may interally give special treatment<br/>   to bread-and-butter functions such as memcpy(), but that's not a C built-in per se */</span><br/>\u00a0<br/><span class=\"coMULTI\">/* subroutines: no such thing. You can goto places, but I doubt that counts. */</span><br/>\u00a0<br/><span class=\"coMULTI\">/* Scalar values are passed by value by default. However, arrays are passed by reference. */</span><br/><span class=\"coMULTI\">/* Pointers *sort of* work like references, though. */</span></pre>"}, {"lang": "C#", "loc": 32, "block": "<pre class=\"c highlighted_source\">\u00a0<br/><span class=\"coMULTI\">/* a function that has no argument */</span><br/>\tpublic <span class=\"kw4\">int</span> MyFunction<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\t<span class=\"coMULTI\">/* a function with a fixed number of arguments */</span><br/>\tFunctionWithArguments<span class=\"br0\">(</span><span class=\"nu0\">4</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\t<span class=\"coMULTI\">/* a function with optional arguments */</span><br/>\tpublic <span class=\"kw4\">void</span> OptArg<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\tpublic <span class=\"kw4\">static</span> <span class=\"kw4\">void</span> Main<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\t<span class=\"br0\">{</span><br/>\t\tOptArg<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t\tOptArg<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t\tOptArg<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t<span class=\"br0\">}</span><br/>\tpublic <span class=\"kw4\">void</span> ExampleMethod<span class=\"br0\">(</span><span class=\"kw4\">int</span> required<span class=\"sy0\">,</span> <br/>        string optionalstr <span class=\"sy0\">=</span> <span class=\"st0\">\"default string\"</span><span class=\"sy0\">,</span><br/>\t\t<span class=\"kw4\">int</span> optionalint <span class=\"sy0\">=</span> <span class=\"nu0\">10</span><span class=\"br0\">)</span><br/>\t<span class=\"coMULTI\">/* If you know the first and the last parameter */</span><br/>\tExampleMethod<span class=\"br0\">(</span><span class=\"nu0\">3</span><span class=\"sy0\">,</span> optionalint<span class=\"sy0\">:</span> <span class=\"nu0\">4</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\t<span class=\"coMULTI\">/* If you know all the parameter */</span><br/>\tExampleMethod<span class=\"br0\">(</span><span class=\"nu0\">3</span><span class=\"sy0\">,</span> <span class=\"st0\">\"Hello World\"</span><span class=\"sy0\">,</span> <span class=\"nu0\">4</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\t<span class=\"coMULTI\">/* Variable number of arguments use array */</span><br/>\tpublic <span class=\"kw4\">static</span> <span class=\"kw4\">void</span> UseVariableParameters<span class=\"br0\">(</span>params <span class=\"kw4\">int</span><span class=\"br0\">[</span><span class=\"br0\">]</span> list<span class=\"br0\">)</span> <br/>\u00a0<br/>\t<span class=\"coMULTI\">/* Obtain return value from function */</span><br/>\tpublic internal MyFunction<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\t<span class=\"kw4\">int</span> returnValue <span class=\"sy0\">=</span> MyFunction<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0</pre>"}, {"lang": "C++", "loc": 5, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>\u00a0<br/>/* function with no arguments */<br/>foo();<br/>\u00a0</pre>"}, {"lang": "COBOL", "loc": 65, "block": "<pre class=\"cobol highlighted_source\"><span class=\"kw2\">CALL</span> <span class=\"st0\">\"No-Arguments\"</span><br/>\u00a0<br/><span class=\"co1\">*&gt; Fixed number of arguments.</span><br/><span class=\"kw2\">CALL</span> <span class=\"st0\">\"2-Arguments\"</span> <span class=\"kw3\">USING</span> Foo Bar<br/>\u00a0<br/><span class=\"kw2\">CALL</span> <span class=\"st0\">\"Optional-Arguments\"</span> <span class=\"kw3\">USING</span> Foo<br/><span class=\"kw2\">CALL</span> <span class=\"st0\">\"Optional-Arguments\"</span> <span class=\"kw3\">USING</span> Foo Bar<br/><span class=\"co1\">*&gt; If an optional argument is omitted and replaced with OMITTED, any following</span><br/><span class=\"co1\">*&gt; arguments can still be specified.</span><br/><span class=\"kw2\">CALL</span> <span class=\"st0\">\"Optional-Arguments\"</span> <span class=\"kw3\">USING</span> Foo <span class=\"kw3\">OMITTED</span> Bar<br/><span class=\"co1\">*&gt; Interestingly, even arguments not marked as optional can be omitted without </span><br/><span class=\"co1\">*&gt; a compiler warning. It is highly unlikely the function will still work,</span><br/><span class=\"co1\">*&gt; however.</span><br/><span class=\"kw2\">CALL</span> <span class=\"st0\">\"2-Arguments\"</span> <span class=\"kw3\">USING</span> Foo<br/>\u00a0<br/><span class=\"co1\">*&gt; COBOL does not support a variable number of arguments, or named arguments.</span><br/>\u00a0<br/><span class=\"co1\">*&gt; Values to return can be put in either one of the arguments or, in OpenCOBOL,</span><br/><span class=\"co1\">*&gt; the RETURN-CODE register.</span><br/><span class=\"co1\">*&gt; A standard function call cannot be done in another statement.</span><br/><span class=\"kw2\">CALL</span> <span class=\"st0\">\"Some-Func\"</span> <span class=\"kw3\">USING</span> Foo<br/><span class=\"kw2\">MOVE</span> Return-<span class=\"kw1\">Code</span> <span class=\"kw2\">TO</span> Bar<br/>\u00a0<br/><span class=\"co1\">*&gt; Intrinsic functions can be used in any place a literal value may go (i.e. in</span><br/><span class=\"co1\">*&gt; statements) and are optionally preceded by FUNCTION.</span><br/><span class=\"co1\">*&gt; Intrinsic functions that do not take arguments may optionally have a pair of</span><br/><span class=\"co1\">*&gt; empty parentheses.</span><br/><span class=\"co1\">*&gt; Intrinsic functions cannot be defined by the user.</span><br/><span class=\"kw2\">MOVE</span> <span class=\"kw3\">FUNCTION</span> PI <span class=\"kw2\">TO</span> Bar<br/><span class=\"kw2\">MOVE</span> <span class=\"kw3\">FUNCTION</span> <span class=\"kw4\">MEDIAN</span><span class=\"br0\">(</span><span class=\"nu0\">4</span><span class=\"sy0\">,</span> <span class=\"nu0\">5</span><span class=\"sy0\">,</span> <span class=\"nu0\">6</span><span class=\"br0\">)</span> <span class=\"kw2\">TO</span> Bar<br/>\u00a0<br/><span class=\"co1\">*&gt; Built-in functions/subroutines typically have prefixes indicating which</span><br/><span class=\"co1\">*&gt; compiler originally incorporated it:</span><br/><span class=\"co1\">*&gt;  - C$      - ACUCOBOL-GT</span><br/><span class=\"co1\">*&gt;  - CBL_    - Micro Focus</span><br/><span class=\"co1\">*&gt;  - CBL_OC_ - OpenCOBOL</span><br/><span class=\"co1\">*&gt; Note: The user could name their functions similarly if they wanted to.</span><br/><span class=\"kw2\">CALL</span> <span class=\"st0\">\"C$MAKEDIR\"</span> <span class=\"kw3\">USING</span> Foo<br/><span class=\"kw2\">CALL</span> <span class=\"st0\">\"CBL_CREATE_DIR\"</span> <span class=\"kw3\">USING</span> Foo<br/><span class=\"kw2\">CALL</span> <span class=\"st0\">\"CBL_OC_NANOSLEEP\"</span> <span class=\"kw3\">USING</span> Bar<br/><span class=\"co1\">*&gt; Although some built-in functions identified by numbers.</span><br/><span class=\"kw2\">CALL</span> X<span class=\"st0\">\"F4\"</span> <span class=\"kw3\">USING</span> Foo Bar<br/>\u00a0<br/><span class=\"co1\">*&gt; Parameters can be passed in 3 different ways:</span><br/><span class=\"co1\">*&gt;  - BY REFERENCE - this is the default way in OpenCOBOL and this clause may </span><br/><span class=\"co1\">*&gt;       be omitted. The address of the argument is passed to the function.</span><br/><span class=\"co1\">*&gt;       The function is allowed to modify the variable.</span><br/><span class=\"co1\">*&gt;  - BY CONTENT - a copy is made and the function is passed the address</span><br/><span class=\"co1\">*&gt;      of the copy, which it can then modify. This is recomended when</span><br/><span class=\"co1\">*&gt;      passing a literal to a function.</span><br/><span class=\"co1\">*&gt;  - BY VALUE - the function is passed the address of the argument (like a</span><br/><span class=\"co1\">*&gt;      pointer). This is mostly used to provide compatibility with other</span><br/><span class=\"co1\">*&gt;      languages, such as C.</span><br/><span class=\"kw2\">CALL</span> <span class=\"st0\">\"Modify-Arg\"</span> <span class=\"kw3\">USING</span> <span class=\"kw3\">BY</span> <span class=\"kw3\">REFERENCE</span> Foo *&gt; Foo <span class=\"kw3\">is</span> modified<span class=\"sy0\">.</span><br/><span class=\"kw2\">CALL</span> <span class=\"st0\">\"Modify-Arg\"</span> <span class=\"kw3\">USING</span> <span class=\"kw3\">BY</span> <span class=\"kw3\">CONTENT</span> Foo   *&gt; Foo <span class=\"kw3\">is</span> unchanged<span class=\"sy0\">.</span><br/><span class=\"kw2\">CALL</span> <span class=\"st0\">\"C-Func\"</span> <span class=\"kw3\">USING</span> <span class=\"kw3\">BY</span> <span class=\"kw3\">VALUE</span> Bar<br/>\u00a0<br/><span class=\"co1\">*&gt; Partial application is impossible as COBOL does not support first-class</span><br/><span class=\"co1\">*&gt; functions.</span><br/><span class=\"co1\">*&gt; However, as functions are called using a string of their PROGRAM-ID,</span><br/><span class=\"co1\">*&gt; you could pass a 'function' as an argument to another function, or store</span><br/><span class=\"co1\">*&gt; it in a variable, or get it at runtime.</span><br/><span class=\"kw2\">ACCEPT</span> Foo *&gt; Get a <span class=\"kw3\">PROGRAM-ID</span> <span class=\"kw3\">from</span> the user<span class=\"sy0\">.</span><br/><span class=\"kw2\">CALL</span> <span class=\"st0\">\"Use-Func\"</span> <span class=\"kw3\">USING</span> Foo<br/><span class=\"kw2\">CALL</span> Foo <span class=\"kw3\">USING</span> Bar</pre>"}, {"lang": "CoffeeScript", "loc": 54, "block": "<pre class=\"coffeescript highlighted_source\">\u00a0<br/><span class=\"co1\"># Calling a function that requires no arguments</span><br/>foo<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\"># Calling a function with a fixed number of arguments</span><br/>foo <span class=\"nu0\">1</span><br/>\u00a0<br/><span class=\"co1\"># Calling a function with optional arguments</span><br/><span class=\"co1\"># (Optional arguments are done using an object with named keys)</span><br/>foo <span class=\"nu0\">1</span><span class=\"sy0\">,</span> optionalBar<span class=\"sy0\">:</span> <span class=\"nu0\">1</span><span class=\"sy0\">,</span> optionalBaz<span class=\"sy0\">:</span> <span class=\"st0\">'bax'</span><br/>\u00a0<br/><span class=\"co1\"># Calling a function with a variable number of arguments</span><br/><span class=\"co1\"># for a function `foo` defined as `foo = ( args... ) -&gt;`</span><br/>foo <span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"sy0\">,</span> <span class=\"nu0\">4</span><br/>\u00a0<br/><span class=\"co1\"># Calling a function with named arguments</span><br/><span class=\"co1\"># (Named arguments are done using an object with named keys)</span><br/>foo bar<span class=\"sy0\">:</span> <span class=\"nu0\">1</span><span class=\"sy0\">,</span> bax<span class=\"sy0\">:</span> <span class=\"st0\">'baz'</span><br/>\u00a0<br/><span class=\"co1\"># Using a function in statement context</span><br/>x = foo <span class=\"nu0\">1</span><br/>\u00a0<br/><span class=\"co1\"># Using a function in first-class context within an expression</span><br/><span class=\"co1\"># (For `foo` defined as `foo = ( x ) -&gt; x + 1`</span><br/>x = <span class=\"br0\">[</span> <span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span> <span class=\"br0\">]</span>.<span class=\"me1\">map</span> foo<br/>\u00a0<br/><span class=\"co1\"># Obtaining the return value of a function</span><br/>x = foo <span class=\"nu0\">1</span><br/>\u00a0<br/><span class=\"co1\"># Arguments are passed by value, even objects. Objects</span><br/><span class=\"co1\"># are passed as the _value_ of the reference to an object.</span><br/><span class=\"co1\"># Example:</span><br/>bar = <span class=\"br0\">(</span> person <span class=\"br0\">)</span> <span class=\"sy0\">-&gt;</span><br/>    <span class=\"co1\"># Since `person` is a reference</span><br/>    <span class=\"co1\"># to the person passed in, we can assign</span><br/>    <span class=\"co1\"># a new value to its `name` key.</span><br/>    person.<span class=\"me1\">name</span> = <span class=\"st0\">'Bob'</span><br/>\u00a0<br/>    <span class=\"co1\"># Since `person` is just the value of</span><br/>    <span class=\"co1\"># the original reference, assigning to it</span><br/>    <span class=\"co1\"># does not modify the original reference.</span><br/>    person = <span class=\"kw3\">new</span> Person <span class=\"st0\">'Frank'</span><br/>\u00a0<br/><span class=\"co1\"># Partial application is only possible manually through closures</span><br/>curry = <span class=\"br0\">(</span> f<span class=\"sy0\">,</span> fixedArgs... <span class=\"br0\">)</span> <span class=\"sy0\">-&gt;</span><br/>    <span class=\"br0\">(</span> args... <span class=\"br0\">)</span> <span class=\"sy0\">-&gt;</span> f fixedArgs...<span class=\"sy0\">,</span> args...<br/>\u00a0<br/><span class=\"co1\"># Example usage</span><br/>add = <span class=\"br0\">(</span> x<span class=\"sy0\">,</span> y <span class=\"br0\">)</span> <span class=\"sy0\">-&gt;</span> x <span class=\"sy0\">+</span> y<br/>\u00a0<br/>add2 = curry add<span class=\"sy0\">,</span> <span class=\"nu0\">2</span><br/>\u00a0<br/>add2 <span class=\"nu0\">1</span> <span class=\"co1\">#=&gt; 3</span><br/>\u00a0</pre>"}, {"lang": "Common Lisp", "loc": 27, "block": "<pre class=\"lisp highlighted_source\">\u00a0<br/><span class=\"co1\">;Calling a function that requires no arguments</span><br/><span class=\"br0\">(</span><span class=\"kw1\">defun</span> a <span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"st0\">\"This is the 'A' function\"</span><span class=\"br0\">)</span><br/><span class=\"br0\">(</span>a<span class=\"br0\">)</span><br/><span class=\"co1\">;Calling a function with a fixed number of arguments</span><br/><span class=\"br0\">(</span><span class=\"kw1\">defun</span> b <span class=\"br0\">(</span>x y<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw1\">list</span> x y<span class=\"br0\">)</span><span class=\"br0\">)</span><br/><span class=\"br0\">(</span>b <span class=\"nu0\">1</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><br/><span class=\"co1\">;Calling a function with optional arguments</span><br/><span class=\"br0\">(</span><span class=\"kw1\">defun</span> c <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>optional x y<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw1\">list</span> x y<span class=\"br0\">)</span><span class=\"br0\">)</span><br/><span class=\"br0\">(</span>c <span class=\"nu0\">1</span><span class=\"br0\">)</span><br/><span class=\"co1\">;Calling a function with a variable number of arguments</span><br/><span class=\"br0\">(</span><span class=\"kw1\">defun</span> d <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>rest args<span class=\"br0\">)</span> args<span class=\"br0\">)</span><br/><span class=\"br0\">(</span>d <span class=\"nu0\">1</span> <span class=\"nu0\">2</span> <span class=\"nu0\">3</span> <span class=\"nu0\">4</span> <span class=\"nu0\">5</span> <span class=\"nu0\">6</span> <span class=\"nu0\">7</span> <span class=\"nu0\">8</span><span class=\"br0\">)</span><br/><span class=\"co1\">;Calling a function with named arguments</span><br/><span class=\"br0\">(</span><span class=\"kw1\">defun</span> e <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>key <span class=\"br0\">(</span>x <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>y <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw1\">list</span> x y<span class=\"br0\">)</span><span class=\"br0\">)</span><br/><span class=\"br0\">(</span>e <span class=\"sy0\">:</span><span class=\"me1\">x</span> <span class=\"nu0\">10</span> <span class=\"sy0\">:</span><span class=\"me1\">y</span> <span class=\"nu0\">20</span><span class=\"br0\">)</span><br/><span class=\"co1\">;Using a function in first-class context within an expression</span><br/><span class=\"br0\">(</span><span class=\"kw1\">defun</span> f <span class=\"br0\">(</span>func<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw1\">funcall</span> func<span class=\"br0\">)</span><span class=\"br0\">)</span><br/><span class=\"br0\">(</span>f #'a<span class=\"br0\">)</span><br/><span class=\"co1\">;Obtaining the return value of a function</span><br/><span class=\"br0\">(</span>defvar return-of-a <span class=\"br0\">(</span>a<span class=\"br0\">)</span><span class=\"br0\">)</span><br/><span class=\"co1\">;Is partial application possible and how </span><br/><span class=\"br0\">(</span><span class=\"kw1\">defun</span> curry <span class=\"br0\">(</span><span class=\"kw1\">function</span> <span class=\"sy0\">&amp;</span>rest args-<span class=\"nu0\">1</span><span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">lambda</span> <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>rest args-<span class=\"nu0\">2</span><span class=\"br0\">)</span><br/>    <span class=\"br0\">(</span><span class=\"kw1\">apply</span> <span class=\"kw1\">function</span> <span class=\"br0\">(</span><span class=\"kw1\">append</span> args-<span class=\"nu0\">1</span> args-<span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/><span class=\"br0\">(</span><span class=\"kw1\">funcall</span> <span class=\"br0\">(</span>curry #'+ <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><br/>\u00a0</pre>"}, {"lang": "D", "loc": 103, "block": "<pre class=\"d highlighted_source\"><span class=\"kw2\">import</span> std.<span class=\"me1\">traits</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"kw4\">enum</span> isSubroutine<span class=\"br0\">(</span><span class=\"kw2\">alias</span> F<span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"kw2\">is</span><span class=\"br0\">(</span>ReturnType<span class=\"sy0\">!</span>F <span class=\"sy0\">==</span> <span class=\"kw4\">void</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"kw4\">void</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <span class=\"kw4\">void</span> foo1<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"co1\">// Calling a function that requires no arguments:</span><br/>    foo1<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    foo1<span class=\"sy0\">;</span> <span class=\"co1\">// Alternative syntax.</span><br/>\u00a0<br/>\u00a0<br/>    <span class=\"kw4\">void</span> foo2<span class=\"br0\">(</span><span class=\"kw4\">int</span> x<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> y<span class=\"br0\">)</span> <span class=\"br0\">{</span><span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"kw4\">immutable</span> lambda <span class=\"sy0\">=</span> <span class=\"kw2\">function</span> <span class=\"kw4\">int</span><span class=\"br0\">(</span><span class=\"kw4\">int</span> x<span class=\"br0\">)</span> <span class=\"sy0\">=&gt;</span> x <span class=\"sy0\">^^</span> <span class=\"nu0\">2</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"co1\">// Calling a function with a fixed number of arguments:</span><br/>    foo2<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    foo2<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw2\">cast</span><span class=\"br0\">(</span><span class=\"kw4\">void</span><span class=\"br0\">)</span>lambda<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\u00a0<br/>    <span class=\"kw4\">void</span> foo3<span class=\"br0\">(</span><span class=\"kw4\">int</span> x<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> y<span class=\"sy0\">=</span><span class=\"nu0\">2</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"co1\">// Calling a function with optional arguments:</span><br/>    foo3<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    foo3<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"kw4\">int</span> sum<span class=\"br0\">(</span><span class=\"kw4\">int</span><span class=\"br0\">[</span><span class=\"br0\">]</span> arr<span class=\"sy0\">...</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw4\">int</span> tot <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">immutable</span> x<span class=\"sy0\">;</span> arr<span class=\"br0\">)</span><br/>            tot <span class=\"sy0\">+=</span> x<span class=\"sy0\">;</span><br/>        <span class=\"kw1\">return</span> tot<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"kw4\">real</span> sum2<span class=\"br0\">(</span>Args<span class=\"sy0\">...</span><span class=\"br0\">)</span><span class=\"br0\">(</span>Args arr<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw2\">typeof</span><span class=\"br0\">(</span><span class=\"kw1\">return</span><span class=\"br0\">)</span> tot <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw4\">immutable</span> x<span class=\"sy0\">;</span> arr<span class=\"br0\">)</span><br/>            tot <span class=\"sy0\">+=</span> x<span class=\"sy0\">;</span><br/>        <span class=\"kw1\">return</span> tot<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"co1\">// Calling a function with a variable number of arguments:</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>sum<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"br0\">)</span> <span class=\"sy0\">==</span> <span class=\"nu0\">6</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>sum<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"sy0\">,</span> <span class=\"nu0\">4</span><span class=\"br0\">)</span> <span class=\"sy0\">==</span> <span class=\"nu0\">10</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>sum2<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu16\">2.5</span><span class=\"sy0\">,</span> <span class=\"nu16\">3.5</span><span class=\"br0\">)</span> <span class=\"sy0\">==</span> <span class=\"nu0\">7</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"co1\">// Calling a function with named arguments:</span><br/>    <span class=\"co1\">// Various struct or tuple-based tricks can be used for this,</span><br/>    <span class=\"co1\">// but currently D doesn't have named arguments.</span><br/>\u00a0<br/>\u00a0<br/>    <span class=\"co1\">// Using a function in statement context (?):</span><br/>    <span class=\"kw1\">if</span> <span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><br/>        foo1<span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"co1\">// Using a function in first-class context within an expression:</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>sum<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"sy0\">==</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>\u00a0<br/>    <span class=\"kw4\">auto</span> foo4<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span> <span class=\"kw1\">return</span> <span class=\"nu0\">1</span><span class=\"sy0\">;</span> <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"co1\">// Obtaining the return value of a function:</span><br/>    <span class=\"kw4\">immutable</span> x <span class=\"sy0\">=</span> foo4<span class=\"sy0\">;</span><br/>\u00a0<br/>\u00a0<br/>    <span class=\"co1\">// Distinguishing built-in functions and user-defined functions:</span><br/>    <span class=\"co1\">// There are no built-in functions, beside the operators, and</span><br/>    <span class=\"co1\">// pseudo-functions like assert().</span><br/>\u00a0<br/>\u00a0<br/>    <span class=\"kw4\">int</span> myFynction<span class=\"br0\">(</span><span class=\"kw4\">int</span> x<span class=\"br0\">)</span> <span class=\"br0\">{</span> <span class=\"kw1\">return</span> x<span class=\"sy0\">;</span> <span class=\"br0\">}</span><br/>    <span class=\"kw4\">void</span> mySubroutine<span class=\"br0\">(</span><span class=\"kw4\">int</span> x<span class=\"br0\">)</span> <span class=\"br0\">{</span><span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"co1\">// Distinguishing subroutines and functions:</span><br/>    <span class=\"co1\">// (A subroutine is merely a function that has no explicit</span><br/>    <span class=\"co1\">// return statement and will return void).</span><br/>    <span class=\"kw2\">pragma</span><span class=\"br0\">(</span>msg<span class=\"sy0\">,</span> isSubroutine<span class=\"sy0\">!</span>mySubroutine<span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">// Prints: true</span><br/>    <span class=\"kw2\">pragma</span><span class=\"br0\">(</span>msg<span class=\"sy0\">,</span> isSubroutine<span class=\"sy0\">!</span>myFynction<span class=\"br0\">)</span><span class=\"sy0\">;</span>   <span class=\"co1\">// Prints: false</span><br/>\u00a0<br/>\u00a0<br/>    <span class=\"kw4\">void</span> foo5<span class=\"br0\">(</span><span class=\"kw4\">int</span> a<span class=\"sy0\">,</span> <span class=\"kw2\">in</span> <span class=\"kw4\">int</span> b<span class=\"sy0\">,</span> <span class=\"kw2\">ref</span> <span class=\"kw4\">int</span> c<span class=\"sy0\">,</span> <span class=\"kw2\">out</span> <span class=\"kw4\">int</span> d<span class=\"sy0\">,</span> <span class=\"kw2\">lazy</span> <span class=\"kw4\">int</span> e<span class=\"sy0\">,</span> <span class=\"kw2\">scope</span> <span class=\"kw4\">int</span> f<span class=\"br0\">)</span> <span class=\"br0\">{</span><span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"co1\">// Stating whether arguments are passed by value, by reference, etc:</span><br/>    <span class=\"kw2\">alias</span> STC <span class=\"sy0\">=</span> ParameterStorageClass<span class=\"sy0\">;</span><br/>    <span class=\"kw2\">alias</span> psct <span class=\"sy0\">=</span> ParameterStorageClassTuple<span class=\"sy0\">!</span>foo5<span class=\"sy0\">;</span><br/>    <span class=\"kw4\">static</span> <span class=\"kw2\">assert</span><span class=\"br0\">(</span>psct.<span class=\"me1\">length</span> <span class=\"sy0\">==</span> <span class=\"nu0\">6</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">// Six parameters.</span><br/>    <span class=\"kw4\">static</span> <span class=\"kw2\">assert</span><span class=\"br0\">(</span>psct<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span> <span class=\"sy0\">==</span> STC.<span class=\"me1\">none</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw4\">static</span> <span class=\"kw2\">assert</span><span class=\"br0\">(</span>psct<span class=\"br0\">[</span><span class=\"nu0\">1</span><span class=\"br0\">]</span> <span class=\"sy0\">==</span> STC.<span class=\"me1\">none</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw4\">static</span> <span class=\"kw2\">assert</span><span class=\"br0\">(</span>psct<span class=\"br0\">[</span><span class=\"nu0\">2</span><span class=\"br0\">]</span> <span class=\"sy0\">==</span> STC.<span class=\"me1\">ref_</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw4\">static</span> <span class=\"kw2\">assert</span><span class=\"br0\">(</span>psct<span class=\"br0\">[</span><span class=\"nu0\">3</span><span class=\"br0\">]</span> <span class=\"sy0\">==</span> STC.<span class=\"me1\">out_</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw4\">static</span> <span class=\"kw2\">assert</span><span class=\"br0\">(</span>psct<span class=\"br0\">[</span><span class=\"nu0\">4</span><span class=\"br0\">]</span> <span class=\"sy0\">==</span> STC.<span class=\"me1\">lazy_</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw4\">static</span> <span class=\"kw2\">assert</span><span class=\"br0\">(</span>psct<span class=\"br0\">[</span><span class=\"nu0\">5</span><span class=\"br0\">]</span> <span class=\"sy0\">==</span> STC.<span class=\"me1\">scope_</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"co1\">// There are also inout and auto ref.</span><br/>\u00a0<br/>\u00a0<br/>    <span class=\"kw4\">int</span> foo6<span class=\"br0\">(</span><span class=\"kw4\">int</span> a<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> b<span class=\"br0\">)</span> <span class=\"br0\">{</span> <span class=\"kw1\">return</span> a <span class=\"sy0\">+</span> b<span class=\"sy0\">;</span> <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"co1\">// Is partial application possible and how:</span><br/>    <span class=\"kw2\">import</span> std.<span class=\"me1\">functional</span><span class=\"sy0\">;</span><br/>    <span class=\"kw2\">alias</span> foo6b <span class=\"sy0\">=</span> partial<span class=\"sy0\">!</span><span class=\"br0\">(</span>foo6<span class=\"sy0\">,</span> <span class=\"nu0\">5</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw2\">assert</span><span class=\"br0\">(</span>foo6b<span class=\"br0\">(</span><span class=\"nu0\">6</span><span class=\"br0\">)</span> <span class=\"sy0\">==</span> <span class=\"nu0\">11</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "D\u00e9j\u00e0 Vu", "loc": 32, "block": "<pre class=\"text highlighted_source\"># all functions used are from the standard library <br/># calling a function with no arguments:<br/>random-int<br/># calling a function with a fixed number of arguments:<br/>+ 1 2<br/># calling a function with optional arguments:<br/># optional arguments are not really possible as such<br/># generally differently named functions are used:<br/>sort [ 3 2 1 ]<br/>sort-by @len [ \"Hello\" \"World\" \"Bob\" ]<br/># calling a function with a variable number of arguments:<br/># generally with a special terminator value, which one depends<br/># on the function called<br/>concat( 1 2 3 ) <br/>[ 1 2 3 ]<br/>set{\u00a0:foo\u00a0:bar\u00a0:spam }<br/># calling a function with named arguments: not possible<br/># using a function in first-class context within an expression<br/>$ @-- @len # $ is \"compose\", so the function returned is \"one less than the length\"<br/># obtaining the return value of a function<br/># return values are always pushed on the stack, so you don't need anything special<br/>random-int<br/># discarding the return value of a function<br/>drop random-int<br/># method call:<br/>local\u00a0:do {\u00a0:nuthin @pass }<br/>do!nuthin<br/>!import!fooModule # same as eva!import\u00a0:fooModule<br/># arguments are passed by object-identity, like in Python and Lua<br/># partial application is not possible, due to the fact that<br/># a function's arity is a property of its behavior and not<br/># of its definition</pre>"}, {"lang": "Elena", "loc": 4, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>var c0\u00a0:= [ console writeLine(\"No argument provided\") ].<br/>var c2\u00a0:= (:a:b)&lt;int,int&gt;[ console printLine(\"Arguments \",a,\" and \",b,\" provided\")  ].<br/>\u00a0</pre>"}, {"lang": "Elixir", "loc": 59, "block": "<pre class=\"text highlighted_source\">\u00a0<br/># Anonymous function<br/>\u00a0<br/>foo = fn() -&gt;<br/>  IO.puts(\"foo\")<br/>end<br/>\u00a0<br/>foo()  #=&gt; undefined function foo/0<br/>foo.() #=&gt; \"foo\"<br/>\u00a0<br/># Using `def`<br/>\u00a0<br/>defmodule Foo do<br/>  def foo do<br/>    IO.puts(\"foo\")<br/>  end<br/>end<br/>\u00a0<br/>Foo.foo    #=&gt; \"foo\"<br/>Foo.foo()  #=&gt; \"foo\"<br/>\u00a0<br/>\u00a0<br/># Calling a function with a fixed number of arguments<br/>\u00a0<br/>defmodule Foo do<br/>  def foo(x) do<br/>    IO.puts(x)<br/>  end<br/>end<br/>\u00a0<br/>Foo.foo(\"foo\") #=&gt; \"foo\"<br/>\u00a0<br/># Calling a function with a default argument<br/>\u00a0<br/>defmodule Foo do<br/>  def foo(x \\\\ \"foo\") do<br/>    IO.puts(x)<br/>  end<br/>end<br/>\u00a0<br/>Foo.foo()      #=&gt; \"foo\"<br/>Foo.foo(\"bar\") #=&gt; \"bar\"<br/>\u00a0<br/># There is no such thing as a function with a variable number of arguments. So in Elixir, you'd call the function with a list<br/>\u00a0<br/>defmodule Foo do<br/>  def foo(args) when is_list(args) do<br/>    Enum.each(args, &amp;(IO.puts(&amp;1)))<br/>  end<br/>end<br/>\u00a0<br/># Calling a function with named arguments<br/>\u00a0<br/>defmodule Foo do<br/>  def foo([x: x]) do<br/>    IO.inspect(x)<br/>  end<br/>end<br/>\u00a0</pre>"}, {"lang": "Erlang", "loc": 14, "block": "<pre class=\"erlang highlighted_source\">\u00a0<br/><span class=\"re3\">no_argument</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/><span class=\"re3\">one_argument</span><span class=\"br0\">(</span> <span class=\"re5\">Arg</span> <span class=\"br0\">)</span><br/><span class=\"re3\">optional_arguments</span><span class=\"br0\">(</span> <span class=\"re5\">Arg</span><span class=\"sy1\">,</span> <span class=\"br0\">[</span><span class=\"br0\">{</span>opt1<span class=\"sy1\">,</span> <span class=\"re5\">Opt1</span><span class=\"br0\">}</span><span class=\"sy1\">,</span> <span class=\"br0\">{</span>another_opt<span class=\"sy1\">,</span> <span class=\"re5\">Another</span><span class=\"br0\">}</span><span class=\"br0\">]</span> <span class=\"br0\">)</span><br/><span class=\"re3\">variable_arguments</span><span class=\"br0\">(</span> <span class=\"br0\">[</span><span class=\"re5\">Arg1</span><span class=\"sy1\">,</span> <span class=\"re5\">Arg2</span> | <span class=\"re5\">Rest</span><span class=\"br0\">]</span> <span class=\"br0\">)</span><br/><span class=\"re3\">names_arguments</span><span class=\"br0\">(</span><span class=\"br0\">[</span><span class=\"br0\">{</span>name1<span class=\"sy1\">,</span> <span class=\"re5\">Arg1</span><span class=\"br0\">}</span><span class=\"sy1\">,</span> <span class=\"br0\">{</span>another_name<span class=\"sy1\">,</span> <span class=\"re5\">Another</span><span class=\"br0\">}</span><span class=\"br0\">]</span> <span class=\"br0\">)</span><br/><span class=\"co1\">% Statement context?</span><br/><span class=\"co1\">% First class context?</span><br/><span class=\"re5\">Result</span> <span class=\"sy3\">=</span> <span class=\"re3\">obtain_result</span><span class=\"br0\">(</span> <span class=\"re5\">Arg1</span> <span class=\"br0\">)</span><br/><span class=\"co1\">% No way to distinguish builtin/user functions</span><br/><span class=\"co1\">% Subroutines?</span><br/><span class=\"co1\">% Arguments are passed by reference, but you can not change them.</span><br/><span class=\"co1\">% Partial application is possible (a function returns a function that has one argument bound)</span><br/>\u00a0</pre>"}, {"lang": "F#", "loc": 43, "block": "<pre class=\"fsharp highlighted_source\"><span class=\"co1\">// No arguments</span><br/>noArgs<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">// Fixed number of arguments</span><br/>oneArg x<br/>\u00a0<br/><span class=\"co1\">// Optional arguments</span><br/><span class=\"co1\">// In a normal function:</span><br/>optionalArgs <span class=\"sy0\">&lt;|</span> Some<span class=\"br0\">(</span><span class=\"nu0\">5</span><span class=\"br0\">)</span> <span class=\"sy0\">&lt;|</span> None<br/><span class=\"co1\">// In a function taking a tuple:</span><br/>optionalArgsInTuple<span class=\"br0\">(</span>Some<span class=\"br0\">(</span><span class=\"nu0\">5</span><span class=\"br0\">)</span>, None<span class=\"br0\">)</span><br/><span class=\"co1\">// In a function in a type:</span><br/>foo.<span class=\"me1\">optionalArgs</span> <span class=\"nu0\">5</span><span class=\"sy0\">;;</span><br/><span class=\"co1\">// However, if you want to pass more than one paramter, the arguments must be</span><br/><span class=\"co1\">// passed in a tuple:</span><br/>foo.<span class=\"me1\">optionalArgs</span><span class=\"br0\">(</span><span class=\"nu0\">5</span>, <span class=\"nu0\">6</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">// Function with a variable number of arguments</span><br/>variableArgs <span class=\"nu0\">5</span> <span class=\"nu0\">6</span> <span class=\"nu0\">7</span> <span class=\"co1\">// etc...</span><br/>\u00a0<br/><span class=\"co1\">// Named arguments can only be used in type methods taking a tuple. The</span><br/><span class=\"co1\">// arguments can appear in any order.</span><br/>foo.<span class=\"me1\">namedArgs</span><span class=\"br0\">(</span>x <span class=\"sy0\">=</span> <span class=\"nu0\">5</span>, y <span class=\"sy0\">=</span> <span class=\"nu0\">6</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">// Using a function in a statement</span><br/><span class=\"kw1\">for</span> i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span> <span class=\"kw1\">to</span> someFunc<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">do</span><br/>    printfn <span class=\"st0\">\"Something\"</span><br/>\u00a0<br/><span class=\"co1\">// Using a function in a first-class context</span><br/>funcArgs someFunc<br/>\u00a0<br/><span class=\"co1\">// Obtaining a return value</span><br/><span class=\"kw1\">let</span> x <span class=\"sy0\">=</span> someFunc<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">// Built-in functions: do functions like (+) or (-) count? </span><br/>\u00a0<br/><span class=\"co1\">// Parameters are normally passed by value (as shown in the previous examples),</span><br/><span class=\"co1\">// but they can be passed by reference.</span><br/><span class=\"co1\">// Passing by reference:</span><br/>refArgs &amp;mutableVal<br/>\u00a0<br/><span class=\"co1\">// Partial application example</span><br/><span class=\"kw1\">let</span> add2 <span class=\"sy0\">=</span> <span class=\"br0\">(</span><span class=\"sy0\">+</span><span class=\"br0\">)</span> <span class=\"nu0\">2</span></pre>"}, {"lang": "Factor", "loc": 1, "block": "<pre class=\"text highlighted_source\">foo</pre>"}, {"lang": "Forth", "loc": 25, "block": "<pre class=\"text highlighted_source\">a-function         \\ requiring no arguments<br/>a-function         \\ with a fixed number of arguents<br/>a-function         \\ having optional arguments<br/>a-function         \\ having a variable number of arguments<br/>a-function         \\ having such named arguments as we have in Forth<br/>' a-function var\u00a0! \\ using a function in a first-class context (here: storing it in a variable)<br/>a-function         \\ in which we obtain a function's return value<br/>\u00a0<br/>                   \\ forth lacks 'statement contenxt'<br/>                   \\ forth doesn't distinguish between built-in and user-defined functions<br/>                   \\ forth doesn't distinguish between functions and subroutines<br/>                   \\ forth doesn't care about by-value or by-reference<br/>\u00a0<br/>\\ partial application is achieved by creating functions and manipulating stacks<br/>: curried  0 a-function\u00a0;<br/>: only-want-third-argument 1 2 rot a-function\u00a0;<br/>\u00a0<br/>\\ Realistic example:<br/>: move ( delta-x delta-y -- )<br/>  y +!  x +!\u00a0;<br/>\u00a0<br/>: down ( n -- )  0 swap move\u00a0;<br/>: up ( n -- )    negate down\u00a0;<br/>: right ( n -- ) 0 move\u00a0;<br/>: left ( n -- )  negate right\u00a0;</pre>"}, {"lang": "Fortran", "loc": 71, "block": "<pre class=\"fortran highlighted_source\"><span class=\"kw1\">program</span> main<br/><span class=\"kw3\">implicit</span> <span class=\"kw3\">none</span><br/><span class=\"kw3\">integer</span> <span class=\"sy0\">::</span> <span class=\"me2\">a</span><br/><span class=\"kw3\">integer</span> <span class=\"sy0\">::</span> <span class=\"me2\">f</span>, g<br/><span class=\"kw3\">logical</span> <span class=\"sy0\">::</span> <span class=\"me2\">lresult</span><br/><span class=\"kw1\">interface</span><br/>  <span class=\"kw3\">integer</span> <span class=\"kw1\">function</span> h<span class=\"br0\">(</span>a,b,c<span class=\"br0\">)</span><br/>    <span class=\"kw3\">integer</span> <span class=\"sy0\">::</span> <span class=\"me2\">a</span>, b<br/>    <span class=\"kw3\">integer</span>, <span class=\"kw3\">optional</span> <span class=\"sy0\">::</span> <span class=\"me2\">c</span><br/>  <span class=\"kw1\">end</span> <span class=\"kw1\">function</span><br/><span class=\"kw1\">end</span> <span class=\"kw1\">interface</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'no arguments: '</span>, f<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'-----------------'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'fixed arguments: '</span>, g<span class=\"br0\">(</span><span class=\"nu0\">5</span>,<span class=\"nu0\">8</span>,lresult<span class=\"br0\">)</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'-----------------'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'optional arguments: '</span>, h<span class=\"br0\">(</span><span class=\"nu0\">5</span>,<span class=\"nu0\">8</span><span class=\"br0\">)</span>, h<span class=\"br0\">(</span><span class=\"nu0\">5</span>,<span class=\"nu0\">8</span>,<span class=\"nu0\">4</span><span class=\"br0\">)</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'-----------------'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'function with variable arguments: Does not apply!'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'An option is to pass arrays of variable lengths.'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'-----------------'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'named arguments: '</span>, h<span class=\"br0\">(</span>c<span class=\"sy0\">=</span><span class=\"nu0\">4</span>,b<span class=\"sy0\">=</span><span class=\"nu0\">8</span>,a<span class=\"sy0\">=</span><span class=\"nu0\">5</span><span class=\"br0\">)</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'-----------------'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'function in statement context: Does not apply!'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'-----------------'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'Fortran passes memory location of variables as arguments.'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'So an argument can hold the return value.'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'function result: '</span>, g<span class=\"br0\">(</span><span class=\"nu0\">5</span>,<span class=\"nu0\">8</span>,lresult<span class=\"br0\">)</span> , <span class=\"st0\">' function successful? '</span>, lresult<br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'-----------------'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'Distinguish between built-in and user-defined functions: Does not apply!'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'-----------------'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'Calling a subroutine: '</span><br/>a <span class=\"sy0\">=</span> <span class=\"nu0\">30</span><br/><span class=\"co1\">call sub(a)</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'Function call: '</span>, f<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'-----------------'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'All variables are passed as pointers.'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'Problems can arise if instead of sub(a), one uses sub(10).'</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'-----------------'</span><br/><span class=\"kw1\">end</span> <span class=\"kw1\">program</span><br/>\u00a0<br/><span class=\"co1\">!no argument</span><br/><span class=\"kw3\">integer</span> <span class=\"kw1\">function</span> f<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>f <span class=\"sy0\">=</span> <span class=\"nu0\">10</span><br/><span class=\"kw1\">end</span> <span class=\"kw1\">function</span><br/>\u00a0<br/><span class=\"co1\">!fixed number of arguments</span><br/><span class=\"kw3\">integer</span> <span class=\"kw1\">function</span> g<span class=\"br0\">(</span>a, b, lresult<span class=\"br0\">)</span><br/><span class=\"kw3\">integer</span> <span class=\"sy0\">::</span> <span class=\"me2\">a</span>, b<br/><span class=\"kw3\">logical</span> <span class=\"sy0\">::</span> <span class=\"me2\">lresult</span><br/>g <span class=\"sy0\">=</span> a<span class=\"sy0\">+</span>b<br/>lresult <span class=\"sy0\">=</span> <span class=\"kw2\">.<span class=\"me1\">TRUE</span>.</span><br/><span class=\"kw1\">end</span> <span class=\"kw1\">function</span><br/>\u00a0<br/><span class=\"co1\">!optional arguments</span><br/><span class=\"kw3\">integer</span> <span class=\"kw1\">function</span> h<span class=\"br0\">(</span>a, b, c<span class=\"br0\">)</span><br/><span class=\"kw3\">integer</span> <span class=\"sy0\">::</span> <span class=\"me2\">a</span>, b<br/><span class=\"kw3\">integer</span>, <span class=\"kw3\">optional</span> <span class=\"sy0\">::</span> <span class=\"me2\">c</span><br/>\u00a0<br/>h <span class=\"sy0\">=</span> a<span class=\"sy0\">+</span>b<br/><span class=\"kw1\">if</span><span class=\"br0\">(</span><span class=\"kw4\">present</span><span class=\"br0\">(</span>c<span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"kw1\">then</span><br/>  h <span class=\"sy0\">=</span> h<span class=\"sy0\">+</span><span class=\"nu0\">10</span><span class=\"sy0\">*</span>c<br/><span class=\"kw1\">end</span> <span class=\"kw1\">if</span><br/><span class=\"kw1\">end</span> <span class=\"kw1\">function</span><br/>\u00a0<br/><span class=\"co1\">!subroutine</span><br/><span class=\"kw1\">subroutine</span> sub<span class=\"br0\">(</span>a<span class=\"br0\">)</span><br/><span class=\"kw3\">integer</span> <span class=\"sy0\">::</span> <span class=\"me2\">a</span><br/>a <span class=\"sy0\">=</span> a<span class=\"sy0\">*</span><span class=\"nu0\">100</span><br/>write<span class=\"br0\">(</span><span class=\"sy0\">*</span>,<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"st0\">'Output of subroutine: '</span>, a<br/><span class=\"kw1\">end</span> <span class=\"kw1\">subroutine</span><br/>\u00a0</pre>"}, {"lang": "Fortress", "loc": 40, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>component call_a_function<br/>  export Executable<br/>  (* Declaring test functions that allow the various ways to call functions in Fortress to be demonstrated. *)<br/>  addition(i:ZZ32, j:ZZ32): ZZ32 = i+j<br/>  addition(i:ZZ32): ZZ32 = i+1<br/>\u00a0<br/>  (* Strings are concatenated by using a space as an infix operator. *)<br/>  addition(i:String, j:String): String = i j<br/>\u00a0<br/>  printAString(s:String): () = println(s)<br/>\u00a0<br/>  (* Functions can be passed to other functions as arguments. When passing a function as an argument, the argument's type should be <br/>  represented as follows: \"typeOfArgument(s)-&gt;returnType,\" which, in this case, is \"String-&gt;().\" You could also technically use the <br/>  \"Any\" type, but that isn't type-safe. *)<br/>  printAString(s:String, f:String-&gt;()) = f(s)<br/>\u00a0<br/>  (* Defined functions can then be called as follows. *)<br/>  var x:ZZ32 = addition(1, 2)<br/>  var str:String = addition(\"This is \", \"another string.\")<br/>\u00a0<br/>  run() = do<br/>    (* You can call built-in functions the same way that you call functions that you define. *)<br/>    println(\"x at start: \" x)<br/>\u00a0<br/>    x\u00a0:= addition(x, 2)<br/>\u00a0<br/>    println(\"x at middle: \" x)<br/>\u00a0<br/>    printAString(\"This \" \"is \" \"a \" \"string.\")<br/>    printAString(str)<br/>    printAString(\"\\nThis is a string that is being printed by a function of the same name \\nthat takes a function as an argument.\\n\",<br/>      printAString)<br/>\u00a0<br/>    x\u00a0:= addition(4)<br/>\u00a0<br/>    println(\"x at end: \" x)<br/>  end<br/>end<br/>\u00a0</pre>"}, {"lang": "Gambas", "loc": 25, "block": "<pre class=\"gambas highlighted_source\"><a href=\"http://gambasdoc.org/help/lang/public\"><span class=\"kw1\">Public</span></a> <a href=\"http://gambasdoc.org/help/lang/sub\"><span class=\"kw1\">Sub</span></a> Main<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/>Hello<br/><a href=\"http://gambasdoc.org/help/lang/print\"><span class=\"kw1\">Print</span></a> CopyIt<span class=\"br0\">(</span><span class=\"st0\">\"Hello \"</span>, <span class=\"nu0\">6</span><span class=\"br0\">)</span><br/><a href=\"http://gambasdoc.org/help/lang/print\"><span class=\"kw1\">Print</span></a> CopyIt<span class=\"br0\">(</span><span class=\"st0\">\"Hello \"</span>, <span class=\"nu0\">3</span>, <span class=\"st0\">\"!!\"</span><span class=\"br0\">)</span><br/>\u00a0<br/><a href=\"http://gambasdoc.org/help/lang/end\"><span class=\"kw1\">End</span></a><br/><span class=\"co1\">'_____________________________________________________________________________________</span><br/><a href=\"http://gambasdoc.org/help/lang/public\"><span class=\"kw1\">Public</span></a> <a href=\"http://gambasdoc.org/help/lang/sub\"><span class=\"kw1\">Sub</span></a> CopyIt<span class=\"br0\">(</span>sString <a href=\"http://gambasdoc.org/help/lang/as\"><span class=\"kw1\">As</span></a> <a href=\"http://gambasdoc.org/help/lang/type/string\"><span class=\"kw4\">String</span></a>, siNo <a href=\"http://gambasdoc.org/help/lang/as\"><span class=\"kw1\">As</span></a> <a href=\"http://gambasdoc.org/help/lang/type/short\"><span class=\"kw4\">Short</span></a>, <a href=\"http://gambasdoc.org/help/lang/optional\"><span class=\"kw1\">Optional</span></a> sEnd <a href=\"http://gambasdoc.org/help/lang/as\"><span class=\"kw1\">As</span></a> <a href=\"http://gambasdoc.org/help/lang/type/string\"><span class=\"kw4\">String</span></a><span class=\"br0\">)</span> <a href=\"http://gambasdoc.org/help/lang/as\"><span class=\"kw1\">As</span></a> <a href=\"http://gambasdoc.org/help/lang/type/string\"><span class=\"kw4\">String</span></a><br/><a href=\"http://gambasdoc.org/help/lang/dim\"><span class=\"kw1\">Dim</span></a> siCount <a href=\"http://gambasdoc.org/help/lang/as\"><span class=\"kw1\">As</span></a> <a href=\"http://gambasdoc.org/help/lang/type/short\"><span class=\"kw4\">Short</span></a><br/><a href=\"http://gambasdoc.org/help/lang/dim\"><span class=\"kw1\">Dim</span></a> sNewString <a href=\"http://gambasdoc.org/help/lang/as\"><span class=\"kw1\">As</span></a> <a href=\"http://gambasdoc.org/help/lang/type/string\"><span class=\"kw4\">String</span></a><br/>\u00a0<br/><a href=\"http://gambasdoc.org/help/lang/for\"><span class=\"kw1\">For</span></a> siCount <span class=\"sy0\">=</span> <span class=\"nu0\">1</span> <a href=\"http://gambasdoc.org/help/lang/to\"><span class=\"kw1\">To</span></a> siNo<br/>  sNewString <span class=\"sy0\">&amp;=</span> sString<br/><a href=\"http://gambasdoc.org/help/lang/next\"><span class=\"kw1\">Next</span></a><br/>\u00a0<br/><a href=\"http://gambasdoc.org/help/lang/return\"><span class=\"kw1\">Return</span></a> <a href=\"http://gambasdoc.org/help/lang/trim\"><span class=\"kw2\">Trim</span></a><span class=\"br0\">(</span>sNewString<span class=\"br0\">)</span> <span class=\"sy0\">&amp;</span> sEnd<br/>\u00a0<br/><a href=\"http://gambasdoc.org/help/lang/end\"><span class=\"kw1\">End</span></a><br/><span class=\"co1\">'_____________________________________________________________________________________</span><br/><a href=\"http://gambasdoc.org/help/lang/public\"><span class=\"kw1\">Public</span></a> <a href=\"http://gambasdoc.org/help/lang/sub\"><span class=\"kw1\">Sub</span></a> Hello<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/><a href=\"http://gambasdoc.org/help/lang/print\"><span class=\"kw1\">Print</span></a> <span class=\"st0\">\"Hello world!\"</span><br/>\u00a0<br/><a href=\"http://gambasdoc.org/help/lang/end\"><span class=\"kw1\">End</span></a></pre>"}, {"lang": "Go", "loc": 11, "block": "<pre class=\"go highlighted_source\"><span class=\"kw1\">import</span> <span class=\"sy1\">(</span><br/>\t<span class=\"st0\">\"image\"</span><br/>\t<span class=\"st0\">\"image/gif\"</span><br/>\t<span class=\"st0\">\"io/ioutil\"</span><br/>\t<span class=\"st0\">\"strings\"</span><br/>\t<span class=\"st0\">\"unicode\"</span><br/><span class=\"sy1\">)</span><br/>\u00a0<br/><span class=\"kw4\">func</span> f<span class=\"sy1\">()</span> <span class=\"sy1\">(</span><span class=\"kw4\">int</span><span class=\"sy1\">,</span> <span class=\"kw4\">float64</span><span class=\"sy1\">)</span>  <span class=\"sy1\">{</span> <span class=\"kw1\">return</span> <span class=\"nu0\">0</span><span class=\"sy1\">,</span> <span class=\"nu0\">0</span> <span class=\"sy1\">}</span><br/><span class=\"kw4\">func</span> g<span class=\"sy1\">(</span><span class=\"kw4\">int</span><span class=\"sy1\">,</span> <span class=\"kw4\">float64</span><span class=\"sy1\">)</span> <span class=\"kw4\">int</span> <span class=\"sy1\">{</span> <span class=\"kw1\">return</span> <span class=\"nu0\">0</span> <span class=\"sy1\">}</span><br/><span class=\"kw4\">func</span> h<span class=\"sy1\">(</span><span class=\"kw4\">string</span><span class=\"sy1\">,</span> <span class=\"sy4\">...</span><span class=\"kw4\">int</span><span class=\"sy1\">)</span>   <span class=\"sy1\">{}</span></pre>"}, {"lang": "Haskell", "loc": 30, "block": "<pre class=\"haskell highlighted_source\">\u00a0<br/><span class=\"co1\">-- Calling a function with a fixed number of arguments</span><br/>multiply x y <span class=\"sy0\">=</span> x <span class=\"sy0\">*</span> y<br/>multiply <span class=\"nu0\">10</span> <span class=\"nu0\">20</span> <span class=\"co1\">-- returns 200</span><br/>\u00a0<br/><span class=\"co1\">-- Calling a function that requires no arguments</span><br/><span class=\"co1\">-- Normally, you use constant instead of function without arguments:</span><br/>twopi <span class=\"sy0\">=</span> <span class=\"nu0\">6.28</span><br/><span class=\"co1\">-- But you can also pass special value as the first argument indicating function call:</span><br/>twopi <span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"nu0\">6.28</span> <span class=\"co1\">-- definition</span><br/>twopi <span class=\"sy0\">::</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:Num\"><span class=\"kw4\">Num</span></a> a <span class=\"sy0\">=&gt;</span> <span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">-&gt;</span> a <span class=\"co1\">-- its type</span><br/>twopi <span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"co1\">-- returns 6.28</span><br/>\u00a0<br/><span class=\"co1\">-- Partial application and auto-currying is built-in.</span><br/>multiply<span class=\"sy0\">_</span>by<span class=\"sy0\">_</span>10 <span class=\"sy0\">=</span> <span class=\"br0\">(</span><span class=\"nu0\">10</span> <span class=\"sy0\">*</span> <span class=\"br0\">)</span><br/><a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:map\"><span class=\"kw3\">map</span></a> multiply<span class=\"sy0\">_</span>by<span class=\"sy0\">_</span>10 <span class=\"br0\">[</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"br0\">]</span> <span class=\"co1\">-- [10, 20, 30]</span><br/>multiply<span class=\"sy0\">_</span>all<span class=\"sy0\">_</span>by<span class=\"sy0\">_</span>10 <span class=\"sy0\">=</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#v:map\"><span class=\"kw3\">map</span></a> multiply<span class=\"sy0\">_</span>by<span class=\"sy0\">_</span>10<br/>multiply<span class=\"sy0\">_</span>all<span class=\"sy0\">_</span>by<span class=\"sy0\">_</span>10 <span class=\"br0\">[</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"br0\">]</span> <span class=\"co1\">-- [10, 20, 30]</span><br/>\u00a0<br/><span class=\"co1\">-- TODO:</span><br/><span class=\"co1\">-- Calling a function with optional arguments</span><br/><span class=\"co1\">-- Calling a function with a variable number of arguments</span><br/><span class=\"co1\">-- Calling a function with named arguments</span><br/><span class=\"co1\">-- Using a function in statement context</span><br/><span class=\"co1\">-- Using a function in first-class context within an expression</span><br/><span class=\"co1\">-- Obtaining the return value of a function</span><br/><span class=\"co1\">-- Distinguishing built-in functions and user-defined functions</span><br/><span class=\"co1\">-- Distinguishing subroutines and functions</span><br/><span class=\"co1\">-- Stating whether arguments are passed by value or by reference</span><br/>\u00a0</pre>"}, {"lang": "i", "loc": 29, "block": "<pre class=\"text highlighted_source\">//The type of the function argument determines whether or not the value is passed by reference or not.<br/>//Eg. numbers are passed by value and lists/arrays are passed by reference.<br/>\u00a0<br/>software {<br/>\tprint() \t\t\t\t\t//Calling a function with no arguments.<br/>\tprint(\"Input a number!\")\t//Calling a function with fixed arguments.<br/>\tprint(1,2,3,4,5,6,7,8,9,0) \t//Calling a function with variable arguments.<br/>\tinput = read() \t\t\t\t//Obtaining the return value of a function.<br/>\tmyprint = print<br/>\tmyprint(\"It was: \", input)\t//Calling first class functions, the same as calling ordinary functions.<br/>\u00a0<br/>\t//The only distinction that can be made between two functions is if they are 'real' or not.<br/>\tif type(myprint) = concept<br/>\t\tprint(\"myprint is a not a real function\")<br/>\telse if type(myprint) = function<br/>\t\tprint(\"myprint is a real function\")<br/>\tend<br/>\u00a0<br/>\t//Partial functions can be created with static parts.<br/>\tDebugPrint = print[\"[DEBUG] \", text]<br/>\tDebugPrint(\"partial function!\")\t\t//This would output '[DEBUG] partial function!'<br/>\u00a0<br/>\tif type(DebugPrint) = concept<br/>\t\tprint(\"DebugPrint is a not a real function\")<br/>\telse if type(DebugPrint) = function<br/>\t\tprint(\"DebugPrint is a real function\")<br/>\tend<br/>} <br/>\u00a0</pre>"}, {"lang": "Icon and Unicon", "loc": 30, "block": "<pre class=\"icon highlighted_source\"><span class=\"kw1\">procedure</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span>  <span class=\"co1\"># demonstrate and describe function calling syntax and semantics</span><br/>\u00a0<br/>   <span class=\"co1\"># normal procedure/function calling</span><br/>\u00a0<br/>   f<span class=\"br0\">(</span><span class=\"br0\">)</span>                      <span class=\"co1\"># no arguments, also command context</span><br/>   f<span class=\"br0\">(</span>x<span class=\"br0\">)</span>                     <span class=\"co1\"># fixed number of arguments</span><br/>   f<span class=\"br0\">(</span>x<span class=\"sy1\">,</span>h<span class=\"sy1\">,</span>w<span class=\"br0\">)</span>                 <span class=\"co1\"># variable number of arguments (varargs)</span><br/>   y <span class=\"sy1\">:=</span> f<span class=\"br0\">(</span>x<span class=\"br0\">)</span>                <span class=\"co1\"># Obtaining the returned value of a function</span><br/>\u00a0<br/>   <span class=\"co1\"># procedures as first class values and string invocation </span><br/>\u00a0<br/>   f<span class=\"sy1\">!</span>L                      <span class=\"co1\"># Alternate calling syntax using a list as args   </span><br/>   <span class=\"br0\">(</span><span class=\"kw1\">if</span> <span class=\"sy1\">\\</span>x <span class=\"kw1\">then</span> f <span class=\"kw1\">else</span> g<span class=\"br0\">)</span><span class=\"br0\">(</span><span class=\"br0\">)</span>  <span class=\"co1\"># call (f or g)()</span><br/>   f <span class=\"sy1\">:=</span> <span class=\"kw4\">write</span>               <span class=\"co1\"># assign a procedure</span><br/>   f<span class=\"br0\">(</span><span class=\"st0\">\"Write is now called\"</span><span class=\"br0\">)</span> <span class=\"co1\"># ... and call it</span><br/>   <span class=\"st0\">\"f\"</span><span class=\"br0\">(</span><span class=\"br0\">)</span>                    <span class=\"co1\"># string invocation, procedure</span><br/>   <span class=\"st0\">\"-\"</span><span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span>                   <span class=\"co1\"># string invocation, operator</span><br/>\u00a0<br/>   <span class=\"co1\"># Co-expressions</span><br/>\u00a0<br/>   f<span class=\"br0\">{</span>e1<span class=\"sy1\">,</span>e2<span class=\"br0\">}</span>                 <span class=\"co1\"># parallel evaluation co-expression call  </span><br/>                            <span class=\"co1\"># equivalent to f([create e1, create e2]) </span><br/>   expr <span class=\"sy1\">@</span> coexp             <span class=\"co1\"># transmission of a single value to a coexpression</span><br/>   <span class=\"br0\">[</span>e1<span class=\"sy1\">,</span>e2<span class=\"br0\">]</span><span class=\"sy1\">@</span>coexp            <span class=\"co1\"># ... of multiple values (list) to a coexpression </span><br/>   coexp<span class=\"br0\">(</span>e1<span class=\"sy1\">,</span>e2<span class=\"br0\">)</span>             <span class=\"co1\"># ... same as above but only in Unicon </span><br/>\u00a0<br/>   <span class=\"co1\"># Other</span><br/>\u00a0<br/>   f<span class=\"br0\">(</span><span class=\"st0\">\"x:=\"</span><span class=\"sy1\">,</span><span class=\"nu0\">1</span><span class=\"sy1\">,</span><span class=\"st0\">\"y:=\"</span><span class=\"sy1\">,</span><span class=\"nu0\">2</span><span class=\"br0\">)</span>       <span class=\"co1\"># named parameters (user defined)</span><br/><span class=\"kw1\">end</span></pre>"}, {"lang": "J", "loc": 2, "block": "<pre class=\"j highlighted_source\">        verb noun<br/>   noun verb noun</pre>"}, {"lang": "Java", "loc": 1, "block": "<pre class=\"java highlighted_source\">myMethod<span class=\"br0\">(</span><span class=\"br0\">)</span></pre>"}, {"lang": "JavaScript", "loc": 3, "block": "<pre class=\"javascript highlighted_source\"><span class=\"kw1\">var</span> foo <span class=\"sy0\">=</span> <span class=\"kw1\">function</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span> <span class=\"kw1\">return</span> arguments.<span class=\"me1\">length</span> <span class=\"br0\">}</span><span class=\"sy0\">;</span><br/>foo<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"co1\">// 0</span><br/>foo<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"br0\">)</span> <span class=\"co1\">// 3</span></pre>"}, {"lang": "jq", "loc": 92, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>#  Calling a function that requires no arguments:<br/>f() = print(\"Hello world!\")<br/>f()<br/>\u00a0<br/>\u00a0<br/>#  Calling a function with a fixed number of arguments:<br/>function f(x, y, z)<br/>    x*y - z^2<br/>end<br/>\u00a0<br/>f(3, 4, 2)<br/>\u00a0<br/>\u00a0<br/>#  Calling a function with optional arguments:<br/>#  Note Julia uses multiple dispatch based on argument number and type, so <br/># f() is always different from f(x) unless default arguments are used, as in:<br/>\u00a0<br/>pimultiple(mult=1.0) = pi * mult # so pimultiple() defaults to pi * (1.0) or pi<br/>\u00a0<br/>\u00a0<br/>#  Calling a function with a variable number of arguments:<br/>\u00a0<br/>f(a,b,x...) = reduce(+, 0, x) - a - b<br/>\u00a0<br/>\u00a0<br/># here a and b are single arguments, but x is a tuple of x plus whatever follows x, so:<br/>a = b = c = d = e = 3<br/>f(a,b,c)           # x within the function is (c) so == 0 + c - a - b<br/>f(a,b,c,d,e)      # x is a tuple == (c,d,e) so == (0 + c + d + e) - a - b<br/>f(a,b)             # x is () so == 0 - a - b<br/>\u00a0<br/>\u00a0<br/>#  Calling a function with named arguments:<br/># Functions with keyword arguments are defined using a semicolon in the function signature,<br/>#  as in <br/>#             function plot(x, y; style=\"solid\", width=1, color=\"black\") <br/>#<br/># When the function is called, the semicolon is optional, so plot here can be<br/># either called with plot(x, y, width=2) or less commonly as plot(x, y; width=2).<br/>\u00a0<br/>\u00a0<br/>#  Using a function in statement context:<br/>#  Any function can be used as a variable by its name.<br/>\u00a0<br/>circlearea(x) = x^2 * pi <br/>map(circlearea, [r1, r2, r3, r4])<br/>\u00a0<br/>\u00a0<br/>#  Using a function in first-class context within an expression:<br/>cylindervolume = circlearea(r) * h<br/>\u00a0<br/>\u00a0<br/>#  Obtaining the return value of a function:<br/>radius = 2.5<br/>area = circlearea(2.5)<br/>\u00a0<br/>\u00a0<br/>#  Distinguishing built-in functions and user-defined functions:<br/>#  Julia does not attempt to distinguish these in any special way, <br/>#  but at the REPL command line there is\u00a0? help available for builtin <br/>#  functions that would not generally be available for the user-defined ones.<br/>\u00a0<br/>\u00a0<br/>#  Distinguishing subroutines and functions:<br/>#  All subroutines are called functions in Julia, regardless of whether they return values.<br/>\u00a0<br/>\u00a0<br/>#  Stating whether arguments are passed by value or by reference:<br/>#  As in Python, all arguments are passed by pointer reference, but assignment to a passed argument<br/>#  only changes the variable within the function. Assignment to the values referenced by the argument <br/>## DOES however change those values. For instance:<br/>\u00a0<br/>a = 3<br/>b = [3]<br/>c = [3]<br/>\u00a0<br/>function f(x, y)<br/>    a = 0<br/>    b[1] = 0<br/>    c = [0]<br/>end # a and c are now unchanged but b = [0]<br/>\u00a0<br/>\u00a0<br/>#  Is partial application possible and how:<br/>#  In Julia, there are many different ways to compose functions. In particular, <br/>#  Julia has an \"arrow\" operator -&gt; that may be used to curry other functions.<br/>\u00a0<br/>f(a, b) = a^2 + a + b<br/>v = [4, 6, 8]<br/>map(x -&gt; f(x, 10), v)  # v = [30, 52, 82]<br/>\u00a0</pre>"}, {"lang": "Julia", "loc": 92, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>#  Calling a function that requires no arguments:<br/>f() = print(\"Hello world!\")<br/>f()<br/>\u00a0<br/>\u00a0<br/>#  Calling a function with a fixed number of arguments:<br/>function f(x, y, z)<br/>    x*y - z^2<br/>end<br/>\u00a0<br/>f(3, 4, 2)<br/>\u00a0<br/>\u00a0<br/>#  Calling a function with optional arguments:<br/>#  Note Julia uses multiple dispatch based on argument number and type, so <br/># f() is always different from f(x) unless default arguments are used, as in:<br/>\u00a0<br/>pimultiple(mult=1.0) = pi * mult # so pimultiple() defaults to pi * (1.0) or pi<br/>\u00a0<br/>\u00a0<br/>#  Calling a function with a variable number of arguments:<br/>\u00a0<br/>f(a,b,x...) = reduce(+, 0, x) - a - b<br/>\u00a0<br/>\u00a0<br/># here a and b are single arguments, but x is a tuple of x plus whatever follows x, so:<br/>a = b = c = d = e = 3<br/>f(a,b,c)           # x within the function is (c) so == 0 + c - a - b<br/>f(a,b,c,d,e)      # x is a tuple == (c,d,e) so == (0 + c + d + e) - a - b<br/>f(a,b)             # x is () so == 0 - a - b<br/>\u00a0<br/>\u00a0<br/>#  Calling a function with named arguments:<br/># Functions with keyword arguments are defined using a semicolon in the function signature,<br/>#  as in <br/>#             function plot(x, y; style=\"solid\", width=1, color=\"black\") <br/>#<br/># When the function is called, the semicolon is optional, so plot here can be<br/># either called with plot(x, y, width=2) or less commonly as plot(x, y; width=2).<br/>\u00a0<br/>\u00a0<br/>#  Using a function in statement context:<br/>#  Any function can be used as a variable by its name.<br/>\u00a0<br/>circlearea(x) = x^2 * pi <br/>map(circlearea, [r1, r2, r3, r4])<br/>\u00a0<br/>\u00a0<br/>#  Using a function in first-class context within an expression:<br/>cylindervolume = circlearea(r) * h<br/>\u00a0<br/>\u00a0<br/>#  Obtaining the return value of a function:<br/>radius = 2.5<br/>area = circlearea(2.5)<br/>\u00a0<br/>\u00a0<br/>#  Distinguishing built-in functions and user-defined functions:<br/>#  Julia does not attempt to distinguish these in any special way, <br/>#  but at the REPL command line there is\u00a0? help available for builtin <br/>#  functions that would not generally be available for the user-defined ones.<br/>\u00a0<br/>\u00a0<br/>#  Distinguishing subroutines and functions:<br/>#  All subroutines are called functions in Julia, regardless of whether they return values.<br/>\u00a0<br/>\u00a0<br/>#  Stating whether arguments are passed by value or by reference:<br/>#  As in Python, all arguments are passed by pointer reference, but assignment to a passed argument<br/>#  only changes the variable within the function. Assignment to the values referenced by the argument <br/>## DOES however change those values. For instance:<br/>\u00a0<br/>a = 3<br/>b = [3]<br/>c = [3]<br/>\u00a0<br/>function f(x, y)<br/>    a = 0<br/>    b[1] = 0<br/>    c = [0]<br/>end # a and c are now unchanged but b = [0]<br/>\u00a0<br/>\u00a0<br/>#  Is partial application possible and how:<br/>#  In Julia, there are many different ways to compose functions. In particular, <br/>#  Julia has an \"arrow\" operator -&gt; that may be used to curry other functions.<br/>\u00a0<br/>f(a, b) = a^2 + a + b<br/>v = [4, 6, 8]<br/>map(x -&gt; f(x, 10), v)  # v = [30, 52, 82]<br/>\u00a0</pre>"}, {"lang": "Kotlin", "loc": 33, "block": "<pre class=\"scala highlighted_source\"><span class=\"co1\">// version 1.0.6</span><br/>\u00a0<br/>fun fun1<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> println<span class=\"br0\">(</span><span class=\"st0\">\"No arguments\"</span><span class=\"br0\">)</span><br/>\u00a0<br/>fun fun2<span class=\"br0\">(</span>i<span class=\"sy0\">:</span> Int<span class=\"br0\">)</span> <span class=\"sy0\">=</span> println<span class=\"br0\">(</span><span class=\"st0\">\"One argument = $i\"</span><span class=\"br0\">)</span><br/>\u00a0<br/>fun fun3<span class=\"br0\">(</span>i<span class=\"sy0\">:</span> Int, j<span class=\"sy0\">:</span> Int <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> println<span class=\"br0\">(</span><span class=\"st0\">\"One required argument = $i, one optional argument = $j\"</span><span class=\"br0\">)</span><br/>\u00a0<br/>fun fun4<span class=\"br0\">(</span>vararg v<span class=\"sy0\">:</span> Int<span class=\"br0\">)</span> <span class=\"sy0\">=</span> println<span class=\"br0\">(</span><span class=\"st0\">\"Variable number of arguments = ${v.asList()}\"</span><span class=\"br0\">)</span><br/>\u00a0<br/>fun fun5<span class=\"br0\">(</span>i<span class=\"sy0\">:</span> Int<span class=\"br0\">)</span> <span class=\"sy0\">=</span> i <span class=\"sy0\">*</span> i<br/>\u00a0<br/>fun fun6<span class=\"br0\">(</span>i<span class=\"sy0\">:</span> Int, f<span class=\"sy0\">:</span> <span class=\"br0\">(</span>Int<span class=\"br0\">)</span> -<span class=\"sy0\">&gt;</span> Int<span class=\"br0\">)</span> <span class=\"sy0\">=</span> f<span class=\"br0\">(</span>i<span class=\"br0\">)</span><br/>\u00a0<br/>fun fun7<span class=\"br0\">(</span>i<span class=\"sy0\">:</span> Int<span class=\"br0\">)</span><span class=\"sy0\">:</span> Double <span class=\"sy0\">=</span> i / <span class=\"nu0\">2.0</span><br/>\u00a0<br/>fun fun8<span class=\"br0\">(</span>x<span class=\"sy0\">:</span> String<span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"br0\">{</span> y<span class=\"sy0\">:</span> String -<span class=\"sy0\">&gt;</span> x + <span class=\"st0\">\" \"</span> + y <span class=\"br0\">}</span><br/>\u00a0<br/>fun main<span class=\"br0\">(</span>args<span class=\"sy0\">:</span> Array<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    fun1<span class=\"br0\">(</span><span class=\"br0\">)</span>              <span class=\"co1\">// no arguments</span><br/>    fun2<span class=\"br0\">(</span><span class=\"nu0\">2</span><span class=\"br0\">)</span>             <span class=\"co1\">// fixed number of arguments, one here</span><br/>    fun3<span class=\"br0\">(</span><span class=\"nu0\">3</span><span class=\"br0\">)</span>             <span class=\"co1\">// optional argument, default value used here</span><br/>    fun4<span class=\"br0\">(</span><span class=\"nu0\">4</span>, <span class=\"nu0\">5</span>, <span class=\"nu0\">6</span><span class=\"br0\">)</span>       <span class=\"co1\">// variable number of arguments</span><br/>    fun3<span class=\"br0\">(</span>j <span class=\"sy0\">=</span> <span class=\"nu0\">8</span>, i <span class=\"sy0\">=</span> <span class=\"nu0\">7</span><span class=\"br0\">)</span>  <span class=\"co1\">// using named arguments, order unimportant</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> b <span class=\"sy0\">=</span> <a href=\"http://scala-lang.org\"><span class=\"kw1\">false</span></a><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>b<span class=\"br0\">)</span> fun1<span class=\"br0\">(</span><span class=\"br0\">)</span> <a href=\"http://scala-lang.org\"><span class=\"kw1\">else</span></a> fun2<span class=\"br0\">(</span><span class=\"nu0\">9</span><span class=\"br0\">)</span>        <span class=\"co1\">// statement context</span><br/>    println<span class=\"br0\">(</span><span class=\"nu0\">1</span> + fun6<span class=\"br0\">(</span><span class=\"nu0\">4</span>, <span class=\"sy0\">::</span>fun5<span class=\"br0\">)</span> + <span class=\"nu0\">3</span><span class=\"br0\">)</span>  <span class=\"co1\">// first class context within an expression</span><br/>    println<span class=\"br0\">(</span>fun5<span class=\"br0\">(</span><span class=\"nu0\">5</span><span class=\"br0\">)</span><span class=\"br0\">)</span>    <span class=\"co1\">// obtaining return value</span><br/>    println<span class=\"br0\">(</span>Math.<span class=\"me1\">round</span><span class=\"br0\">(</span><span class=\"nu0\">2.5</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"co1\">// no distinction between built-in and user-defined functions, though former usually have a receiver</span><br/>    fun1<span class=\"br0\">(</span><span class=\"br0\">)</span>              <span class=\"co1\">// calling sub-routine which has a Unit return type by default</span><br/>    println<span class=\"br0\">(</span>fun7<span class=\"br0\">(</span><span class=\"nu0\">11</span><span class=\"br0\">)</span><span class=\"br0\">)</span>   <span class=\"co1\">// calling function with a return type of Double (here explicit but can be implicit)</span><br/>    println<span class=\"br0\">(</span>fun8<span class=\"br0\">(</span><span class=\"st0\">\"Hello\"</span><span class=\"br0\">)</span><span class=\"br0\">(</span><span class=\"st0\">\"world\"</span><span class=\"br0\">)</span><span class=\"br0\">)</span>   <span class=\"co1\">// partial application isn't supported though you can do this</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "LFE", "loc": 4, "block": "<pre class=\"lisp highlighted_source\">\u00a0<br/><span class=\"br0\">(</span><span class=\"kw1\">defun</span> my-func<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span><span class=\"sy0\">:</span> <span class=\"me1\">io</span> format '<span class=\"st0\">\"I get called with NOTHING!~n\"</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0</pre>"}, {"lang": "Liberty BASIC", "loc": 44, "block": "<pre class=\"lb highlighted_source\">\u00a0<br/><span class=\"co1\">'Call a function - Liberty BASIC</span><br/>\u00a0<br/><span class=\"co1\">'First, function result could not be discarded</span><br/><span class=\"co1\">' that is, you cannot do \"f(x)\" as a separate statement</span><br/>\u00a0<br/><span class=\"co1\">'Calling a function that requires no arguments</span><br/>res <span class=\"sy0\">=</span> f<span class=\"br0\">(</span><span class=\"br0\">)</span>   <span class=\"co1\">'brackets required</span><br/>\u00a0<br/><span class=\"co1\">'Calling a function with a fixed number of arguments</span><br/>res <span class=\"sy0\">=</span> g<span class=\"br0\">(</span>x<span class=\"br0\">)</span><br/>res <span class=\"sy0\">=</span> h<span class=\"br0\">(</span>x<span class=\"sy0\">,</span>y<span class=\"br0\">)</span><br/><span class=\"co1\">'Calling a function with optional arguments</span><br/>    <span class=\"co1\">'impossible for user-defined functions</span><br/>    <span class=\"co1\">'Some build-in functions ex. INSTR and MID$ could be called with last argument omitted</span><br/><span class=\"co1\">'Calling a function with a variable number of arguments</span><br/>    <span class=\"co1\">'impossible</span><br/><span class=\"co1\">'Calling a function with named arguments</span><br/>    <span class=\"co1\">'impossible</span><br/><span class=\"co1\">'Using a function in statement context</span><br/>    <span class=\"co1\">'impossible (see starting notice)</span><br/><span class=\"co1\">'Using a function in first-class context within an expression</span><br/>    <span class=\"co1\">'impossible</span><br/><span class=\"co1\">'Obtaining the return value of a function</span><br/>res <span class=\"sy0\">=</span> g<span class=\"br0\">(</span>x<span class=\"br0\">)</span><br/><span class=\"co1\">'Distinguishing built-in functions and user-defined functions</span><br/>    <span class=\"co1\">'I would say impossible. Though built-in functions could be EVAL'ed,</span><br/>    <span class=\"co1\">'while user-defined would not be called (tries address array instead).</span><br/>    <span class=\"co1\">'Still cannot distinguish user-defined function from array.</span><br/><span class=\"co1\">'Distinguishing subroutines and functions</span><br/>    <span class=\"co1\">'then defined, subroutines and functions defined with words</span><br/>    <span class=\"co1\">'SUB and FUNCTION (case incensitive)</span><br/>    <span class=\"co1\">'Then used, function used as expression (with return value),</span><br/>    res <span class=\"sy0\">=</span> g<span class=\"br0\">(</span>x<span class=\"br0\">)</span><br/>    <span class=\"co1\">'while subroutines called with special keyword CALL and without brackets</span><br/>    <span class=\"kw1\">call</span> test x<span class=\"sy0\">,</span> y<br/><span class=\"co1\">'Stating whether arguments are passed by value or by reference</span><br/>    <span class=\"co1\">'Variables passed as arguments into functions and subs are passed \"by value\" by default</span><br/>    <span class=\"co1\">'parameters could be passed \"by reference\" if formal parameter in sub/function definition uses the \"byref\" specifier</span><br/>    <span class=\"co1\">'Then calling a function, you can prevent pass by reference by changing variable to expression</span><br/>    <span class=\"co1\">'   like x+0, x$+\"\" or just (x), (x$)</span><br/><span class=\"co1\">'Is partial application possible and how</span><br/>    <span class=\"co1\">'impossible</span><br/>\u00a0</pre>"}, {"lang": "Lingo", "loc": 3, "block": "<pre class=\"text highlighted_source\">foo()<br/>-- or alternatively:<br/>call(#foo, _movie)</pre>"}, {"lang": "Little", "loc": 35, "block": "<pre class=\"c highlighted_source\"><span class=\"co1\">// Calling a function that requires no arguments</span><br/><span class=\"kw4\">void</span> foo<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/puts.html\"><span class=\"kw3\">puts</span></a><span class=\"br0\">(</span><span class=\"st0\">\"Calling a function with no arguments\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><span class=\"br0\">}</span><br/>foo<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"co1\">// Calling a function with a fixed number of arguments</span><br/><a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/abs.html\"><span class=\"kw3\">abs</span></a><span class=\"br0\">(</span><span class=\"sy0\">-</span><span class=\"nu0\">36</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"co1\">// Calling a function with optional arguments</span><br/><a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/puts.html\"><span class=\"kw3\">puts</span></a><span class=\"br0\">(</span>nonewline<span class=\"sy0\">:</span> <span class=\"st0\">\"nonewline is an optional argument\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/puts.html\"><span class=\"kw3\">puts</span></a><span class=\"br0\">(</span><span class=\"st0\">\"<span class=\"es1\">\\n</span>\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"co1\">// Calling a function with a variable number of arguments</span><br/><span class=\"kw4\">void</span> var_arg_func<span class=\"br0\">(</span>...<span class=\"me1\">args</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/puts.html\"><span class=\"kw3\">puts</span></a><span class=\"br0\">(</span>length<span class=\"br0\">(</span>args<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>var_arg_func<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>var_arg_func<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"co1\">// Obtaining the return value of a function</span><br/><span class=\"kw4\">int</span> s <span class=\"sy0\">=</span> <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/clock.html\"><span class=\"kw3\">clock</span></a><span class=\"br0\">(</span><span class=\"st0\">\"seconds\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">//current time in seconds</span><br/><span class=\"co1\">// Calling a function with named arguments</span><br/><span class=\"co1\">// format is a named argument in Clock_format </span><br/><span class=\"kw4\">int</span> str <span class=\"sy0\">=</span> Clock_format<span class=\"br0\">(</span>s<span class=\"sy0\">,</span> format<span class=\"sy0\">:</span> <span class=\"st0\">\"%B\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/puts.html\"><span class=\"kw3\">puts</span></a><span class=\"br0\">(</span>str<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"co1\">// Stating whether arguments are passed by value or by reference</span><br/><span class=\"kw4\">void</span> f<span class=\"br0\">(</span><span class=\"kw4\">int</span> a<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> <span class=\"sy0\">&amp;</span>b<span class=\"br0\">)</span> <span class=\"br0\">{</span> a<span class=\"sy0\">++;</span> b<span class=\"sy0\">++;</span> <span class=\"br0\">}</span><br/><span class=\"br0\">{</span><br/><span class=\"kw4\">int</span> a <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/><span class=\"kw4\">int</span> b <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>\u00a0<br/>f<span class=\"br0\">(</span>a<span class=\"sy0\">,</span> <span class=\"sy0\">&amp;</span>b<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/puts.html\"><span class=\"kw3\">puts</span></a> <span class=\"br0\">(</span>a<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/puts.html\"><span class=\"kw3\">puts</span></a> <span class=\"br0\">(</span>b<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Lua", "loc": 33, "block": "<pre class=\"lua highlighted_source\"><span class=\"co1\">-- Lua functions accept any number of arguments; missing arguments are nil-padded, extras are dropped.</span><br/><span class=\"kw1\">function</span> fixed <span class=\"br0\">(</span>a<span class=\"sy0\">,</span> b<span class=\"sy0\">,</span> c<span class=\"br0\">)</span> <span class=\"kw3\">print</span><span class=\"br0\">(</span>a<span class=\"sy0\">,</span> b<span class=\"sy0\">,</span> c<span class=\"br0\">)</span> <span class=\"kw1\">end</span><br/>fixed<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"co1\">--&gt; nil nil nil</span><br/>fixed<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"sy0\">,</span> <span class=\"nu0\">4</span><span class=\"sy0\">,</span> <span class=\"nu0\">5</span><span class=\"br0\">)</span> <span class=\"co1\">--&gt; 1 2 3</span><br/>\u00a0<br/><span class=\"co1\">-- True vararg functions include a trailing ... parameter, which captures all additional arguments as a group of values.</span><br/><span class=\"kw1\">function</span> vararg <span class=\"br0\">(</span><span class=\"sy0\">...</span><span class=\"br0\">)</span> <span class=\"kw3\">print</span><span class=\"br0\">(</span><span class=\"sy0\">...</span><span class=\"br0\">)</span> <span class=\"kw1\">end</span><br/>vararg<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"sy0\">,</span> <span class=\"nu0\">4</span><span class=\"sy0\">,</span> <span class=\"nu0\">5</span><span class=\"br0\">)</span> <span class=\"co1\">-- 1 2 3 4 5</span><br/>\u00a0<br/><span class=\"co1\">-- Lua also allows dropping the parentheses if table or string literals are used as the sole argument</span><br/><span class=\"kw3\">print</span> <span class=\"st0\">\"some string\"</span><br/><span class=\"kw3\">print</span> <span class=\"br0\">{</span> foo <span class=\"sy0\">=</span> <span class=\"st0\">\"bar\"</span> <span class=\"br0\">}</span> <span class=\"co1\">-- also serves as a form of named arguments</span><br/>\u00a0<br/><span class=\"co1\">-- First-class functions in expression context</span><br/><span class=\"kw3\">print</span><span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"st0\">\"this is backwards uppercase\"</span><span class=\"br0\">)</span><span class=\"sy0\">:</span><span class=\"kw3\">gsub</span><span class=\"br0\">(</span><span class=\"st0\">\"%w+\"</span><span class=\"sy0\">,</span> <span class=\"kw1\">function</span> <span class=\"br0\">(</span>s<span class=\"br0\">)</span> <span class=\"kw1\">return</span> s<span class=\"sy0\">:</span>upper<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">:</span>reverse<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">end</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">-- Functions can return multiple values (including none), which can be counted via select()</span><br/><span class=\"kw1\">local</span> iter<span class=\"sy0\">,</span> obj<span class=\"sy0\">,</span> start <span class=\"sy0\">=</span> <span class=\"kw3\">ipairs</span> <span class=\"br0\">{</span> <span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span> <span class=\"br0\">}</span> <br/><span class=\"kw3\">print</span><span class=\"br0\">(</span>select<span class=\"br0\">(</span><span class=\"st0\">\"#\"</span><span class=\"sy0\">,</span> <span class=\"br0\">(</span><span class=\"kw1\">function</span> <span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">end</span><span class=\"br0\">)</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"co1\">--&gt; 0</span><br/><span class=\"kw3\">print</span><span class=\"br0\">(</span>select<span class=\"br0\">(</span><span class=\"st0\">\"#\"</span><span class=\"sy0\">,</span> <span class=\"kw3\">unpack</span> <span class=\"br0\">{</span> <span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"sy0\">,</span> <span class=\"nu0\">4</span> <span class=\"br0\">}</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"co1\">--&gt; 4</span><br/>\u00a0<br/><span class=\"co1\">-- Partial application</span><br/><span class=\"kw1\">function</span> prefix <span class=\"br0\">(</span>pre<span class=\"br0\">)</span><br/>    <span class=\"kw1\">return</span> <span class=\"kw1\">function</span> <span class=\"br0\">(</span>suf<span class=\"br0\">)</span> <span class=\"kw1\">return</span> pre <span class=\"sy0\">..</span> suf <span class=\"kw1\">end</span><br/><span class=\"kw1\">end</span><br/>\u00a0<br/><span class=\"kw1\">local</span> prefixed <span class=\"sy0\">=</span> prefix <span class=\"st0\">\"foo\"</span><br/><span class=\"kw3\">print</span><span class=\"br0\">(</span>prefixed <span class=\"st0\">\"bar\"</span><span class=\"sy0\">,</span> prefixed <span class=\"st0\">\"baz\"</span><span class=\"sy0\">,</span> prefixed <span class=\"st0\">\"quux\"</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">-- nil, booleans, and numbers are always passed by value. Everything else is always passed by reference.</span><br/><span class=\"co1\">-- There is no separate notion of subroutines</span><br/><span class=\"co1\">-- Built-in functions are not easily distinguishable from user-defined functions</span><br/>\u00a0</pre>"}, {"lang": "Luck", "loc": 43, "block": "<pre class=\"text highlighted_source\">/* Calling a function that requires no arguments */<br/>f();;<br/>\u00a0<br/>/* Calling a function with a fixed number of arguments */<br/>f(1,2);;<br/>\u00a0<br/>/* Calling a function with optional arguments <br/>   Note: defining the function is cumbersome but will get easier in future versions. */<br/>f(1,2,new {default with x=3, y=4});;<br/>\u00a0<br/>/* Calling a function with a variable number of arguments */<br/>printf(\"%d\u00a0%d\u00a0%d\u00a0%d\":char*,2,3,4,5);;<br/>\u00a0<br/>/* Calling a function with named arguments <br/>   Note: may get syntax sugar in future versions */<br/>f(1,2,new {default with x=3, y=4});;<br/>\u00a0<br/>/* Using a function in statement context (what?) */<br/>f();f();f();;<br/>\u00a0<br/>/* Using a function in first-class context within an expression */<br/>[1,2,3].map(string);;<br/>\u00a0<br/>/* Obtaining the return value of a function */<br/>let x:int = f();;<br/>\u00a0<br/>/* Distinguishing built-in functions and user-defined functions */<br/>/* Builtin function i.e. custom calling convention: */<br/>(@ binop \"==\" l r);;<br/>/* User defined function i.e. normal function */<br/>f(l)(r);;<br/>\u00a0<br/>/* Distinguishing subroutines and functions: both are supported, but compiler is not aware of difference */<br/>sub();;<br/>fun();;<br/>\u00a0<br/>/* Stating whether arguments are passed by value or by reference */<br/>f(value);; /* by value */<br/>f(&amp;value);; /* by pointer reference */<br/>f(ref(value));; /* by managed reference */<br/>\u00a0<br/>/* Is partial application possible and how */<br/>tasty_curry(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)(n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z);;</pre>"}, {"lang": "M2000 Interpreter", "loc": 51, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>Module CheckIt {<br/>            Dim a(4)=100<br/>            Def a(x)=x**2<br/>            Print a(2), a(@2)<br/>            Gosub a(4)<br/>            Print \"End\"<br/>            Sub a(x)<br/>                  Print \"This is sub a()\", x<br/>            End Sub<br/>}<br/>CheckIt<br/>Call CheckIt<br/>\\\\ both module and function can exist with same name<br/>Function CheckIt {<br/>            Dim a(4)=100<br/>            Def a(x)=x**2<br/>            Print a(2), a(@2)<br/>            Gosub a(4)<br/>            Print \"End\"<br/>            Sub a(x)<br/>                  Print \"This is sub a()\", x<br/>            End Sub<br/>}<br/>Call CheckIt()<br/>Call Function Checkit<br/>\\\\ if a function return a non zero number then we get error with value the returned number. Using Void we drop any return value, so no error happen.<br/>Call Void CheckIt()<br/>Call Void Function Checkit<br/>\\\\ subs are part of modules/functions (there are no global subs, but there is a way to share definitions modules from parent module).<br/>Module CheckSub {<br/>      M=1<br/>      a(100)   ' 400<br/>      a(100)  ' 800<br/>      Module Child {<br/>            M=1<br/>            a(100) ' 400<br/>            a(100) ' 800<br/>      }<br/>      Child<br/>      Sub a(x)<br/>            b(x*4)<br/>            M++<br/>      End Sub<br/>      Sub b(x)<br/>            Print x*M<br/>      End Sub<br/>}<br/>CheckSub<br/>\u00a0<br/>\u00a0</pre>"}, {"lang": "Maple", "loc": 1, "block": "<pre class=\"text highlighted_source\"> f()</pre>"}, {"lang": "Mathematica / Wolfram Language", "loc": 1, "block": "<pre class=\"text highlighted_source\">f[]</pre>"}, {"lang": "MATLAB / Octave", "loc": 51, "block": "<pre class=\"matlab highlighted_source\">\u00a0<br/>    <span class=\"co1\">% Calling a function that requires no arguments</span><br/>       <span class=\"kw1\">function</span> a=foo<span class=\"br0\">(</span><span class=\"br0\">)</span>; <br/>         a=<span class=\"nu0\">4</span>;<br/>       <span class=\"kw1\">end</span>;<br/>       x = foo<span class=\"br0\">(</span><span class=\"br0\">)</span>; <br/>    <span class=\"co1\">% Calling a function with a fixed number of arguments</span><br/>       <span class=\"kw1\">function</span> foo<span class=\"br0\">(</span>a,b,c<span class=\"br0\">)</span>; <br/>         <span class=\"co1\">%% function definition;</span><br/>       <span class=\"kw1\">end</span>;<br/>       foo<span class=\"br0\">(</span>x,y,z<span class=\"br0\">)</span>; <br/>    <span class=\"co1\">% Calling a function with optional arguments</span><br/>       <span class=\"kw1\">function</span> foo<span class=\"br0\">(</span>a,b,c<span class=\"br0\">)</span>; <br/>\t<span class=\"kw1\">if</span> nargin&lt;<span class=\"nu0\">2</span>, b=<span class=\"nu0\">0</span>; <span class=\"kw1\">end</span>;<br/>\t<span class=\"kw1\">if</span> nargin&lt;<span class=\"nu0\">3</span>, c=<span class=\"nu0\">0</span>; <span class=\"kw1\">end</span>;<br/>         <span class=\"co1\">%% function definition;</span><br/>       <span class=\"kw1\">end</span>;<br/>       foo<span class=\"br0\">(</span>x,y<span class=\"br0\">)</span>; <br/>    <span class=\"co1\">% Calling a function with a variable number of arguments</span><br/>       <span class=\"kw1\">function</span> foo<span class=\"br0\">(</span><a href=\"http://www.mathworks.com/access/helpdesk/help/techdoc/ref/varargin.html\"><span class=\"kw2\">varargin</span></a><span class=\"br0\">)</span>; <br/>\t  <span class=\"kw1\">for</span> k=<span class=\"nu0\">1</span>:<a href=\"http://www.mathworks.com/access/helpdesk/help/techdoc/ref/length.html\"><span class=\"kw2\">length</span></a><span class=\"br0\">(</span><a href=\"http://www.mathworks.com/access/helpdesk/help/techdoc/ref/varargin.html\"><span class=\"kw2\">varargin</span></a><span class=\"br0\">)</span><br/>            arg<span class=\"br0\">{</span>k<span class=\"br0\">}</span> = <a href=\"http://www.mathworks.com/access/helpdesk/help/techdoc/ref/varargin.html\"><span class=\"kw2\">varargin</span></a><span class=\"br0\">{</span>k<span class=\"br0\">}</span>;\t<br/>       <span class=\"kw1\">end</span>;<br/>       foo<span class=\"br0\">(</span>x,y<span class=\"br0\">)</span>; <br/>    <span class=\"co1\">% Calling a function with named arguments</span><br/>\t<span class=\"co1\">%% does not apply</span><br/>    <span class=\"co1\">% Using a function in statement context</span><br/>\t<span class=\"co1\">%% does not apply</span><br/>    <span class=\"co1\">% Using a function in first-class context within an expression</span><br/>    <span class=\"co1\">% Obtaining the return value of a function</span><br/>       <span class=\"kw1\">function</span> <span class=\"br0\">[</span>a,b<span class=\"br0\">]</span>=foo<span class=\"br0\">(</span><span class=\"br0\">)</span>; <br/>         a=<span class=\"nu0\">4</span>;<br/>         b=<span class=\"co2\">'result string'</span>;<br/>       <span class=\"kw1\">end</span>;<br/>       <span class=\"br0\">[</span>x,y<span class=\"br0\">]</span> = foo<span class=\"br0\">(</span><span class=\"br0\">)</span>; <br/>    <span class=\"co1\">% Distinguishing built-in functions and user-defined functions</span><br/>\tfun = <span class=\"co2\">'foo'</span>;\t<br/>\t<span class=\"kw1\">if</span> <span class=\"br0\">(</span><a href=\"http://www.mathworks.com/access/helpdesk/help/techdoc/ref/exist.html\"><span class=\"kw2\">exist</span></a><span class=\"br0\">(</span>fun,<span class=\"co2\">'builtin'</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/> \t\tprintf<span class=\"br0\">(</span><span class=\"co2\">'function\u00a0%s is a builtin\\n'</span><span class=\"br0\">)</span>;<br/>        <span class=\"kw1\">elseif</span> <span class=\"br0\">(</span><a href=\"http://www.mathworks.com/access/helpdesk/help/techdoc/ref/exist.html\"><span class=\"kw2\">exist</span></a><span class=\"br0\">(</span>fun,<span class=\"co2\">'file'</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/> \t\tprintf<span class=\"br0\">(</span><span class=\"co2\">'function\u00a0%s is user-defined\\n'</span><span class=\"br0\">)</span>;<br/>        <span class=\"kw1\">elseif</span> <span class=\"br0\">(</span><a href=\"http://www.mathworks.com/access/helpdesk/help/techdoc/ref/exist.html\"><span class=\"kw2\">exist</span></a><span class=\"br0\">(</span>fun,<span class=\"co2\">'var'</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/> \t\tprintf<span class=\"br0\">(</span><span class=\"co2\">'function\u00a0%s is a variable\\n'</span><span class=\"br0\">)</span>;<br/>        <span class=\"kw1\">else</span> <br/> \t\tprintf<span class=\"br0\">(</span><span class=\"co2\">'%s is not a function or variable.\\n'</span><span class=\"br0\">)</span>;<br/>        <span class=\"kw1\">end</span><br/>    <span class=\"co1\">% Distinguishing subroutines and functions</span><br/>        <span class=\"co1\">% there are only scripts and functions, any function declaration starts with the keyword function, otherwise it is a script that runs in the workspace</span><br/>    <span class=\"co1\">% Stating whether arguments are passed by value or by reference </span><br/>      <span class=\"co1\">% arguments are passed by value, however Matlab has delayed evaluation, such that a copy of large data structures are done only when an element is written to.  </span><br/>\u00a0</pre>"}, {"lang": "Nemerle", "loc": 57, "block": "<pre class=\"text highlighted_source\">// no arguments<br/>f()<br/>\u00a0<br/>// fixed arguments<br/>def f(a, b) { ... } // as an aside, functions defined with 'def' use type inference for parameters and return types<br/>f(1, 'a')<br/>\u00a0<br/>// optional arguments<br/>def f(a, b = 0) { ... }<br/>f(\"hello\")<br/>f(\"goodbye\", 2)<br/>f(\"hey\", b = 2) // using the name makes more sense if there's more than one optional argument, obviously<br/>\u00a0<br/>// variable number of arguments<br/>def f(params args) { ... }<br/>def g(a, b, params rest) { ... }<br/>f(1, 2, 3) // arguments should all have the same type or may be coerced to a supertype<br/>g(1.0, 2, \"a\", \"hello\")<br/>\u00a0<br/>// named arguments<br/>f(a = 'a', b = 0)<br/>f(b = 0, a = 'a')<br/>f('a', b = 0) // if mixing named and unnamed args, unnamed must be first and in correct order<br/>\u00a0<br/>// statement context<br/>if (f(foo) == 42) <br/>    WriteLine($\"$foo is the meaning to life, the universe and everything.\") <br/>else WriteLine($\"$foo is meaningless.\")<br/>\u00a0<br/>// first class function in an expression<br/>def a = numList.FoldLeft(f)<br/>\u00a0<br/>// obtaining return value<br/>def a = f(3)<br/>\u00a0<br/>// distinguishing built-in from user functions<br/>//   N/A?<br/>\u00a0<br/>// distinguishing subroutines from functions<br/>//   N/A<br/>\u00a0<br/>// stating whether passed by value or by reference<br/>//   .NET distinguishes between value types and reference types; if a reference type is passed by reference (using ref or out), <br/>//   the reference is passed by reference, which would allow a method to modify the object to which the reference refers<br/>def f(a, ref b) { ... }<br/>mutable someVar = \"hey there\" // doesn't make sense to pass immutable value by ref<br/>f(2, ref someVar)<br/>def g(a, out b) { ... }<br/>mutable someOtherVar // if passed by ref using 'out', the variable needn't be initialized<br/>g(2, out someOtherVar)<br/>\u00a0<br/>// partial application<br/>def f(a, b) { ... } <br/>def g = f(2, _)<br/>def h = f(_, 2)<br/>def a = g(3) // equivalent to: def a = f(2, 3)<br/>def b = h(3) // equivalent to: def b = f(3, 2)</pre>"}, {"lang": "Nim", "loc": 43, "block": "<pre class=\"text highlighted_source\">proc no_args() =<br/>  discard<br/># call<br/>no_args()<br/>\u00a0<br/>proc fixed_args(x, y) =<br/>  echo x<br/>  echo y<br/># calls<br/>fixed_args(1, 2)        # x=1, y=2<br/>fixed_args 1, 2         # same call<br/>1.fixed_args(2)         # same call<br/>\u00a0<br/>\u00a0<br/>proc opt_args(x=1.0) =<br/>  echo x<br/># calls<br/>opt_args()              # 1<br/>opt_args(3.141)         # 3.141<br/>\u00a0<br/>proc var_args(v: varargs[string, `$`]) =<br/>  for x in v: echo x<br/># calls<br/>var_args(1, 2, 3)       # (1, 2, 3)<br/>var_args(1, (2,3))      # (1, (2, 3))<br/>var_args()              # ()<br/>\u00a0<br/>## Named arguments<br/>fixed_args(y=2, x=1)    # x=1, y=2<br/>\u00a0<br/>## As a statement<br/>if true:<br/>  no_args()<br/>\u00a0<br/>proc return_something(x): int =<br/>  x + 1<br/>\u00a0<br/>var a = return_something(2)<br/>\u00a0<br/>## First-class within an expression<br/>let x = return_something(19) + 10<br/>let y = 19.return_something() + 10<br/>let z = 19.return_something + 10</pre>"}, {"lang": "OCaml", "loc": 1, "block": "<pre class=\"ocaml highlighted_source\">f <span class=\"br0\">(</span><span class=\"br0\">)</span></pre>"}, {"lang": "Oforth", "loc": 1, "block": "<pre class=\"text highlighted_source\">a b c f</pre>"}, {"lang": "Ol", "loc": 122, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>; note: sign \"==&gt;\" indicates expected output<br/>\u00a0<br/>;;; Calling a function that requires no arguments<br/>(define (no-args-function)<br/>   (print \"ok.\"))<br/>)<br/>\u00a0<br/>(no-args-function)<br/>; ==&gt; ok.<br/>\u00a0<br/>\u00a0<br/>;;; Calling a function with a fixed number of arguments<br/>(define (two-args-function a b)<br/>   (print \"a: \" a)<br/>   (print \"b: \" b))<br/>)<br/>\u00a0<br/>(two-args-function 8 13)<br/>; ==&gt; a: 8<br/>; ==&gt; b: 13<br/>\u00a0<br/>\u00a0<br/>;;; Calling a function with optional arguments<br/>(define (optional-args-function a . args)<br/>   (print \"a: \" a)<br/>   (if (null? args)<br/>      (print \"no optional arguments\"))<br/>   (if (less? 0 (length args))<br/>      (print \"b: \" (car args)))<br/>   (if (less? 1 (length args))<br/>      (print \"c: \" (cadr args)))<br/>  \u00a0; etc.<br/>)<br/>\u00a0<br/>(optional-args-function 3)<br/>; ==&gt; a: 3<br/>; ==&gt; no optional arguments<br/>(optional-args-function 3 8)<br/>; ==&gt; a: 3<br/>; ==&gt; b: 8<br/>(optional-args-function 3 8 13)<br/>; ==&gt; a: 3<br/>; ==&gt; b: 8<br/>; ==&gt; c: 13<br/>(optional-args-function 3 8 13 77)<br/>; ==&gt; a: 3<br/>; ==&gt; b: 8<br/>; ==&gt; c: 13<br/>\u00a0<br/>\u00a0<br/>;;; Calling a function with a variable number of arguments<br/>; /same as optional arguments<br/>\u00a0<br/>\u00a0<br/>;;; Calling a function with named arguments<br/>; /no named arguments \"from the box\" provided, but it can be simulated using builtin maps (named \"ff\")<br/>(define (named-args-function args)<br/>   (print \"a: \" (get args 'a 8))<br/>   (print \"b: \" (get args 'b 13))<br/>)<br/>\u00a0<br/>(named-args-function #empty)<br/>; ==&gt; a: 8<br/>; ==&gt; b: 13<br/>(named-args-function (list-&gt;ff '((a . 3))))<br/>; ==&gt; a: 3<br/>; ==&gt; b: 13<br/>(named-args-function (list-&gt;ff '((b . 7))))<br/>; ==&gt; a: 8<br/>; ==&gt; b: 7<br/>(named-args-function (list-&gt;ff '((a . 3) (b . 7))))<br/>; ==&gt; a: 3<br/>; ==&gt; b: 7<br/>\u00a0<br/>\u00a0<br/>;;; Using a function in first-class context within an expression<br/>(define (first-class-arg-function arg a b)<br/>   (print (arg a b))<br/>)<br/>\u00a0<br/>(first-class-arg-function + 2 3)<br/>; ==&gt; 5<br/>(first-class-arg-function - 2 3)<br/>; ==&gt; -1<br/>\u00a0<br/>\u00a0<br/>;;; Obtaining the return value of a function<br/>(define (return-value-function)<br/>   (print \"ok.\")<br/>   123)<br/>\u00a0<br/>(let ((result (return-value-function)))<br/>   (print result))<br/>; ==&gt; ok.<br/>; ==&gt; 123<br/>; actually<br/>\u00a0<br/>\u00a0<br/>;;; Is partial application possible and how<br/>(define (make-partial-function n)<br/>   (lambda (x y)<br/>      (print (n x y)))<br/>)<br/>\u00a0<br/>(define plus (make-partial-function +))<br/>(plus 2 3)<br/>; ==&gt; 5<br/>(define minus (make-partial-function -))<br/>(minus 2 3)<br/>; ==&gt; -1<br/>\u00a0<br/>\u00a0<br/>; TBD:<br/>;;; Using a function in statement context<br/>;;; Using a function in first-class context within an expression<br/>;;; Obtaining the return value of a function<br/>;;; Distinguishing built-in functions and user-defined functions<br/>;;; Distinguishing subroutines and functions<br/>;;; Stating whether arguments are passed by value or by reference<br/>\u00a0<br/>\u00a0</pre>"}, {"lang": "PARI/GP", "loc": 7, "block": "<pre class=\"parigp highlighted_source\">f<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">\\\\ zero arguments</span><br/><span class=\"kw1\">sin</span><span class=\"br0\">(</span><span class=\"kw1\">Pi</span><span class=\"sy0\">/</span><span class=\"nu1\">2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">\\\\ fixed number of arguments</span><br/><span class=\"kw1\">vecsort</span><span class=\"br0\">(</span><span class=\"br0\">[</span><span class=\"nu1\">5</span><span class=\"sy0\">,</span><span class=\"nu1\">6</span><span class=\"br0\">]</span><span class=\"br0\">)</span> <span class=\"sy0\">!=</span> <span class=\"kw1\">vecsort</span><span class=\"br0\">(</span><span class=\"br0\">[</span><span class=\"nu1\">5</span><span class=\"sy0\">,</span><span class=\"nu1\">6</span><span class=\"br0\">]</span><span class=\"sy0\">,,</span><span class=\"nu1\">4</span><span class=\"br0\">)</span> <span class=\"co1\">\\\\ optional arguments</span><br/><span class=\"kw1\">Str</span><span class=\"br0\">(</span><span class=\"st0\">\"gg\"</span><span class=\"sy0\">,</span> <span class=\"nu1\">1</span><span class=\"sy0\">,</span> <span class=\"st0\">\"hh\"</span><span class=\"br0\">)</span> <span class=\"co1\">\\\\ variable number of arguments</span><br/>call<span class=\"br0\">(</span><span class=\"kw1\">Str</span><span class=\"sy0\">,</span> <span class=\"br0\">[</span><span class=\"st0\">\"gg\"</span><span class=\"sy0\">,</span> <span class=\"nu1\">1</span><span class=\"sy0\">,</span> <span class=\"st0\">\"hh\"</span><span class=\"br0\">]</span><span class=\"br0\">)</span> <span class=\"co1\">\\\\ variable number of arguments in a vector</span><br/><span class=\"br0\">(</span>x<span class=\"sy0\">-&gt;</span>x<span class=\"sy0\">^</span><span class=\"nu1\">2</span><span class=\"br0\">)</span><span class=\"br0\">(</span><span class=\"nu1\">3</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">\\\\ first-class</span><br/>x <span class=\"sy0\">=</span> <span class=\"kw1\">sin</span><span class=\"br0\">(</span><span class=\"nu1\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">\\\\ get function value</span></pre>"}, {"lang": "Perl", "loc": 4, "block": "<pre class=\"perl highlighted_source\">foo<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span>              <span class=\"co1\"># Call foo on the null list</span><br/><span class=\"re0\">&amp;foo</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span>             <span class=\"co1\"># Ditto</span><br/>foo<span class=\"br0\">(</span><span class=\"re0\">$arg1</span><span class=\"sy0\">,</span> <span class=\"re0\">$arg2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span>  <span class=\"co1\"># Call foo on $arg1 and $arg2</span><br/><span class=\"re0\">&amp;foo</span><span class=\"br0\">(</span><span class=\"re0\">$arg1</span><span class=\"sy0\">,</span> <span class=\"re0\">$arg2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\"># Ditto; ignores prototypes</span></pre>"}, {"lang": "Perl 6", "loc": 8, "block": "<pre class=\"perl6 highlighted_source\">foo               <span class=\"co1\"># as list operator</span><br/>foo<span class=\"br0\">(</span><span class=\"br0\">)</span>             <span class=\"co1\"># as function</span><br/>foo<span class=\"sy0\">.</span><span class=\"br0\">(</span><span class=\"br0\">)</span>            <span class=\"co1\"># as function, explicit postfix form</span><br/><span class=\"re0\">$ref</span><span class=\"br0\">(</span><span class=\"br0\">)</span>            <span class=\"co1\"># as object invocation</span><br/><span class=\"re0\">$ref</span><span class=\"sy0\">.</span><span class=\"br0\">(</span><span class=\"br0\">)</span>           <span class=\"co1\"># as object invocation, explicit postfix</span><br/><span class=\"re0\">&amp;foo</span><span class=\"br0\">(</span><span class=\"br0\">)</span>            <span class=\"co1\"># as object invocation</span><br/><span class=\"re0\">&amp;foo</span><span class=\"sy0\">.</span><span class=\"br0\">(</span><span class=\"br0\">)</span>           <span class=\"co1\"># as object invocation, explicit postfix</span><br/><span class=\"sy0\">::</span><span class=\"br0\">(</span><span class=\"re0\">$name</span><span class=\"br0\">)</span><span class=\"br0\">(</span><span class=\"br0\">)</span>       <span class=\"co1\"># as symbolic ref</span></pre>"}, {"lang": "Phix", "loc": 1, "block": "<pre class=\"text highlighted_source\">{} = myfunction()</pre>"}, {"lang": "PicoLisp", "loc": 2, "block": "<pre class=\"text highlighted_source\">(foo)<br/>(bar 1 'arg 2 'mumble)</pre>"}, {"lang": "Python", "loc": 70, "block": "<pre class=\"python highlighted_source\"><span class=\"kw1\">def</span> no_args<span class=\"br0\">(</span><span class=\"br0\">)</span>:<br/>    <span class=\"kw1\">pass</span><br/><span class=\"co1\"># call</span><br/>no_args<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"kw1\">def</span> fixed_args<span class=\"br0\">(</span>x<span class=\"sy0\">,</span> y<span class=\"br0\">)</span>:<br/>    <span class=\"kw1\">print</span><span class=\"br0\">(</span><span class=\"st0\">'x=%r, y=%r'</span>\u00a0% <span class=\"br0\">(</span>x<span class=\"sy0\">,</span> y<span class=\"br0\">)</span><span class=\"br0\">)</span><br/><span class=\"co1\"># call</span><br/>fixed_args<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span>        <span class=\"co1\"># x=1, y=2</span><br/>\u00a0<br/><span class=\"co1\">## Can also called them using the parameter names, in either order:</span><br/>fixed_args<span class=\"br0\">(</span>y<span class=\"sy0\">=</span><span class=\"nu0\">2</span><span class=\"sy0\">,</span> x<span class=\"sy0\">=</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">## Can also \"apply\" fixed_args() to a sequence:</span><br/>myargs<span class=\"sy0\">=</span><span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span><span class=\"nu0\">2</span><span class=\"br0\">)</span> <span class=\"co1\"># tuple</span><br/>fixed_args<span class=\"br0\">(</span>*myargs<span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"kw1\">def</span> opt_args<span class=\"br0\">(</span>x<span class=\"sy0\">=</span><span class=\"nu0\">1</span><span class=\"br0\">)</span>:<br/>    <span class=\"kw1\">print</span><span class=\"br0\">(</span>x<span class=\"br0\">)</span><br/><span class=\"co1\"># calls</span><br/>opt_args<span class=\"br0\">(</span><span class=\"br0\">)</span>              <span class=\"co1\"># 1</span><br/>opt_args<span class=\"br0\">(</span><span class=\"nu0\">3.141</span><span class=\"br0\">)</span>         <span class=\"co1\"># 3.141</span><br/>\u00a0<br/><span class=\"kw1\">def</span> var_args<span class=\"br0\">(</span>*v<span class=\"br0\">)</span>:<br/>    <span class=\"kw1\">print</span><span class=\"br0\">(</span>v<span class=\"br0\">)</span><br/><span class=\"co1\"># calls\t</span><br/>var_args<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"sy0\">,</span> <span class=\"nu0\">3</span><span class=\"br0\">)</span>       <span class=\"co1\"># (1, 2, 3)</span><br/>var_args<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"br0\">(</span><span class=\"nu0\">2</span><span class=\"sy0\">,</span><span class=\"nu0\">3</span><span class=\"br0\">)</span><span class=\"br0\">)</span>      <span class=\"co1\"># (1, (2, 3))</span><br/>var_args<span class=\"br0\">(</span><span class=\"br0\">)</span>              <span class=\"co1\"># ()</span><br/>\u00a0<br/><span class=\"co1\">## Named arguments</span><br/>fixed_args<span class=\"br0\">(</span>y<span class=\"sy0\">=</span><span class=\"nu0\">2</span><span class=\"sy0\">,</span> x<span class=\"sy0\">=</span><span class=\"nu0\">1</span><span class=\"br0\">)</span>    <span class=\"co1\"># x=1, y=2</span><br/>\u00a0<br/><span class=\"co1\">## As a statement</span><br/><span class=\"kw1\">if</span> <span class=\"nu0\">1</span>:<br/>    no_args<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">## First-class within an expression</span><br/><span class=\"kw1\">assert</span> no_args<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">is</span> <span class=\"kw2\">None</span><br/>\u00a0<br/><span class=\"kw1\">def</span> return_something<span class=\"br0\">(</span><span class=\"br0\">)</span>:<br/>    <span class=\"kw1\">return</span> <span class=\"nu0\">1</span><br/>x <span class=\"sy0\">=</span> return_something<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"kw1\">def</span> is_builtin<span class=\"br0\">(</span>x<span class=\"br0\">)</span>:<br/>\t<span class=\"kw1\">print</span><span class=\"br0\">(</span>x.__name__ <span class=\"kw1\">in</span> <span class=\"kw2\">dir</span><span class=\"br0\">(</span>__builtins__<span class=\"br0\">)</span><span class=\"br0\">)</span><br/><span class=\"co1\"># calls</span><br/>is_builtin<span class=\"br0\">(</span><span class=\"kw2\">pow</span><span class=\"br0\">)</span>         <span class=\"co1\"># True</span><br/>is_builtin<span class=\"br0\">(</span>is_builtin<span class=\"br0\">)</span>  <span class=\"co1\"># False</span><br/>\u00a0<br/><span class=\"co1\"># Very liberal function definition</span><br/>\u00a0<br/><span class=\"kw1\">def</span> takes_anything<span class=\"br0\">(</span>*args<span class=\"sy0\">,</span> **kwargs<span class=\"br0\">)</span>:<br/>    <span class=\"kw1\">for</span> each <span class=\"kw1\">in</span> args:<br/>        <span class=\"kw1\">print</span><span class=\"br0\">(</span>each<span class=\"br0\">)</span><br/>    <span class=\"kw1\">for</span> key<span class=\"sy0\">,</span> value <span class=\"kw1\">in</span> <span class=\"kw2\">sorted</span><span class=\"br0\">(</span>kwargs.<span class=\"me1\">items</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span>:<br/>        <span class=\"kw1\">print</span><span class=\"br0\">(</span><span class=\"st0\">\"%s:%s\"</span>\u00a0% <span class=\"br0\">(</span>key<span class=\"sy0\">,</span> value<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>    <span class=\"co1\"># Passing those to another, wrapped, function:</span><br/>    wrapped_fn<span class=\"br0\">(</span>*args<span class=\"sy0\">,</span> **kwargs<span class=\"br0\">)</span><br/>    <span class=\"co1\"># (Function being wrapped can have any parameter list</span><br/>    <span class=\"co1\"># ... that doesn't have to match this prototype)</span><br/>\u00a0<br/><span class=\"co1\">## A subroutine is merely a function that has no explicit</span><br/><span class=\"co1\">## return statement and will return None.</span><br/>\u00a0<br/><span class=\"co1\">## Python uses \"Call by Object Reference\".</span><br/><span class=\"co1\">## See, for example, http://www.python-course.eu/passing_arguments.php</span><br/>\u00a0<br/><span class=\"co1\">## For partial function application see:</span><br/><span class=\"co1\">##   http://rosettacode.org/wiki/Partial_function_application#Python</span></pre>"}, {"lang": "R", "loc": 58, "block": "<pre class=\"rsplus highlighted_source\"><span class=\"co1\">### Calling a function that requires no arguments</span><br/>no_args <span class=\"sy0\">&lt;-</span> <a href=\"http://stat.ethz.ch/R-manual/R-devel/library/base/html/function.html\"><span class=\"kw2\">function</span></a><span class=\"br0\">(</span><span class=\"br0\">)</span> NULL<br/>no_args<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/>\u00a0<br/><span class=\"co1\">### Calling a function with a fixed number of arguments</span><br/>fixed_args <span class=\"sy0\">&lt;-</span> <a href=\"http://stat.ethz.ch/R-manual/R-devel/library/base/html/function.html\"><span class=\"kw2\">function</span></a><span class=\"br0\">(</span>x, y<span class=\"br0\">)</span> <a href=\"http://stat.ethz.ch/R-manual/R-devel/library/base/html/print.html\"><span class=\"kw2\">print</span></a><span class=\"br0\">(</span><a href=\"http://stat.ethz.ch/R-manual/R-devel/library/base/html/paste.html\"><span class=\"kw2\">paste</span></a><span class=\"br0\">(</span><span class=\"st0\">\"x=\"</span>, x, <span class=\"st0\">\", y=\"</span>, y, sep<span class=\"sy0\">=</span><span class=\"st0\">\"\"</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>fixed_args<span class=\"br0\">(</span><span class=\"nu0\">1</span>, <span class=\"nu0\">2</span><span class=\"br0\">)</span>        <span class=\"co1\"># x=1, y=2</span><br/>fixed_args<span class=\"br0\">(</span>y<span class=\"sy0\">=</span><span class=\"nu0\">2</span>, x<span class=\"sy0\">=</span><span class=\"nu0\">1</span><span class=\"br0\">)</span>    <span class=\"co1\"># y=1, x=2</span><br/>\u00a0<br/>\u00a0<br/><span class=\"co1\">### Calling a function with optional arguments</span><br/>opt_args <span class=\"sy0\">&lt;-</span> <a href=\"http://stat.ethz.ch/R-manual/R-devel/library/base/html/function.html\"><span class=\"kw2\">function</span></a><span class=\"br0\">(</span>x<span class=\"sy0\">=</span><span class=\"nu0\">1</span><span class=\"br0\">)</span> x<br/>opt_args<span class=\"br0\">(</span><span class=\"br0\">)</span>              <span class=\"co1\"># x=1</span><br/>opt_args<span class=\"br0\">(</span><span class=\"nu0\">3.141</span><span class=\"br0\">)</span>         <span class=\"co1\"># x=3.141</span><br/>\u00a0<br/>\u00a0<br/><span class=\"co1\">### Calling a function with a variable number of arguments</span><br/>var_args <span class=\"sy0\">&lt;-</span> <a href=\"http://stat.ethz.ch/R-manual/R-devel/library/base/html/function.html\"><span class=\"kw2\">function</span></a><span class=\"br0\">(</span>...<span class=\"br0\">)</span> <a href=\"http://stat.ethz.ch/R-manual/R-devel/library/base/html/print.html\"><span class=\"kw2\">print</span></a><span class=\"br0\">(</span><a href=\"http://stat.ethz.ch/R-manual/R-devel/library/base/html/list.html\"><span class=\"kw2\">list</span></a><span class=\"br0\">(</span>...<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>var_args<span class=\"br0\">(</span><span class=\"nu0\">1</span>, <span class=\"nu0\">2</span>, <span class=\"nu0\">3</span><span class=\"br0\">)</span><br/>var_args<span class=\"br0\">(</span><span class=\"nu0\">1</span>, <a href=\"http://stat.ethz.ch/R-manual/R-devel/library/base/html/c.html\"><span class=\"kw2\">c</span></a><span class=\"br0\">(</span><span class=\"nu0\">2</span>,<span class=\"nu0\">3</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>var_args<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/>\u00a0<br/><span class=\"co1\">### Calling a function with named arguments</span><br/>fixed_args<span class=\"br0\">(</span>y<span class=\"sy0\">=</span><span class=\"nu0\">2</span>, x<span class=\"sy0\">=</span><span class=\"nu0\">1</span><span class=\"br0\">)</span>    <span class=\"co1\"># x=1, y=2</span><br/>\u00a0<br/>\u00a0<br/><span class=\"co1\">### Using a function in statement context</span><br/><a href=\"http://stat.ethz.ch/R-manual/R-devel/library/base/html/if.html\"><span class=\"kw2\">if</span></a> <span class=\"br0\">(</span>TRUE<span class=\"br0\">)</span> no_args<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/>\u00a0<br/><span class=\"co1\">### Using a function in first-class context within an expression</span><br/><a href=\"http://stat.ethz.ch/R-manual/R-devel/library/base/html/print.html\"><span class=\"kw2\">print</span></a><span class=\"br0\">(</span>no_args<span class=\"br0\">)</span><br/>\u00a0<br/>\u00a0<br/><span class=\"co1\">### Obtaining the return value of a function</span><br/>return_something <span class=\"sy0\">&lt;-</span> <a href=\"http://stat.ethz.ch/R-manual/R-devel/library/base/html/function.html\"><span class=\"kw2\">function</span></a><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"nu0\">1</span><br/>x <span class=\"sy0\">&lt;-</span> return_something<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>x<br/>\u00a0<br/>\u00a0<br/><span class=\"co1\">### Distinguishing built-in functions and user-defined functions</span><br/><span class=\"co1\"># Not easily possible. See </span><br/><span class=\"co1\"># http://cran.r-project.org/doc/manuals/R-ints.html#g_t_002eInternal-vs-_002ePrimitive</span><br/><span class=\"co1\"># for details.</span><br/>\u00a0<br/>\u00a0<br/><span class=\"co1\">### Distinguishing subroutines and functions</span><br/><span class=\"co1\"># No such distinction.</span><br/>\u00a0<br/>\u00a0<br/><span class=\"co1\">### Stating whether arguments are passed by value or by reference</span><br/><span class=\"co1\"># Pass by value.</span><br/>\u00a0<br/>\u00a0<br/><span class=\"co1\">### Is partial application possible and how </span><br/><span class=\"co1\"># Yes, see http://rosettacode.org/wiki/Partial_function_application#R</span></pre>"}, {"lang": "Racket", "loc": 40, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>#lang racket<br/>\u00a0<br/>;; Calling a function that requires no arguments<br/>(foo)<br/>\u00a0<br/>;; Calling a function with a fixed number of arguments<br/>(foo 1 2 3)<br/>\u00a0<br/>;; Calling a function with optional arguments<br/>;; Calling a function with a variable number of arguments<br/>(foo 1 2 3)\u00a0; same in both cases<br/>\u00a0<br/>;; Calling a function with named arguments<br/>(foo 1 2 #:x 3)\u00a0; using #:keywords for the names<br/>\u00a0<br/>;; Using a function in statement context<br/>;; Using a function in first-class context within an expression<br/>;; Obtaining the return value of a function<br/>;; -&gt; Makes no sense for Racket, as well as most other functional PLs<br/>\u00a0<br/>;; Distinguishing built-in functions and user-defined functions<br/>(primitive? foo)<br/>;; but this is mostly useless, since most of Racket is implemented in<br/>;; itself<br/>\u00a0<br/>;; Distinguishing subroutines and functions<br/>;; -&gt; No difference, though `!' is an idiomatic suffix for names of<br/>;;    side-effect functions, and they usually return (void)<br/>\u00a0<br/>;; Stating whether arguments are passed by value or by reference<br/>\u00a0<br/>;; -&gt; Always by value, but it's possible to implement languages with<br/>;;    other argument passing styles, including passing arguments by<br/>;;    reference (eg, there is \"#lang algol60\")<br/>\u00a0<br/>;; Is partial application possible and how<br/>(curry foo 1 2)   \u00a0; later apply this on 3<br/>(\u03bb(x) (foo 1 2 x))\u00a0; a direct way of doing the same<br/>\u00a0</pre>"}, {"lang": "REXX", "loc": 137, "block": "<pre class=\"rexx highlighted_source\"><span class=\"coMULTI\">/*REXX program to demonstrate various methods of calling a REXX function*/</span><br/><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 Calling a function that REQUIRES no arguments.                     \u2502<br/>  \u2502                                                                    \u2502<br/>  \u2502 In the REXX language, there is no way to require the caller to not \u2502<br/>  \u2502 pass arguments, but the programmer can check if any arguments were \u2502<br/>  \u2502 (or weren't) passed.                                               \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/</span><br/>yr=yearFunc<span class=\"br0\">(</span><span class=\"br0\">)</span><br/><span class=\"kw1\">say</span> <span class=\"st0\">'year='</span> yr<br/><span class=\"kw1\">exit</span><br/>\u00a0<br/>yearFunc: <span class=\"kw1\">procedure</span><br/><span class=\"kw1\">if</span> <span class=\"kw1\">arg</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">\\</span>==<span class=\"nu0\">0</span> <span class=\"kw3\">then</span> <span class=\"kw1\">call</span> sayErr <span class=\"st0\">\"SomeFunc function won't accept arguments.\"</span><br/><span class=\"kw1\">return</span> <span class=\"kw6\">left</span><span class=\"br0\">(</span><span class=\"kw6\">date</span><span class=\"br0\">(</span><span class=\"st0\">'Sorted'</span><span class=\"br0\">)</span>,<span class=\"nu0\">3</span><span class=\"br0\">)</span><br/><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 Calling a function with a fixed number of arguments.               \u2502<br/>  \u2502                                                                    \u2502<br/>  \u2502 I take this to mean that the function requires a fixed number of   \u2502<br/>  \u2502 arguments.   As above, REXX doesn't enforce calling (or invoking)  \u2502<br/>  \u2502 a (any) function with a certain number of arguments,  but the      \u2502<br/>  \u2502 programmer can check if the correct number of arguments have been  \u2502<br/>  \u2502 specified (or not).                                                \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/</span><br/>ggg=FourFunc<span class=\"br0\">(</span><span class=\"nu0\">12</span>,abc,<span class=\"nu0\">6</span>+q,zz%2,<span class=\"st0\">'da 5th disagreement'</span><span class=\"br0\">)</span><br/><span class=\"kw1\">say</span> <span class=\"st0\">'ggg squared='</span> ggg<span class=\"sy0\">**</span><span class=\"nu0\">2</span><br/><span class=\"kw1\">exit</span><br/>\u00a0<br/>FourFunc: <span class=\"kw1\">procedure</span>; <span class=\"kw1\">parse</span> <span class=\"kw1\">arg</span> a1,a2,a3; a4=<span class=\"kw1\">arg</span><span class=\"br0\">(</span><span class=\"nu0\">4</span><span class=\"br0\">)</span>  <span class=\"coMULTI\">/*another way get a4*/</span><br/>\u00a0<br/><span class=\"kw1\">if</span> <span class=\"kw1\">arg</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">\\</span>==<span class=\"nu0\">4</span> <span class=\"kw3\">then</span> <span class=\"kw1\">do</span><br/>                  <span class=\"kw1\">call</span> sayErr <span class=\"st0\">\"FourFunc function requires 4 arguments,\"</span><br/>                  <span class=\"kw1\">call</span> sayErr <span class=\"st0\">\"but instead it found\"</span> <span class=\"kw1\">arg</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"st0\">'arguments.'</span><br/>                  <span class=\"kw1\">exit</span> <span class=\"nu0\">13</span><br/>                  <span class=\"kw3\">end</span><br/><span class=\"kw1\">return</span> a1+a2+a3+a4<br/><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 Calling a function with optional arguments.                        \u2502<br/>  \u2502                                                                    \u2502<br/>  \u2502 Note that not passing an argument isn't the same as passing a null \u2502<br/>  \u2502 argument  (a REXX variable whose value is length zero).            \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/</span><br/>x=<span class=\"nu0\">12</span>;  w=x<span class=\"sy0\">/</span><span class=\"nu0\">2</span>;  y=x<span class=\"sy0\">**</span><span class=\"nu0\">2</span>;  z=x<span class=\"sy0\">//</span><span class=\"nu0\">7</span>                <span class=\"coMULTI\">/* z  is  x  modulo seven.*/</span><br/><span class=\"kw1\">say</span> <span class=\"st0\">'sum of w, x, y, &amp; z='</span> SumIt<span class=\"br0\">(</span>w,x,y,,z<span class=\"br0\">)</span>    <span class=\"coMULTI\">/*pass 5 args, 4th is null*/</span><br/><span class=\"kw1\">exit</span><br/>\u00a0<br/>SumIt: <span class=\"kw1\">procedure</span>; sum=<span class=\"nu0\">0</span><br/>\u00a0<br/>  <span class=\"kw1\">do</span> j=<span class=\"nu0\">1</span> <span class=\"kw2\">for</span> <span class=\"kw1\">arg</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>  <span class=\"kw1\">if</span> <span class=\"kw1\">arg</span><span class=\"br0\">(</span>j,<span class=\"st0\">'E'</span><span class=\"br0\">)</span> <span class=\"kw3\">then</span> sum=sum+<span class=\"kw1\">arg</span><span class=\"br0\">(</span>j<span class=\"br0\">)</span>  <span class=\"coMULTI\">/*the Jth arg may have been omitted*/</span><br/>  <span class=\"kw3\">end</span><br/>\u00a0<br/><span class=\"kw1\">return</span> sum<br/><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 Calling a function with a variable number of arguments.            \u2502<br/>  \u2502                                                                    \u2502<br/>  \u2502 This situation isn't any different then the previous example.      \u2502<br/>  \u2502 It's up to the programmer to code how to utilize the arguments.    \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/</span><br/><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 Calling a function with named arguments.                           \u2502<br/>  \u2502                                                                    \u2502<br/>  \u2502 REXX allows almost anything to be passed, so the following is one  \u2502<br/>  \u2502 way this can be accomplished.                                      \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/</span><br/>what=parserFunc<span class=\"br0\">(</span><span class=\"st0\">'name=Luna'</span>,<span class=\"st0\">\"gravity=.1654\"</span>,<span class=\"st0\">'moon=yes'</span><span class=\"br0\">)</span><br/><span class=\"kw1\">say</span> <span class=\"st0\">'name='</span> common<span class=\"sy0\">.</span><span class=\"kw2\">name</span><br/>gr=common<span class=\"sy0\">.</span>gr<br/><span class=\"kw1\">say</span> <span class=\"st0\">'gravity='</span> gr<br/><span class=\"kw1\">exit</span><br/>\u00a0<br/>parseFunc: <span class=\"kw1\">procedure</span> <span class=\"kw1\">expose</span> common<span class=\"sy0\">.</span><br/>      <span class=\"kw1\">do</span> j=<span class=\"nu0\">1</span> <span class=\"kw2\">for</span> <span class=\"kw1\">arg</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>      <span class=\"kw1\">parse</span> <span class=\"kw2\">var</span> <span class=\"kw1\">arg</span><span class=\"br0\">(</span>j<span class=\"br0\">)</span> <span class=\"kw2\">name</span> <span class=\"st0\">'='</span> val<br/>      <span class=\"kw2\">upper</span> <span class=\"kw2\">name</span><br/>      <span class=\"kw1\">call</span> <span class=\"kw2\">value</span> <span class=\"st0\">'COMMON.'</span><span class=\"kw2\">name</span>,val<br/>      <span class=\"kw3\">end</span><br/><span class=\"kw1\">return</span> <span class=\"kw1\">arg</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 Calling a function in statement context.                           \u2502<br/>  \u2502                                                                    \u2502<br/>  \u2502 REXX allows functions to be called (invoked) two ways, the first   \u2502<br/>  \u2502 example (above) is calling a function in statement context.        \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/</span><br/><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 Calling a function in within an expression.                        \u2502<br/>  \u2502                                                                    \u2502<br/>  \u2502 This is a variant of the first example.                            \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/</span><br/>yr=yearFunc<span class=\"br0\">(</span><span class=\"br0\">)</span>+<span class=\"nu0\">20</span><br/><span class=\"kw1\">say</span> <span class=\"st0\">'two decades from now, the year will be:'</span> yr<br/><span class=\"kw1\">exit</span><br/><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 Obtaining the return value of a function.                          \u2502<br/>  \u2502                                                                    \u2502<br/>  \u2502 There are two ways to get the (return) value of a function.        \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/</span><br/>currYear=yearFunc<span class=\"br0\">(</span><span class=\"br0\">)</span><br/><span class=\"kw1\">say</span> <span class=\"st0\">'the current year is'</span> currYear<br/>\u00a0<br/><span class=\"kw1\">call</span> yearFunc<br/><span class=\"kw1\">say</span> <span class=\"st0\">'the current year is'</span> <span class=\"kw4\">result</span><br/><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 Distinguishing built-in functions and user-defined functions.      \u2502<br/>  \u2502                                                                    \u2502<br/>  \u2502 One objective of the REXX language is to allow the user to use any \u2502<br/>  \u2502 function (or subroutine) name whether or not there is a built-in   \u2502<br/>  \u2502 function with the same name  (there isn't a penality for this).    \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/</span><br/>qqq=<span class=\"kw6\">date</span><span class=\"br0\">(</span><span class=\"br0\">)</span>                      <span class=\"coMULTI\">/*number of real dates that Bob was on. */</span><br/><span class=\"kw1\">say</span> <span class=\"st0\">\"Bob's been out\"</span> qqq <span class=\"st0\">'times.'</span><br/>www=<span class=\"st0\">'DATE'</span><span class=\"br0\">(</span><span class=\"st0\">'USA'</span><span class=\"br0\">)</span>               <span class=\"coMULTI\">/*returns date in format mm/dd/yyy      */</span><br/><span class=\"kw1\">exit</span>                            <span class=\"coMULTI\">/*any function in quotes is external.   */</span><br/>\u00a0<br/><span class=\"kw6\">date</span>: <span class=\"kw1\">return</span> <span class=\"nu0\">4</span><br/><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 Distinguishing subroutines and functions.                          \u2502<br/>  \u2502                                                                    \u2502<br/>  \u2502 There is no programatic difference between subroutines and         \u2502<br/>  \u2502 functions if the subroutine returns a value  (which effectively    \u2502<br/>  \u2502 makes it a function).   REXX allows you to call a function as if   \u2502<br/>  \u2502 it were a subroutine.                                              \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/</span><br/><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 In REXX, all arguments are passed by value, never by name,  but it \u2502<br/>  \u2502 is possible to accomplish this if the variable's name is passed    \u2502<br/>  \u2502 and the subroutine/function could use the built-in-function VALUE  \u2502<br/>  \u2502 to retrieve the variable's value.                                  \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/</span><br/><span class=\"coMULTI\">/*\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510<br/>  \u2502 In the REXX language, partial application is possible, depending   \u2502<br/>  \u2502 how partial application is defined; I prefer the 1st definition (as\u2502<br/>  \u2502 (as per the \"discussion\" for \"Partial Function Application\" task:  \u2502<br/>  \u2502   1.  The \"syntactic sugar\" that allows one to write (some examples\u2502<br/>  \u2502       are:      map (f 7 9)  [1..9]                                \u2502<br/>  \u2502        or:      map(f(7,_,9),{1,...,9})                            \u2502<br/>  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518*/</span></pre>"}, {"lang": "Ring", "loc": 5, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>hello()<br/>func hello<br/>        see \"Hello from function\" + nl<br/>\u00a0</pre>"}, {"lang": "Ruby", "loc": 4, "block": "<pre class=\"ruby highlighted_source\"><span class=\"kw1\">def</span> foo<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw3\">p</span> <span class=\"st0\">\"foo\"</span> <span class=\"kw1\">end</span><br/>\u00a0<br/>foo                             <span class=\"co1\">#=&gt; \"foo\"</span><br/>foo<span class=\"br0\">(</span><span class=\"br0\">)</span>                           <span class=\"co1\">#=&gt; \"foo\"</span></pre>"}, {"lang": "Rust", "loc": 91, "block": "<pre class=\"text highlighted_source\">fn main() {<br/>    // Rust has a lot of neat things you can do with functions: let's go over the basics first<br/>    fn no_args() {}<br/>    // Run function with no arguments<br/>    no_args();<br/>\u00a0<br/>    // Calling a function with fixed number of arguments.<br/>    // adds_one takes a 32-bit signed integer and returns a 32-bit signed integer<br/>    fn adds_one(num: i32) -&gt; i32 {<br/>        // the final expression is used as the return value, though `return` may be used for early returns<br/>        num + 1<br/>    }<br/>    adds_one(1);<br/>\u00a0<br/>    // Optional arguments<br/>    // The language itself does not support optional arguments, however, you can take advantage of<br/>    // Rust's algebraic types for this purpose<br/>    fn prints_argument(maybe: Option&lt;i32&gt;) {<br/>        match maybe {<br/>            Some(num) =&gt; println!(\"{}\", num),<br/>            None =&gt; println!(\"No value given\"),<br/>        };<br/>    }<br/>    prints_argument(Some(3));<br/>    prints_argument(None);<br/>\u00a0<br/>    // You could make this a bit more ergonomic by using Rust's Into trait<br/>    fn prints_argument_into&lt;I&gt;(maybe: I)<br/>        where I: Into&lt;Option&lt;i32&gt;&gt;<br/>    {<br/>        match maybe.into() {<br/>            Some(num) =&gt; println!(\"{}\", num),<br/>            None =&gt; println!(\"No value given\"),<br/>        };<br/>    }<br/>    prints_argument_into(3);<br/>    prints_argument_into(None);<br/>\u00a0<br/>    // Rust does not support functions with variable numbers of arguments. Macros fill this niche<br/>    // (println! as used above is a macro for example)<br/>\u00a0<br/>    // Rust does not support named arguments<br/>\u00a0<br/>    // We used the no_args function above in a no-statement context<br/>\u00a0<br/>    // Using a function in an expression context<br/>    adds_one(1) + adds_one(5); // evaluates to eight<br/>\u00a0<br/>    // Obtain the return value of a function.<br/>    let two = adds_one(1);<br/>\u00a0<br/>    // In Rust there are no real built-in functions (save compiler intrinsics but these must be<br/>    // manually imported)<br/>\u00a0<br/>    // In rust there are no such thing as subroutines<br/>\u00a0<br/>    // In Rust, there are three ways to pass an object to a function each of which have very important<br/>    // distinctions when it comes to Rust's ownership model and move semantics. We may pass by<br/>    // value, by immutable reference, or mutable reference.<br/>\u00a0<br/>    let mut v = vec![1, 2, 3, 4, 5, 6];<br/>\u00a0<br/>    // By mutable reference<br/>    fn add_one_to_first_element(vector: &amp;mut Vec&lt;i32&gt;) {<br/>        vector[0] += 1;<br/>    }<br/>    add_one_to_first_element(&amp;mut v);<br/>    // By immutable reference<br/>    fn print_first_element(vector: &amp;Vec&lt;i32&gt;) {<br/>        println!(\"{}\", vector[0]);<br/>    }<br/>    print_first_element(&amp;v);<br/>\u00a0<br/>    // By value<br/>    fn consume_vector(vector: Vec&lt;i32&gt;) {<br/>        // We can do whatever we want to vector here<br/>    }<br/>    consume_vector(v);<br/>    // Due to Rust's move semantics, v is now inaccessible because it was moved into consume_vector<br/>    // and was then dropped when it went out of scope<br/>\u00a0<br/>    // Partial application is not possible in rust without wrapping the function in another<br/>    // function/closure e.g.:<br/>    fn average(x: f64, y: f64) -&gt; f64 {<br/>        (x + y) / 2.0<br/>    }<br/>    let average_with_four = |y| average(4.0, y);<br/>    average_with_four(2.0);<br/>\u00a0<br/>\u00a0<br/>}</pre>"}, {"lang": "Scala", "loc": 65, "block": "<pre class=\"scala highlighted_source\"><a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> <span class=\"sy0\">???</span> <span class=\"sy0\">=</span> <a href=\"http://scala-lang.org\"><span class=\"kw1\">throw</span></a> <a href=\"http://scala-lang.org\"><span class=\"kw1\">new</span></a> NotImplementedError <span class=\"co1\">// placeholder for implementation of hypothetical methods</span><br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> myFunction0<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"sy0\">???</span><br/>myFunction0<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"co1\">// function invoked with empty parameter list</span><br/>myFunction0   <span class=\"co1\">// function invoked with empty parameter list omitted</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> myFunction <span class=\"sy0\">=</span> <span class=\"sy0\">???</span><br/>myFunction          <span class=\"co1\">// function invoked with no arguments or empty arg list</span><br/><span class=\"coMULTI\">/* myFunction() */</span>  <span class=\"co1\">// error: does not take parameters</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> myFunction1<span class=\"br0\">(</span>x<span class=\"sy0\">:</span> String<span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"sy0\">???</span><br/>myFunction1<span class=\"br0\">(</span><span class=\"st0\">\"foobar\"</span><span class=\"br0\">)</span>     <span class=\"co1\">// function invoked with single argument</span><br/>myFunction1 <span class=\"br0\">{</span> <span class=\"st0\">\"foobar\"</span> <span class=\"br0\">}</span>  <span class=\"co1\">// function invoked with single argument provided by a block</span><br/>                          <span class=\"co1\">// (a block of code within {}'s' evaluates to the result of its last expression)</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> myFunction2<span class=\"br0\">(</span>first<span class=\"sy0\">:</span> Int, second<span class=\"sy0\">:</span> String<span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"sy0\">???</span><br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> b <span class=\"sy0\">=</span> <span class=\"st0\">\"foobar\"</span><br/>myFunction2<span class=\"br0\">(</span><span class=\"nu0\">6</span>, b<span class=\"br0\">)</span> <span class=\"co1\">// function with two arguments</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> multipleArgLists<span class=\"br0\">(</span>first<span class=\"sy0\">:</span> Int<span class=\"br0\">)</span><span class=\"br0\">(</span>second<span class=\"sy0\">:</span> Int, third<span class=\"sy0\">:</span> String<span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"sy0\">???</span><br/>multipleArgLists<span class=\"br0\">(</span><span class=\"nu0\">42</span><span class=\"br0\">)</span><span class=\"br0\">(</span><span class=\"nu0\">17</span>, <span class=\"st0\">\"foobar\"</span><span class=\"br0\">)</span>  <span class=\"co1\">// function with three arguments in two argument lists</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> myOptionalParam<span class=\"br0\">(</span>required<span class=\"sy0\">:</span> Int, optional<span class=\"sy0\">:</span> Int <span class=\"sy0\">=</span> <span class=\"nu0\">42</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"sy0\">???</span><br/>myOptionalParam<span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span>    <span class=\"co1\">// function with optional param</span><br/>myOptionalParam<span class=\"br0\">(</span><span class=\"nu0\">1</span>, <span class=\"nu0\">2</span><span class=\"br0\">)</span> <span class=\"co1\">// function with optional param provided</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> allParamsOptional<span class=\"br0\">(</span>firstOpt<span class=\"sy0\">:</span> Int <span class=\"sy0\">=</span> <span class=\"nu0\">42</span>, secondOpt<span class=\"sy0\">:</span> String <span class=\"sy0\">=</span> <span class=\"st0\">\"foobar\"</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"sy0\">???</span><br/>allParamsOptional<span class=\"br0\">(</span><span class=\"br0\">)</span>     <span class=\"co1\">// function with all optional args</span><br/><span class=\"coMULTI\">/* allParamsOptional */</span> <span class=\"co1\">// error: missing arguments for method allParamsOptional;</span><br/>                        <span class=\"co1\">//        follow with `_' if you want to treat it as a partially applied function</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> sum<span class=\"br0\">[</span>Int<span class=\"br0\">]</span><span class=\"br0\">(</span>values<span class=\"sy0\">:</span> Int<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> values.<span class=\"me1\">foldLeft</span><span class=\"br0\">(</span><span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"br0\">(</span><span class=\"br0\">(</span>a, b<span class=\"br0\">)</span> <span class=\"sy0\">=&gt;</span> a + b<span class=\"br0\">)</span><br/>sum<span class=\"br0\">(</span><span class=\"nu0\">1</span>, <span class=\"nu0\">2</span>, <span class=\"nu0\">3</span><span class=\"br0\">)</span>                <span class=\"co1\">// function accepting variable arguments as literal</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> values <span class=\"sy0\">=</span> List<span class=\"br0\">(</span><span class=\"nu0\">1</span>, <span class=\"nu0\">2</span>, <span class=\"nu0\">3</span><span class=\"br0\">)</span><br/>sum<span class=\"br0\">(</span>values<span class=\"sy0\">:</span> <span class=\"sy0\">_*</span><span class=\"br0\">)</span>             <span class=\"co1\">// function acception variable arguments from collection</span><br/>sum<span class=\"br0\">(</span><span class=\"br0\">)</span>                       <span class=\"co1\">// function accepting empty variable arguments</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> mult<span class=\"br0\">(</span>firstValue<span class=\"sy0\">:</span> Int, otherValues<span class=\"sy0\">:</span> Int<span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> otherValues.<span class=\"me1\">foldLeft</span><span class=\"br0\">(</span>firstValue<span class=\"br0\">)</span><span class=\"br0\">(</span><span class=\"br0\">(</span>a, b<span class=\"br0\">)</span> <span class=\"sy0\">=&gt;</span> a <span class=\"sy0\">*</span> b<span class=\"br0\">)</span><br/>mult<span class=\"br0\">(</span><span class=\"nu0\">1</span>, <span class=\"nu0\">2</span>, <span class=\"nu0\">3</span><span class=\"br0\">)</span>                             <span class=\"co1\">// function with non-empty variable arguments</span><br/>myOptionalParam<span class=\"br0\">(</span>required <span class=\"sy0\">=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span>             <span class=\"co1\">// function called with named arguments (all functions have named arguments)</span><br/>myFunction2<span class=\"br0\">(</span>second <span class=\"sy0\">=</span> <span class=\"st0\">\"foo\"</span>, first <span class=\"sy0\">=</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span>    <span class=\"co1\">// function with re-ordered named arguments</span><br/>mult<span class=\"br0\">(</span>firstValue <span class=\"sy0\">=</span> <span class=\"nu0\">1</span>, otherValues <span class=\"sy0\">=</span> <span class=\"nu0\">2</span>, <span class=\"nu0\">3</span><span class=\"br0\">)</span>  <span class=\"co1\">// function with named variable argument as literal</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> otherValues <span class=\"sy0\">=</span> Seq<span class=\"br0\">(</span><span class=\"nu0\">2</span>, <span class=\"nu0\">3</span><span class=\"br0\">)</span><br/>mult<span class=\"br0\">(</span><span class=\"nu0\">1</span>, otherValues <span class=\"sy0\">=</span> otherValues<span class=\"sy0\">:</span> <span class=\"sy0\">_*</span><span class=\"br0\">)</span>  <span class=\"co1\">// function with named variable argument from collection</span><br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> result <span class=\"sy0\">=</span> myFunction0<span class=\"br0\">(</span><span class=\"br0\">)</span>              <span class=\"co1\">// function called in an expression context</span><br/>myFunction0<span class=\"br0\">(</span><span class=\"br0\">)</span>                           <span class=\"co1\">// function called in statement context</span><br/><span class=\"coMULTI\">/* myOptionalParam(optional = 1, 2) */</span>  <span class=\"co1\">// error: positional after named argument.</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> transform<span class=\"br0\">[</span>In, Out<span class=\"br0\">]</span><span class=\"br0\">(</span>initial<span class=\"sy0\">:</span> In<span class=\"br0\">)</span><span class=\"br0\">(</span>transformation<span class=\"sy0\">:</span> In <span class=\"sy0\">=&gt;</span> Out<span class=\"br0\">)</span> <span class=\"sy0\">=</span> transformation<span class=\"br0\">(</span>initial<span class=\"br0\">)</span><br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> result <span class=\"sy0\">=</span> transform<span class=\"br0\">(</span><span class=\"nu0\">42</span><span class=\"br0\">)</span><span class=\"br0\">(</span>x <span class=\"sy0\">=&gt;</span> x <span class=\"sy0\">*</span> x<span class=\"br0\">)</span>  <span class=\"co1\">// function in first-class context within an expression</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> divide<span class=\"br0\">(</span>top<span class=\"sy0\">:</span> Double, bottom<span class=\"sy0\">:</span> Double<span class=\"br0\">)</span> <span class=\"sy0\">=</span> top / bottom<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> div <span class=\"sy0\">=</span> <span class=\"br0\">(</span>divide <span class=\"sy0\">_</span><span class=\"br0\">)</span>              <span class=\"co1\">// partial application -- defer application of entire arg list</span><br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> halve <span class=\"sy0\">=</span> divide<span class=\"br0\">(</span><span class=\"sy0\">_:</span> Double, <span class=\"nu0\">2</span><span class=\"br0\">)</span>  <span class=\"co1\">// partial application -- defer application of some arguments</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">class</span></a> Foo<span class=\"br0\">(</span><a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> value<span class=\"sy0\">:</span> Int<span class=\"br0\">)</span><br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> incFoo<span class=\"br0\">(</span>foo<span class=\"sy0\">:</span> Foo<span class=\"br0\">)</span> <span class=\"sy0\">=</span> foo.<span class=\"me1\">value</span> +<span class=\"sy0\">=</span> <span class=\"nu0\">1</span> <span class=\"co1\">// function showing AnyRef's are passed by reference</span><br/><span class=\"coMULTI\">/* def incInt(i: Int) = i += 1 */</span>     <span class=\"co1\">// error: += is not a member of Int</span><br/>                                      <span class=\"co1\">// (All arguments are passed by reference, but reassignment </span><br/>                                      <span class=\"co1\">// or setter must be defined on a type or a field </span><br/>                                      <span class=\"co1\">// (respectively) in order to modify its value.)</span><br/>\u00a0<br/><span class=\"co1\">// No distinction between built-in functions and user-defined functions</span><br/><span class=\"co1\">// No distinction between subroutines and functions</span></pre>"}, {"lang": "Seed7", "loc": 3, "block": "<pre class=\"text highlighted_source\">env\u00a0:= environment;     # Call a function that requires no arguments.<br/>env\u00a0:= environment();   # Alternative possibility to call of a function with no arguments.<br/>cmp\u00a0:= compare(i, j);   # Call a function with a fixed number of arguments.</pre>"}, {"lang": "Sidef", "loc": 10, "block": "<pre class=\"ruby highlighted_source\">foo<span class=\"br0\">(</span><span class=\"br0\">)</span>;                       <span class=\"co1\"># without arguments</span><br/>foo<span class=\"br0\">(</span><span class=\"nu0\">1</span>, <span class=\"nu0\">2</span><span class=\"br0\">)</span>;                   <span class=\"co1\"># with two arguments</span><br/>foo<span class=\"br0\">(</span>args...<span class=\"br0\">)</span>;                <span class=\"co1\"># with a variable number of arguments</span><br/>foo<span class=\"br0\">(</span>name: <span class=\"st0\">'Bar'</span>, age: <span class=\"nu0\">42</span><span class=\"br0\">)</span>;   <span class=\"co1\"># with named arguments</span><br/>\u00a0<br/>var f = foo;                 <span class=\"co1\"># store the function foo inside 'f'</span><br/>var result = f<span class=\"br0\">(</span><span class=\"br0\">)</span>;            <span class=\"co1\"># obtain the return value of a function</span><br/>\u00a0<br/>var arr = <span class=\"br0\">[</span><span class=\"nu0\">1</span>,<span class=\"nu0\">2</span>,<span class=\"nu0\">3</span><span class=\"br0\">]</span>;<br/>foo<span class=\"br0\">(</span>arr<span class=\"br0\">)</span>;                    <span class=\"co1\"># the arguments are passed by object-reference</span></pre>"}, {"lang": "Smalltalk", "loc": 1, "block": "<pre class=\"smalltalk highlighted_source\">f valueWithArguments: <span class=\"re5\">arguments</span>.</pre>"}, {"lang": "SSEM", "loc": 4, "block": "<pre class=\"text highlighted_source\">00110000000000100000000000000000  10. -12 to c<br/>10110000000000000000000000000000  11. 13 to CI<br/>11001111111111111111111111111111  12. -13<br/>11001000000000000000000000000000  13. 19</pre>"}, {"lang": "Swift", "loc": 35, "block": "<pre class=\"text highlighted_source\">// call a function with no args<br/>noArgs()<br/>\u00a0<br/>// call a function with one arg with no external name<br/>oneArgUnnamed(1)<br/>\u00a0<br/>// call a function with one arg with external name<br/>oneArgNamed(arg: 1)<br/>\u00a0<br/>// call a function with two args with no external names<br/>twoArgsUnnamed(1, 2)<br/>\u00a0<br/>// call a function with two args and external names<br/>twoArgsNamed(arg1: 1, arg2: 2)<br/>\u00a0<br/>// call a function with an optional arg<br/>// with arg<br/>optionalArguments(arg: 1)<br/>// without<br/>optionalArguments() // defaults to 0<br/>\u00a0<br/>// function that takes another function as arg<br/>funcArg(noArgs)<br/>\u00a0<br/>// variadic function<br/>variadic(opts: \"foo\", \"bar\")<br/>\u00a0<br/>// getting a return value<br/>let foo = returnString()<br/>\u00a0<br/>// getting a bunch of return values<br/>let (foo, bar, baz) = returnSomeValues()<br/>\u00a0<br/>// getting a bunch of return values, discarding second returned value<br/>let (foo, _, baz) = returnSomeValues()</pre>"}, {"lang": "Tcl", "loc": 7, "block": "<pre class=\"tcl highlighted_source\">aCallToACommandWithNoArguments<br/>aCallToACommandWithOne argument<br/>aCallToACommandWith arbitrarily many arguments<br/>aCallToACommandWith <span class=\"br0\">{</span><span class=\"sy0\">*</span><span class=\"br0\">}</span><span class=\"re0\">$manyArgumentsComingFromAListInAVariable</span><br/>aCallToACommandWith -oneNamed argument -andAnother namedArgument<br/>aCallToACommandWith theNameOfAnotherCommand<br/>aCallToOneCommand <span class=\"br0\">[</span>withTheResultOfAnother<span class=\"br0\">]</span></pre>"}, {"lang": "UNIX Shell", "loc": 2, "block": "<pre class=\"text highlighted_source\">sayhello    # Call a function in statement context with no arguments<br/>multiply 3 4    # Call a function in statement context with two arguments</pre>"}, {"lang": "WDTE", "loc": 20, "block": "<pre class=\"text highlighted_source\">let noargs =&gt; + 2 5;<br/>noargs -- print;<br/>\u00a0<br/>let fixedargs a b =&gt; + a b;<br/>fixedargs 3 5 -- print;<br/>\u00a0<br/>let m =&gt; import 'math';<br/>m.cos 3 -- print;<br/>\u00a0<br/># WDTE only has expressions, not statements, so statement vs.<br/># first-class context doesn't make sense.<br/>\u00a0<br/># Arguments in WDTE are technically passed by reference, in a way, but<br/># because it's a functional language and everything's immutable<br/># there's no real usability difference from that.<br/>\u00a0<br/># Partial application is possible. For example, the following<br/># evaluates `+ 3` and then passes 7 to the resulting partially applied<br/># function.<br/>(+ 3) 7 -- print;</pre>"}, {"lang": "XLISP", "loc": 19, "block": "<pre class=\"lisp highlighted_source\"><span class=\"co1\">; call a function (procedure) with no arguments:</span><br/><span class=\"br0\">(</span>foo<span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">; call a function (procedure) with arguments:</span><br/><span class=\"br0\">(</span>foo bar baz<span class=\"br0\">)</span><br/><span class=\"co1\">; the first symbol after \"(\" is the name of the function</span><br/><span class=\"co1\">; the other symbols are the arguments</span><br/>\u00a0<br/><span class=\"co1\">; call a function on a list of arguments formed at run time:</span><br/><span class=\"br0\">(</span><span class=\"kw1\">apply</span> foo bar<span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">; In a REPL, the return value will be printed.</span><br/><span class=\"co1\">; In other contexts, it can be fed as argument into a further function:</span><br/><span class=\"br0\">(</span>foo <span class=\"br0\">(</span>bar baz<span class=\"br0\">)</span><span class=\"br0\">)</span><br/><span class=\"co1\">; this calls bar on the argument baz and then calls foo on the return value</span><br/>\u00a0<br/><span class=\"co1\">; or it can simply be discarded</span><br/><span class=\"br0\">(</span>foo bar<span class=\"br0\">)</span><br/><span class=\"co1\">; nothing is done with the return value</span></pre>"}, {"lang": "XSLT", "loc": 278, "block": "<pre class=\"xml highlighted_source\"><span class=\"sc3\"><span class=\"re1\">&lt;?xml</span> <span class=\"re0\">version</span>=<span class=\"st0\">\"1.0\"</span> <span class=\"re0\">encoding</span>=<span class=\"st0\">\"UTF-8\"</span><span class=\"re2\">?&gt;</span></span><br/><span class=\"sc3\"><span class=\"re1\">&lt;xsl:stylesheet</span> <span class=\"re0\">xmlns:xsl</span>=<span class=\"st0\">\"http://www.w3.org/1999/XSL/Transform\"</span> <span class=\"re0\">version</span>=<span class=\"st0\">\"1.0\"</span><span class=\"re2\">&gt;</span></span><br/>    <span class=\"sc3\"><span class=\"re1\">&lt;xsl:output</span> <span class=\"re0\">method</span>=<span class=\"st0\">\"xml\"</span> <span class=\"re0\">indent</span>=<span class=\"st0\">\"yes\"</span><span class=\"re2\">/&gt;</span></span><br/>    <span class=\"sc3\"><span class=\"re1\">&lt;xsl:template</span> <span class=\"re0\">match</span>=<span class=\"st0\">\"/\"</span><span class=\"re2\">&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;demo<span class=\"re2\">&gt;</span></span></span><br/>            <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">                XSLT 1.0 actually defines two function-like constructs that</span><br/><span class=\"sc-1\">                are used variously depending on the context.</span><br/><span class=\"sc-1\">            --&gt;</span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;xsl:call-template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"xpath-function-demos\"</span><span class=\"re2\">/&gt;</span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;xsl:call-template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"xslt-template-demos\"</span><span class=\"re2\">/&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;/demo<span class=\"re2\">&gt;</span></span></span><br/>    <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:template<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>    <span class=\"sc3\"><span class=\"re1\">&lt;xsl:template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"xpath-function-demos\"</span><span class=\"re2\">&gt;</span></span><br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            A 'function' in XSLT 1.0 is a function that can be called from</span><br/><span class=\"sc-1\">            an XPath 1.0 expression (such as from \"select\" or \"test\"</span><br/><span class=\"sc-1\">            attribute of several XSLT elements). The following demos apply</span><br/><span class=\"sc-1\">            to these functions.</span><br/><span class=\"sc-1\">        --&gt;</span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Calling function that requires no arguments --&gt;</span><br/>        <span class=\"sc-1\">&lt;!-- false() always returns a boolean false value --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;line<span class=\"re2\">&gt;</span></span></span>This test is <span class=\"sc3\"><span class=\"re1\">&lt;xsl:if</span> <span class=\"re0\">test</span>=<span class=\"st0\">\"false()\"</span><span class=\"re2\">&gt;</span></span>NOT<span class=\"sc3\"><span class=\"re1\">&lt;/xsl:if<span class=\"re2\">&gt;</span></span></span> OK.<span class=\"sc3\"><span class=\"re1\">&lt;/line<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Calling a function with a fixed number of arguments --&gt;</span><br/>        <span class=\"sc-1\">&lt;!-- not() takes exactly 1 argument. starts-with() takes exactly 2 arguments. --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;line<span class=\"re2\">&gt;</span></span></span>'haystack' does <span class=\"sc3\"><span class=\"re1\">&lt;xsl:if</span> <span class=\"re0\">test</span>=<span class=\"st0\">\"not(starts-with('haystack', 'hay'))\"</span><span class=\"re2\">&gt;</span></span>NOT<span class=\"sc3\"><span class=\"re1\">&lt;/xsl:if<span class=\"re2\">&gt;</span></span></span> start with 'hay'.<span class=\"sc3\"><span class=\"re1\">&lt;/line<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Calling a function with optional arguments --&gt;</span><br/>        <span class=\"sc-1\">&lt;!-- If the third argument of substring() is omitted, the length of the string is assumed. --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;line<span class=\"re2\">&gt;</span></span></span>'<span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"substring('haystack', 1, 3)\"</span><span class=\"re2\">/&gt;</span></span>' = 'hay'<span class=\"sc3\"><span class=\"re1\">&lt;/line<span class=\"re2\">&gt;</span></span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;line<span class=\"re2\">&gt;</span></span></span>'<span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"substring('haystack', 4)\"</span><span class=\"re2\">/&gt;</span></span>' = 'stack'<span class=\"sc3\"><span class=\"re1\">&lt;/line<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Calling a function with a variable number of arguments --&gt;</span><br/>        <span class=\"sc-1\">&lt;!-- concat() accepts two or more arguments. --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;line<span class=\"re2\">&gt;</span></span></span>'<span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"concat('abcd', 'efgh')\"</span><span class=\"re2\">/&gt;</span></span>' = 'abcdefgh'<span class=\"sc3\"><span class=\"re1\">&lt;/line<span class=\"re2\">&gt;</span></span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;line<span class=\"re2\">&gt;</span></span></span>'<span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"concat('ij', 'kl', 'mn', 'op')\"</span><span class=\"re2\">/&gt;</span></span>' = 'ijklmnop'<span class=\"sc3\"><span class=\"re1\">&lt;/line<span class=\"re2\">&gt;</span></span></span><br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            Aggregate functions such as sum() and count() accept nodesets.</span><br/><span class=\"sc-1\">            This isn't quite the same as varargs but are probably worth</span><br/><span class=\"sc-1\">            mentioning.</span><br/><span class=\"sc-1\">        --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;line<span class=\"re2\">&gt;</span></span></span>The number of root elements in the input document is <span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"count(/*)\"</span><span class=\"re2\">/&gt;</span></span> (should be 1).<span class=\"sc3\"><span class=\"re1\">&lt;/line<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Calling a function with named arguments --&gt;</span><br/>        <span class=\"sc-1\">&lt;!-- XPath 1.0 uses only positional parameters. --&gt;</span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Using a function in statement context --&gt;</span><br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            In general, XPath 1.0 functions have no side effects, so calling</span><br/><span class=\"sc-1\">            them as statements is useless. While implementations often allow</span><br/><span class=\"sc-1\">            writing extensions in imperative languages, the semantics of</span><br/><span class=\"sc-1\">            calling a function with side effects are, at the very least,</span><br/><span class=\"sc-1\">            implementation-dependent.</span><br/><span class=\"sc-1\">        --&gt;</span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Using a function in first-class context within an expression --&gt;</span><br/>        <span class=\"sc-1\">&lt;!-- Functions are not natively first-class values in XPath 1.0. --&gt;</span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Obtaining the return value of a function --&gt;</span><br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            The return value of the function is handled as specified by the</span><br/><span class=\"sc-1\">            various contexts in which an XPath expression is used. The</span><br/><span class=\"sc-1\">            return value can be stored in a \"variable\" (no destructive</span><br/><span class=\"sc-1\">            assignment is allowed), passed as a parameter to a function or a</span><br/><span class=\"sc-1\">            template, used as a conditional in an &lt;xsl:if/&gt; or &lt;xsl:when/&gt;,</span><br/><span class=\"sc-1\">            interpolated into text using &lt;xsl:value-of/&gt; or into an</span><br/><span class=\"sc-1\">            attribute value using brace syntax, and so forth.</span><br/><span class=\"sc-1\">        --&gt;</span><br/>        <span class=\"sc-1\">&lt;!-- Here, concat() is interpolated into an attribute value using braces ({}). --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;line</span> <span class=\"re0\">foo</span>=<span class=\"st0\">\"{concat('Hello, ', 'Hello, ', 'Hello')}!\"</span><span class=\"re2\">&gt;</span></span>See attribute.<span class=\"sc3\"><span class=\"re1\">&lt;/line<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Distinguishing built-in functions and user-defined functions --&gt;</span><br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            Given that functions aren't first-class here, the origin of any</span><br/><span class=\"sc-1\">            given function is known before run time. Incidentally, functions</span><br/><span class=\"sc-1\">            defined by the standard are generally unprefixed while</span><br/><span class=\"sc-1\">            implementation-specific extensions (and user extensions, if</span><br/><span class=\"sc-1\">            available) must be defined within a separate namespace and</span><br/><span class=\"sc-1\">            prefixed.</span><br/><span class=\"sc-1\">        --&gt;</span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Distinguishing subroutines and functions --&gt;</span><br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            There are no \"subroutines\" in this sense\u2014everything that looks</span><br/><span class=\"sc-1\">            like a subroutine has some sort of return or result value.</span><br/><span class=\"sc-1\">        --&gt;</span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Stating whether arguments are passed by value or by reference --&gt;</span><br/>        <span class=\"sc-1\">&lt;!-- There is no meaningful distinction since there is no mechanism by which to mutate values. --&gt;</span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Is partial application possible and how --&gt;</span><br/>        <span class=\"sc-1\">&lt;!-- Not natively. --&gt;</span><br/>    <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:template<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>    <span class=\"sc3\"><span class=\"re1\">&lt;xsl:template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"xslt-template-demos\"</span><span class=\"re2\">&gt;</span></span><br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            A 'template' in XSLT 1.0 is a subroutine-like construct. When</span><br/><span class=\"sc-1\">            given a name (and, optionally, parameters), it can be called</span><br/><span class=\"sc-1\">            from within another template using the &lt;xsl:call-template/&gt;</span><br/><span class=\"sc-1\">            element. (An unnamed template is instead called according to its</span><br/><span class=\"sc-1\">            match and mode attributes.) The following demos apply to named</span><br/><span class=\"sc-1\">            templates.</span><br/><span class=\"sc-1\">        --&gt;</span><br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            Unlike with functions, there are no built-in named templates to</span><br/><span class=\"sc-1\">            speak of. The ones used here are defined later in this</span><br/><span class=\"sc-1\">            transform.</span><br/><span class=\"sc-1\">        --&gt;</span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            Answers for these prompts are the same as with XPath functions (above):</span><br/><span class=\"sc-1\">                Using a function in statement context</span><br/><span class=\"sc-1\">                Distinguishing subroutines and functions</span><br/><span class=\"sc-1\">                Stating whether arguments are passed by value or by reference</span><br/><span class=\"sc-1\">                Is partial application possible and how</span><br/><span class=\"sc-1\">        --&gt;</span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Calling function that requires no arguments --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:call-template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"nullary-demo\"</span><span class=\"re2\">/&gt;</span></span><br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            Note that even if a template has no parameters, it has access to</span><br/><span class=\"sc-1\">            the current node (.) as of the time of the call. This</span><br/><span class=\"sc-1\">            &lt;xsl:apply-templates/&gt; runs a matching template above that calls</span><br/><span class=\"sc-1\">            the template \"nullary-context-demo\" with no parameters. Another</span><br/><span class=\"sc-1\">            way to manipulate a template's idea of which node is current is</span><br/><span class=\"sc-1\">            by calling from inside a &lt;xsl:for-each/&gt; loop.</span><br/><span class=\"sc-1\">        --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:apply-templates</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"/*\"</span> <span class=\"re0\">mode</span>=<span class=\"st0\">\"nullary-context-demo-mode\"</span><span class=\"re2\">/&gt;</span></span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            A template parameter is made optional in the definition of the</span><br/><span class=\"sc-1\">            template by supplying an expression as its select attribute,</span><br/><span class=\"sc-1\">            which is evaluated and used as its value if the parameter is</span><br/><span class=\"sc-1\">            omitted. Note, though, that all template parameters have an</span><br/><span class=\"sc-1\">            implicit default value, the empty string, if the select</span><br/><span class=\"sc-1\">            attribute is not specified. Therefore, all template parameters</span><br/><span class=\"sc-1\">            are always optional, even when semantically they should not be.</span><br/><span class=\"sc-1\">        --&gt;</span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Calling a function with a fixed number of arguments --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;working</span> <span class=\"re0\">note</span>=<span class=\"st0\">\"When all parameters are supplied\"</span><span class=\"re2\">&gt;</span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;xsl:call-template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"ternary-demo\"</span><span class=\"re2\">&gt;</span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"a\"</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"4\"</span><span class=\"re2\">/&gt;</span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"b\"</span><span class=\"re2\">&gt;</span></span>3<span class=\"sc3\"><span class=\"re1\">&lt;/xsl:with-param<span class=\"re2\">&gt;</span></span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"c\"</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"2 + 3\"</span><span class=\"re2\">/&gt;</span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:call-template<span class=\"re2\">&gt;</span></span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;/working<span class=\"re2\">&gt;</span></span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;broken</span> <span class=\"re0\">note</span>=<span class=\"st0\">\"When the third parameter 'c' is omitted\"</span><span class=\"re2\">&gt;</span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;xsl:call-template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"ternary-demo\"</span><span class=\"re2\">&gt;</span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"a\"</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"4\"</span><span class=\"re2\">/&gt;</span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"b\"</span><span class=\"re2\">&gt;</span></span>3<span class=\"sc3\"><span class=\"re1\">&lt;/xsl:with-param<span class=\"re2\">&gt;</span></span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:call-template<span class=\"re2\">&gt;</span></span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;/broken<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Calling a function with optional arguments --&gt;</span><br/>        <span class=\"sc-1\">&lt;!-- With the optional third parameter --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;working</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"When all parameters are supplied\"</span><span class=\"re2\">&gt;</span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;xsl:call-template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"binary-or-ternary-demo\"</span><span class=\"re2\">&gt;</span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"a\"</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"4\"</span><span class=\"re2\">/&gt;</span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"b\"</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"3\"</span><span class=\"re2\">/&gt;</span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"c\"</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"5\"</span><span class=\"re2\">/&gt;</span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:call-template<span class=\"re2\">&gt;</span></span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;/working<span class=\"re2\">&gt;</span></span></span><br/>        <span class=\"sc-1\">&lt;!-- Without the optional third parameter (which defaults to 0) --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;working</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"When 'a' and 'b' are supplied but 'c' is defaulted to 0\"</span><span class=\"re2\">&gt;</span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;xsl:call-template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"binary-or-ternary-demo\"</span><span class=\"re2\">&gt;</span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"a\"</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"4\"</span><span class=\"re2\">/&gt;</span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"b\"</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"3\"</span><span class=\"re2\">/&gt;</span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:call-template<span class=\"re2\">&gt;</span></span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;/working<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Calling a function with a variable number of arguments --&gt;</span><br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            Templates are not varargs-capable. Variable numbers of arguments</span><br/><span class=\"sc-1\">            usually appear in the form of a nodeset which is then bound to a</span><br/><span class=\"sc-1\">            single parameter name.</span><br/><span class=\"sc-1\">        --&gt;</span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Calling a function with named arguments --&gt;</span><br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            Other than what comes with the current context, template</span><br/><span class=\"sc-1\">            arguments are always named and can be supplied in any order.</span><br/><span class=\"sc-1\">            Templates do not support positional arguments. Additionally,</span><br/><span class=\"sc-1\">            even arguments not specified by the template may be passed; they</span><br/><span class=\"sc-1\">            are silently ignored.</span><br/><span class=\"sc-1\">        --&gt;</span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Using a function in first-class context within an expression --&gt;</span><br/>        <span class=\"sc-1\">&lt;!-- Templates are not first-class values in XSLT 1.0. --&gt;</span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Obtaining the return value of a function --&gt;</span><br/>        <span class=\"sc-1\">&lt;!--</span><br/><span class=\"sc-1\">            The output of a template is interpolated into the place of the</span><br/><span class=\"sc-1\">            call. Often, this is directly into the output of the transform,</span><br/><span class=\"sc-1\">            as with most of the above examples. However, it is also possible</span><br/><span class=\"sc-1\">            to bind the output as a variable or parameter. This is useful</span><br/><span class=\"sc-1\">            for using templates to compute parameters for other templates or</span><br/><span class=\"sc-1\">            for XPath functions.</span><br/><span class=\"sc-1\">        --&gt;</span><br/>        <span class=\"sc-1\">&lt;!-- Which is the least of 34, 78, 12, 56? --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:variable</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"lesser-demo-result\"</span><span class=\"re2\">&gt;</span></span><br/>            <span class=\"sc-1\">&lt;!-- The variable is bound to the output of this call --&gt;</span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;xsl:call-template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"lesser-value\"</span><span class=\"re2\">&gt;</span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"a\"</span><span class=\"re2\">&gt;</span></span><br/>                    <span class=\"sc-1\">&lt;!-- A call as a parameter to another call --&gt;</span><br/>                    <span class=\"sc3\"><span class=\"re1\">&lt;xsl:call-template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"lesser-value\"</span><span class=\"re2\">&gt;</span></span><br/>                        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"a\"</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"34\"</span><span class=\"re2\">/&gt;</span></span><br/>                        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"b\"</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"78\"</span><span class=\"re2\">/&gt;</span></span><br/>                    <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:call-template<span class=\"re2\">&gt;</span></span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:with-param<span class=\"re2\">&gt;</span></span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"b\"</span><span class=\"re2\">&gt;</span></span><br/>                    <span class=\"sc-1\">&lt;!-- and again --&gt;</span><br/>                    <span class=\"sc3\"><span class=\"re1\">&lt;xsl:call-template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"lesser-value\"</span><span class=\"re2\">&gt;</span></span><br/>                        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"a\"</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"12\"</span><span class=\"re2\">/&gt;</span></span><br/>                        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:with-param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"b\"</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"56\"</span><span class=\"re2\">/&gt;</span></span><br/>                    <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:call-template<span class=\"re2\">&gt;</span></span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:with-param<span class=\"re2\">&gt;</span></span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:call-template<span class=\"re2\">&gt;</span></span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:variable<span class=\"re2\">&gt;</span></span></span><br/>        <span class=\"sc-1\">&lt;!-- The variable is used here in an XPath expression --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;line<span class=\"re2\">&gt;</span></span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"concat('And the answer, which should be 12, is ', $lesser-demo-result, ', of course.')\"</span><span class=\"re2\">/&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;/line<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>        <span class=\"sc-1\">&lt;!-- Distinguishing built-in functions and user-defined functions --&gt;</span><br/>        <span class=\"sc-1\">&lt;!-- Virtually all templates are user-defined. --&gt;</span><br/>\u00a0<br/>    <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:template<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>    <span class=\"sc-1\">&lt;!-- Templates supporting template demos above --&gt;</span><br/>    <span class=\"sc3\"><span class=\"re1\">&lt;xsl:template</span> <span class=\"re0\">match</span>=<span class=\"st0\">\"/*\"</span> <span class=\"re0\">mode</span>=<span class=\"st0\">\"nullary-context-demo-mode\"</span><span class=\"re2\">&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:call-template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"nullary-context-demo\"</span><span class=\"re2\">/&gt;</span></span><br/>    <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:template<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>    <span class=\"sc3\"><span class=\"re1\">&lt;xsl:template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"nullary-demo\"</span><span class=\"re2\">&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;line<span class=\"re2\">&gt;</span></span></span>No parameters needed here!<span class=\"sc3\"><span class=\"re1\">&lt;/line<span class=\"re2\">&gt;</span></span></span><br/>    <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:template<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>    <span class=\"sc3\"><span class=\"re1\">&lt;xsl:template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"nullary-context-demo\"</span><span class=\"re2\">&gt;</span></span><br/>        <span class=\"sc-1\">&lt;!-- When a template is called it has access to the current node of the caller --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:for-each</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"self::*\"</span><span class=\"re2\">&gt;</span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;line<span class=\"re2\">&gt;</span></span></span>The context element here is named \"<span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"local-name()\"</span><span class=\"re2\">/&gt;</span></span>\"<span class=\"sc3\"><span class=\"re1\">&lt;/line<span class=\"re2\">&gt;</span></span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:for-each<span class=\"re2\">&gt;</span></span></span><br/>    <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:template<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>    <span class=\"sc3\"><span class=\"re1\">&lt;xsl:template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"ternary-demo\"</span><span class=\"re2\">&gt;</span></span><br/>        <span class=\"sc-1\">&lt;!-- This demo requires, at least semantically, all three parameters. --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"a\"</span><span class=\"re2\">/&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"b\"</span><span class=\"re2\">/&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"c\"</span><span class=\"re2\">/&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;line<span class=\"re2\">&gt;</span></span></span>(<span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"$a\"</span><span class=\"re2\">/&gt;</span></span> * <span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"$b\"</span><span class=\"re2\">/&gt;</span></span>) + <span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"$c\"</span><span class=\"re2\">/&gt;</span></span> = <span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"($a * $b) + $c\"</span><span class=\"re2\">/&gt;</span><span class=\"re1\">&lt;/line<span class=\"re2\">&gt;</span></span></span><br/>    <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:template<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>    <span class=\"sc3\"><span class=\"re1\">&lt;xsl:template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"binary-or-ternary-demo\"</span><span class=\"re2\">&gt;</span></span><br/>        <span class=\"sc-1\">&lt;!-- This demo requires the first two parameters, but defaults the third to 0 if it is not supplied. --&gt;</span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"a\"</span><span class=\"re2\">/&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"b\"</span><span class=\"re2\">/&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"c\"</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"0\"</span><span class=\"re2\">/&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;line<span class=\"re2\">&gt;</span></span></span>(<span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"$a\"</span><span class=\"re2\">/&gt;</span></span> * <span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"$b\"</span><span class=\"re2\">/&gt;</span></span>) + <span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"$c\"</span><span class=\"re2\">/&gt;</span></span> = <span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"($a * $b) + $c\"</span><span class=\"re2\">/&gt;</span><span class=\"re1\">&lt;/line<span class=\"re2\">&gt;</span></span></span><br/>    <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:template<span class=\"re2\">&gt;</span></span></span><br/>\u00a0<br/>    <span class=\"sc3\"><span class=\"re1\">&lt;xsl:template</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"lesser-value\"</span><span class=\"re2\">&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"a\"</span><span class=\"re2\">/&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:param</span> <span class=\"re0\">name</span>=<span class=\"st0\">\"b\"</span><span class=\"re2\">/&gt;</span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;xsl:choose<span class=\"re2\">&gt;</span></span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;xsl:when</span> <span class=\"re0\">test</span>=<span class=\"st0\">\"number($a) &amp;lt; number($b)\"</span><span class=\"re2\">&gt;</span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"$a\"</span><span class=\"re2\">/&gt;</span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:when<span class=\"re2\">&gt;</span></span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;xsl:otherwise<span class=\"re2\">&gt;</span></span></span><br/>                <span class=\"sc3\"><span class=\"re1\">&lt;xsl:value-of</span> <span class=\"re0\">select</span>=<span class=\"st0\">\"$b\"</span><span class=\"re2\">/&gt;</span></span><br/>            <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:otherwise<span class=\"re2\">&gt;</span></span></span><br/>        <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:choose<span class=\"re2\">&gt;</span></span></span><br/>    <span class=\"sc3\"><span class=\"re1\">&lt;/xsl:template<span class=\"re2\">&gt;</span></span></span><br/><span class=\"sc3\"><span class=\"re1\">&lt;/xsl:stylesheet<span class=\"re2\">&gt;</span></span></span><br/>\u00a0</pre>"}, {"lang": "Yabasic", "loc": 19, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>sub test(a, b, c)\u00a0:\tprint a, b, c\u00a0: end sub<br/>\u00a0<br/>test(1, 2, 3)\t// show 1 2 3<br/>test(1, 2)\t// show 1 2 0<br/>\u00a0<br/>execute(\"test\", 1, 2, 3)\t// show 1 2 3<br/>\u00a0<br/>sub test$(a$)\t// show all members of a \"list\"<br/>\tlocal n, i, t$(1)<br/>\u00a0<br/>\tn = token(a$, t$(), \", \")<br/>\tfor i = 1 to n<br/>\t\tprint t$(i), \" \";<br/>\tnext<br/>end sub<br/>\u00a0<br/>test$(\"1, 2, 3, 4, text, 6, 7, 8, \\\"include text\\\"\")<br/>print</pre>"}, {"lang": "zkl", "loc": 10, "block": "<pre class=\"text highlighted_source\">f(); f(1,2,3,4); <br/>fcn f(a=1){}()  // define and call f, which gets a set to 1<br/>fcn{vm.arglist}(1,2,3,4) // arglist is L(1,2,3,4)<br/>fcn{a1:=vm.nthArg(1)}(1,2,3)  // a1 == 2<br/>(f() == True); (f() and 1 or 2)<br/>if (f()) println()<br/>f(f) // pass f to itself<br/>s:=f()<br/>fcn{}.isType(self.fcn)  //True<br/>fcn{}.len.isType(self.fcn)  //False, len is a Method</pre>"}, {"lang": "zonnon", "loc": 57, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>module CallingProcs;<br/>\ttype<br/>\t\t{public} Vector = array {math} * of integer;<br/>\u00a0<br/>\tvar<br/>\t\tnums: array {math} 4 of integer;<br/>\t\tints: Vector;<br/>\t\ttotal: integer;<br/>\u00a0<br/>\t\tprocedure Init(): boolean; (* private by default *)<br/>\t\tbegin<br/>\t\t\tnums\u00a0:= [1,2,3,4];<br/>\t\t\tints\u00a0:= new Vector(5);<br/>\t\t\tints\u00a0:= [2,4,6,8,10];<br/>\t\t\treturn true;<br/>\t\tend Init;<br/>\u00a0<br/>\t\t(* function *)<br/>\t\tprocedure Sum(v: Vector): integer;<br/>\t\tvar<br/>\t\t\ti,s: integer;<br/>\t\tbegin<br/>\t\t\ts\u00a0:= 0;<br/>\t\t\tfor i\u00a0:= 0 to len(v) - 1 do<br/>\t\t\t\t(* inc is a predefined subroutine *)<br/>\t\t\t\tinc(s,v[i])<br/>\t\t\tend;<br/>\t\t\treturn s<br/>\t\tend Sum;<br/>\u00a0<br/>\t\t(* subroutine <br/>\t\t * @param v: by value<br/>\t\t * @param t: by reference<br/>\t\t *)<br/>\t\tprocedure Sum2(v: array {math} * of integer; var t: integer);<br/>\t\tvar\t<br/>\t\t\ti: integer;<br/>\t\tbegin<br/>\t\t\tt\u00a0:= 0;<br/>\t\t\tfor i\u00a0:= 0 to len(v) - 1 do<br/>\t\t\t\tinc(t,v[i])<br/>\t\t\tend\t<br/>\t\tend Sum2;<br/>\tbegin <br/>\t\tInit; (* calling a function without parameters *)<br/>\t\ttotal\u00a0:= Sum(nums);<br/>\t\twriteln(total);<br/>\t\t(* optional arguments not supported *)<br/>\t\t(* variable arguments through open arrays *)<br/>\t\twriteln(Sum(ints));<br/>\t\t(* named arguments not supported *)<br/>\t\tints\u00a0:= [1,3,5,7,9];<br/>\t\tSum2(ints,total);<br/>\t\twriteln(total);<br/>\tend CallingProcs.<br/>\u00a0</pre>"}, {"lang": "ZX Spectrum Basic", "loc": 12, "block": "<pre class=\"zxbasic highlighted_source\"><span class=\"nu0\">10</span> <span class=\"co3\">REM functions cannot be called in statement context</span><br/><span class=\"nu0\">20</span> <span class=\"kw1\">PRINT</span> FN a<span class=\"br0\">(</span><span class=\"nu0\">5</span><span class=\"br0\">)</span>: <span class=\"co3\">REM The function is used in first class context. Arguments are not named</span><br/><span class=\"nu0\">30</span> <span class=\"kw1\">PRINT</span> FN b<span class=\"br0\">(</span><span class=\"br0\">)</span>: <span class=\"co3\">REM Here we call a function that has no arguments</span><br/><span class=\"nu0\">40</span> <span class=\"co3\">REM subroutines cannot be passed parameters, however variables are global</span><br/><span class=\"nu0\">50</span> <span class=\"kw1\">LET</span> n=<span class=\"nu0\">1</span>: <span class=\"co3\">REM This variable will be visible to the called subroutine</span><br/><span class=\"nu0\">60</span> <span class=\"kw1\">GO</span> <span class=\"kw1\">SUB</span> <span class=\"nu0\">1000</span>: <span class=\"co3\">REM subroutines are called by line number and do not have names</span><br/><span class=\"nu0\">70</span> <span class=\"co3\">REM subroutines do not return a value, but we can see any variables it defined</span><br/><span class=\"nu0\">80</span> <span class=\"co3\">REM subroutines cannot be used in first class context</span><br/><span class=\"nu0\">90</span> <span class=\"co3\">REM builtin functions are used in first class context, and do not need the FN keyword prefix</span><br/><span class=\"nu0\">100</span> <span class=\"kw1\">PRINT</span> <span class=\"kw3\">SIN</span><span class=\"br0\">(</span><span class=\"nu0\">50</span><span class=\"br0\">)</span>: <span class=\"co3\">REM here we pass a parameter to a builtin function</span><br/><span class=\"nu0\">110</span> <span class=\"kw1\">PRINT</span> <span class=\"kw3\">RND</span><span class=\"br0\">(</span><span class=\"br0\">)</span>: <span class=\"co3\">REM here we use a builtin function without parameters</span><br/><span class=\"nu0\">120</span> <span class=\"kw1\">RANDOMIZE</span>: <span class=\"co3\">REM statements are not functions and cannot be used in first class context.</span></pre>"}]}