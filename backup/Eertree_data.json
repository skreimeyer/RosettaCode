{"task": "Eertree", "blocks": [{"lang": "C#", "loc": 96, "block": "<pre class=\"csharp highlighted_source\"><span class=\"kw1\">using</span> <span class=\"co3\">System</span><span class=\"sy0\">;</span><br/><span class=\"kw1\">using</span> <span class=\"co3\">System.Collections.Generic</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"kw1\">namespace</span> Eertree <span class=\"br0\">{</span><br/>    <span class=\"kw4\">class</span> Node <span class=\"br0\">{</span><br/>        <span class=\"kw1\">public</span> Node<span class=\"br0\">(</span><span class=\"kw4\">int</span> length<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">this</span><span class=\"sy0\">.</span><span class=\"me1\">Length</span> <span class=\"sy0\">=</span> length<span class=\"sy0\">;</span><br/>            <span class=\"co1\">// empty or</span><br/>            <span class=\"kw1\">this</span><span class=\"sy0\">.</span><span class=\"me1\">Edges</span> <span class=\"sy0\">=</span> <a href=\"http://www.google.com/search?q=new+msdn.microsoft.com\"><span class=\"kw3\">new</span></a> Dictionary<span class=\"sy0\">&lt;</span><span class=\"kw4\">char</span>, <span class=\"kw4\">int</span><span class=\"sy0\">&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">public</span> Node<span class=\"br0\">(</span><span class=\"kw4\">int</span> length, Dictionary<span class=\"sy0\">&lt;</span><span class=\"kw4\">char</span>, <span class=\"kw4\">int</span><span class=\"sy0\">&gt;</span> edges, <span class=\"kw4\">int</span> suffix<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">this</span><span class=\"sy0\">.</span><span class=\"me1\">Length</span> <span class=\"sy0\">=</span> length<span class=\"sy0\">;</span><br/>            <span class=\"kw1\">this</span><span class=\"sy0\">.</span><span class=\"me1\">Edges</span> <span class=\"sy0\">=</span> edges<span class=\"sy0\">;</span><br/>            <span class=\"kw1\">this</span><span class=\"sy0\">.</span><span class=\"me1\">Suffix</span> <span class=\"sy0\">=</span> suffix<span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">public</span> <span class=\"kw4\">int</span> Length <span class=\"br0\">{</span> <span class=\"kw1\">get</span><span class=\"sy0\">;</span> <span class=\"kw1\">set</span><span class=\"sy0\">;</span> <span class=\"br0\">}</span><br/>        <span class=\"kw1\">public</span> Dictionary<span class=\"sy0\">&lt;</span><span class=\"kw4\">char</span>, <span class=\"kw4\">int</span><span class=\"sy0\">&gt;</span> Edges <span class=\"br0\">{</span> <span class=\"kw1\">get</span><span class=\"sy0\">;</span> <span class=\"kw1\">set</span><span class=\"sy0\">;</span> <span class=\"br0\">}</span><br/>        <span class=\"kw1\">public</span> <span class=\"kw4\">int</span> Suffix <span class=\"br0\">{</span> <span class=\"kw1\">get</span><span class=\"sy0\">;</span> <span class=\"kw1\">set</span><span class=\"sy0\">;</span> <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"kw4\">class</span> Program <span class=\"br0\">{</span><br/>        <span class=\"kw1\">const</span> <span class=\"kw4\">int</span> EVEN_ROOT <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">const</span> <span class=\"kw4\">int</span> ODD_ROOT <span class=\"sy0\">=</span> <span class=\"nu0\">1</span><span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"kw1\">static</span> List<span class=\"sy0\">&lt;</span>Node<span class=\"sy0\">&gt;</span> Eertree<span class=\"br0\">(</span><span class=\"kw4\">string</span> s<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            List<span class=\"sy0\">&lt;</span>Node<span class=\"sy0\">&gt;</span> tree <span class=\"sy0\">=</span> <a href=\"http://www.google.com/search?q=new+msdn.microsoft.com\"><span class=\"kw3\">new</span></a> List<span class=\"sy0\">&lt;</span>Node<span class=\"sy0\">&gt;</span> <span class=\"br0\">{</span><br/>                <span class=\"co1\">//new Node(0, null, ODD_ROOT), or</span><br/>                <a href=\"http://www.google.com/search?q=new+msdn.microsoft.com\"><span class=\"kw3\">new</span></a> Node<span class=\"br0\">(</span><span class=\"nu0\">0</span>, <a href=\"http://www.google.com/search?q=new+msdn.microsoft.com\"><span class=\"kw3\">new</span></a> Dictionary<span class=\"sy0\">&lt;</span><span class=\"kw4\">char</span>, <span class=\"kw4\">int</span><span class=\"sy0\">&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span>, ODD_ROOT<span class=\"br0\">)</span>,<br/>                <span class=\"co1\">//new Node(-1, null, ODD_ROOT) or</span><br/>                <a href=\"http://www.google.com/search?q=new+msdn.microsoft.com\"><span class=\"kw3\">new</span></a> Node<span class=\"br0\">(</span><span class=\"sy0\">-</span><span class=\"nu0\">1</span>, <a href=\"http://www.google.com/search?q=new+msdn.microsoft.com\"><span class=\"kw3\">new</span></a> Dictionary<span class=\"sy0\">&lt;</span><span class=\"kw4\">char</span>, <span class=\"kw4\">int</span><span class=\"sy0\">&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span>, ODD_ROOT<span class=\"br0\">)</span><br/>            <span class=\"br0\">}</span><span class=\"sy0\">;</span><br/>            <span class=\"kw4\">int</span> suffix <span class=\"sy0\">=</span> ODD_ROOT<span class=\"sy0\">;</span><br/>            <span class=\"kw4\">int</span> n, k<span class=\"sy0\">;</span><br/>            <span class=\"kw1\">for</span> <span class=\"br0\">(</span><span class=\"kw4\">int</span> i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> s<span class=\"sy0\">.</span><span class=\"me1\">Length</span><span class=\"sy0\">;</span> i<span class=\"sy0\">++</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                <span class=\"kw4\">char</span> c <span class=\"sy0\">=</span> s<span class=\"br0\">[</span>i<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>                <span class=\"kw1\">for</span> <span class=\"br0\">(</span>n <span class=\"sy0\">=</span> suffix<span class=\"sy0\">;</span> <span class=\"sy0\">;</span> n <span class=\"sy0\">=</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Suffix</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                    k <span class=\"sy0\">=</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Length</span><span class=\"sy0\">;</span><br/>                    <span class=\"kw4\">int</span> b <span class=\"sy0\">=</span> i <span class=\"sy0\">-</span> k <span class=\"sy0\">-</span> <span class=\"nu0\">1</span><span class=\"sy0\">;</span><br/>                    <span class=\"kw1\">if</span> <span class=\"br0\">(</span>b <span class=\"sy0\">&gt;=</span> <span class=\"nu0\">0</span> <span class=\"sy0\">&amp;&amp;</span> s<span class=\"br0\">[</span>b<span class=\"br0\">]</span> <span class=\"sy0\">==</span> c<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                        <span class=\"kw1\">break</span><span class=\"sy0\">;</span><br/>                    <span class=\"br0\">}</span><br/>                <span class=\"br0\">}</span><br/>                <span class=\"kw1\">if</span> <span class=\"br0\">(</span>tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Edges</span><span class=\"sy0\">.</span><span class=\"me1\">ContainsKey</span><span class=\"br0\">(</span>c<span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                    suffix <span class=\"sy0\">=</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Edges</span><span class=\"br0\">[</span>c<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>                    <span class=\"kw1\">continue</span><span class=\"sy0\">;</span><br/>                <span class=\"br0\">}</span><br/>                suffix <span class=\"sy0\">=</span> tree<span class=\"sy0\">.</span><span class=\"me1\">Count</span><span class=\"sy0\">;</span><br/>                tree<span class=\"sy0\">.</span><span class=\"kw1\">Add</span><span class=\"br0\">(</span><a href=\"http://www.google.com/search?q=new+msdn.microsoft.com\"><span class=\"kw3\">new</span></a> Node<span class=\"br0\">(</span>k <span class=\"sy0\">+</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>                tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Edges</span><span class=\"br0\">[</span>c<span class=\"br0\">]</span> <span class=\"sy0\">=</span> suffix<span class=\"sy0\">;</span><br/>                <span class=\"kw1\">if</span> <span class=\"br0\">(</span>tree<span class=\"br0\">[</span>suffix<span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Length</span> <span class=\"sy0\">==</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                    tree<span class=\"br0\">[</span>suffix<span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Suffix</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>                    <span class=\"kw1\">continue</span><span class=\"sy0\">;</span><br/>                <span class=\"br0\">}</span><br/>                <span class=\"kw1\">while</span> <span class=\"br0\">(</span><span class=\"kw1\">true</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                    n <span class=\"sy0\">=</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Suffix</span><span class=\"sy0\">;</span><br/>                    <span class=\"kw4\">int</span> b <span class=\"sy0\">=</span> i <span class=\"sy0\">-</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Length</span> <span class=\"sy0\">-</span> <span class=\"nu0\">1</span><span class=\"sy0\">;</span><br/>                    <span class=\"kw1\">if</span> <span class=\"br0\">(</span>b <span class=\"sy0\">&gt;=</span> <span class=\"nu0\">0</span> <span class=\"sy0\">&amp;&amp;</span> s<span class=\"br0\">[</span>b<span class=\"br0\">]</span> <span class=\"sy0\">==</span> c<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                        <span class=\"kw1\">break</span><span class=\"sy0\">;</span><br/>                    <span class=\"br0\">}</span><br/>                <span class=\"br0\">}</span><br/>                tree<span class=\"br0\">[</span>suffix<span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Suffix</span> <span class=\"sy0\">=</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Edges</span><span class=\"br0\">[</span>c<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>            <span class=\"kw1\">return</span> tree<span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">static</span> List<span class=\"sy0\">&lt;</span><span class=\"kw4\">string</span><span class=\"sy0\">&gt;</span> SubPalindromes<span class=\"br0\">(</span>List<span class=\"sy0\">&lt;</span>Node<span class=\"sy0\">&gt;</span> tree<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            List<span class=\"sy0\">&lt;</span><span class=\"kw4\">string</span><span class=\"sy0\">&gt;</span> s <span class=\"sy0\">=</span> <a href=\"http://www.google.com/search?q=new+msdn.microsoft.com\"><span class=\"kw3\">new</span></a> List<span class=\"sy0\">&lt;</span><span class=\"kw4\">string</span><span class=\"sy0\">&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            SubPalindromes_children<span class=\"br0\">(</span><span class=\"nu0\">0</span>, <span class=\"st0\">\"\"</span>, tree, s<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw1\">var</span> c <span class=\"kw1\">in</span> tree<span class=\"br0\">[</span><span class=\"nu0\">1</span><span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Edges</span><span class=\"sy0\">.</span><span class=\"me1\">Keys</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                <span class=\"kw4\">int</span> m <span class=\"sy0\">=</span> tree<span class=\"br0\">[</span><span class=\"nu0\">1</span><span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Edges</span><span class=\"br0\">[</span>c<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>                <span class=\"kw4\">string</span> ct <span class=\"sy0\">=</span> c<span class=\"sy0\">.</span><span class=\"me1\">ToString</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>                s<span class=\"sy0\">.</span><span class=\"kw1\">Add</span><span class=\"br0\">(</span>ct<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>                SubPalindromes_children<span class=\"br0\">(</span>m, ct, tree, s<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>            <span class=\"kw1\">return</span> s<span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">static</span> <span class=\"kw4\">void</span> SubPalindromes_children<span class=\"br0\">(</span><span class=\"kw4\">int</span> n, <span class=\"kw4\">string</span> p, List<span class=\"sy0\">&lt;</span>Node<span class=\"sy0\">&gt;</span> tree, List<span class=\"sy0\">&lt;</span><span class=\"kw4\">string</span><span class=\"sy0\">&gt;</span> s<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span><span class=\"kw1\">var</span> c <span class=\"kw1\">in</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Edges</span><span class=\"sy0\">.</span><span class=\"me1\">Keys</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                <span class=\"kw4\">int</span> m <span class=\"sy0\">=</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span><span class=\"sy0\">.</span><span class=\"me1\">Edges</span><span class=\"br0\">[</span>c<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>                <span class=\"kw4\">string</span> p1 <span class=\"sy0\">=</span> c <span class=\"sy0\">+</span> p <span class=\"sy0\">+</span> c<span class=\"sy0\">;</span><br/>                s<span class=\"sy0\">.</span><span class=\"kw1\">Add</span><span class=\"br0\">(</span>p1<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>                SubPalindromes_children<span class=\"br0\">(</span>m, p1, tree, s<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">static</span> <span class=\"kw4\">void</span> Main<span class=\"br0\">(</span><span class=\"kw4\">string</span><span class=\"br0\">[</span><span class=\"br0\">]</span> args<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            List<span class=\"sy0\">&lt;</span>Node<span class=\"sy0\">&gt;</span> tree <span class=\"sy0\">=</span> Eertree<span class=\"br0\">(</span><span class=\"st0\">\"eertree\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            List<span class=\"sy0\">&lt;</span><span class=\"kw4\">string</span><span class=\"sy0\">&gt;</span> result <span class=\"sy0\">=</span> SubPalindromes<span class=\"br0\">(</span>tree<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            <span class=\"kw4\">string</span> listStr <span class=\"sy0\">=</span> <span class=\"kw4\">string</span><span class=\"sy0\">.</span><span class=\"kw1\">Join</span><span class=\"br0\">(</span><span class=\"st0\">\", \"</span>, result<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            Console<span class=\"sy0\">.</span><span class=\"me1\">WriteLine</span><span class=\"br0\">(</span><span class=\"st0\">\"[{0}]\"</span>, listStr<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "D", "loc": 72, "block": "<pre class=\"d highlighted_source\"><span class=\"kw2\">import</span> std.<span class=\"me1\">array</span><span class=\"sy0\">;</span><br/><span class=\"kw2\">import</span> std.<span class=\"me1\">stdio</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"kw4\">void</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <span class=\"kw4\">auto</span> tree <span class=\"sy0\">=</span> eertree<span class=\"br0\">(</span><span class=\"st0\">\"eertree\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    writeln<span class=\"br0\">(</span>subPalindromes<span class=\"br0\">(</span>tree<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw4\">struct</span> Node <span class=\"br0\">{</span><br/>    <span class=\"kw4\">int</span> length<span class=\"sy0\">;</span><br/>    <span class=\"kw4\">int</span><span class=\"br0\">[</span><span class=\"kw4\">char</span><span class=\"br0\">]</span> edges<span class=\"sy0\">;</span><br/>    <span class=\"kw4\">int</span> suffix<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw4\">const</span> evenRoot <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/><span class=\"kw4\">const</span> oddRoot <span class=\"sy0\">=</span> <span class=\"nu0\">1</span><span class=\"sy0\">;</span><br/>\u00a0<br/>Node<span class=\"br0\">[</span><span class=\"br0\">]</span> eertree<span class=\"br0\">(</span><span class=\"kw4\">string</span> s<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    Node<span class=\"br0\">[</span><span class=\"br0\">]</span> tree <span class=\"sy0\">=</span> <span class=\"br0\">[</span><br/>        Node<span class=\"br0\">(</span><span class=\"nu0\">0</span><span class=\"sy0\">,</span> <span class=\"kw2\">null</span><span class=\"sy0\">,</span> oddRoot<span class=\"br0\">)</span><span class=\"sy0\">,</span><br/>        Node<span class=\"br0\">(</span><span class=\"sy0\">-</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"kw2\">null</span><span class=\"sy0\">,</span> oddRoot<span class=\"br0\">)</span><span class=\"sy0\">,</span><br/>    <span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>    <span class=\"kw4\">int</span> suffix <span class=\"sy0\">=</span> oddRoot<span class=\"sy0\">;</span><br/>    <span class=\"kw4\">int</span> n<span class=\"sy0\">,</span> k<span class=\"sy0\">;</span><br/>    <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span>i<span class=\"sy0\">,</span> c<span class=\"sy0\">;</span> s<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">for</span> <span class=\"br0\">(</span>n<span class=\"sy0\">=</span>suffix<span class=\"sy0\">;</span> <span class=\"sy0\">;</span> n<span class=\"sy0\">=</span>tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span>.<span class=\"me1\">suffix</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            k <span class=\"sy0\">=</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span>.<span class=\"me1\">length</span><span class=\"sy0\">;</span><br/>            <span class=\"kw4\">int</span> b <span class=\"sy0\">=</span> i<span class=\"sy0\">-</span>k<span class=\"sy0\">-</span><span class=\"nu0\">1</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>b<span class=\"sy0\">&gt;=</span><span class=\"nu0\">0</span> <span class=\"sy0\">&amp;&amp;</span> s<span class=\"br0\">[</span>b<span class=\"br0\">]</span><span class=\"sy0\">==</span>c<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                <span class=\"kw1\">break</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>        <span class=\"br0\">}</span><br/>        <span class=\"kw1\">if</span> <span class=\"br0\">(</span>c <span class=\"kw2\">in</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span>.<span class=\"me1\">edges</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            suffix <span class=\"sy0\">=</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span>.<span class=\"me1\">edges</span><span class=\"br0\">[</span>c<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">continue</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>        suffix <span class=\"sy0\">=</span> tree.<span class=\"me1\">length</span><span class=\"sy0\">;</span><br/>        tree <span class=\"sy0\">~=</span> Node<span class=\"br0\">(</span>k<span class=\"sy0\">+</span><span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span>.<span class=\"me1\">edges</span><span class=\"br0\">[</span>c<span class=\"br0\">]</span> <span class=\"sy0\">=</span> suffix<span class=\"sy0\">;</span><br/>        <span class=\"kw1\">if</span> <span class=\"br0\">(</span>tree<span class=\"br0\">[</span>suffix<span class=\"br0\">]</span>.<span class=\"me1\">length</span> <span class=\"sy0\">==</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            tree<span class=\"br0\">[</span>suffix<span class=\"br0\">]</span>.<span class=\"me1\">suffix</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">continue</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>        <span class=\"kw1\">while</span> <span class=\"br0\">(</span><span class=\"kw2\">true</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            n <span class=\"sy0\">=</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span>.<span class=\"me1\">suffix</span><span class=\"sy0\">;</span><br/>            <span class=\"kw4\">int</span> b <span class=\"sy0\">=</span> i<span class=\"sy0\">-</span>tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span>.<span class=\"me1\">length</span><span class=\"sy0\">-</span><span class=\"nu0\">1</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>b<span class=\"sy0\">&gt;=</span><span class=\"nu0\">0</span> <span class=\"sy0\">&amp;&amp;</span> s<span class=\"br0\">[</span>b<span class=\"br0\">]</span><span class=\"sy0\">==</span>c<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                <span class=\"kw1\">break</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>        <span class=\"br0\">}</span><br/>        tree<span class=\"br0\">[</span>suffix<span class=\"br0\">]</span>.<span class=\"me1\">suffix</span> <span class=\"sy0\">=</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span>.<span class=\"me1\">edges</span><span class=\"br0\">[</span>c<span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"kw1\">return</span> tree<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw4\">auto</span> subPalindromes<span class=\"br0\">(</span>Node<span class=\"br0\">[</span><span class=\"br0\">]</span> tree<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <span class=\"kw4\">auto</span> s <span class=\"sy0\">=</span> appender<span class=\"sy0\">!</span><span class=\"br0\">(</span><span class=\"kw4\">string</span><span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw4\">void</span> children<span class=\"br0\">(</span><span class=\"kw4\">int</span> n<span class=\"sy0\">,</span> <span class=\"kw4\">string</span> p<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span>c<span class=\"sy0\">,</span> n<span class=\"sy0\">;</span> tree<span class=\"br0\">[</span>n<span class=\"br0\">]</span>.<span class=\"me1\">edges</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            p <span class=\"sy0\">=</span> c <span class=\"sy0\">~</span> p <span class=\"sy0\">~</span> c<span class=\"sy0\">;</span><br/>            s <span class=\"sy0\">~=</span> p<span class=\"sy0\">;</span><br/>            children<span class=\"br0\">(</span>n<span class=\"sy0\">,</span> p<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>    children<span class=\"br0\">(</span><span class=\"nu0\">0</span><span class=\"sy0\">,</span> <span class=\"st0\">\"\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">foreach</span> <span class=\"br0\">(</span>c<span class=\"sy0\">,</span> n<span class=\"sy0\">;</span> tree<span class=\"br0\">[</span><span class=\"nu0\">1</span><span class=\"br0\">]</span>.<span class=\"me1\">edges</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw4\">string</span> ct <span class=\"sy0\">=</span> <span class=\"br0\">[</span>c<span class=\"br0\">]</span>.<span class=\"me1\">idup</span><span class=\"sy0\">;</span><br/>        s <span class=\"sy0\">~=</span> ct<span class=\"sy0\">;</span><br/>        children<span class=\"br0\">(</span>n<span class=\"sy0\">,</span> ct<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>    <span class=\"kw1\">return</span> s.<span class=\"me1\">data</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Go", "loc": 74, "block": "<pre class=\"go highlighted_source\"><span class=\"kw1\">package</span> main<br/>\u00a0<br/><span class=\"kw1\">import</span> <span class=\"st0\">\"fmt\"</span><br/>\u00a0<br/><span class=\"kw4\">func</span> main<span class=\"sy1\">()</span> <span class=\"sy1\">{</span><br/>    tree <span class=\"sy2\">:=</span> eertree<span class=\"sy1\">([]</span><span class=\"kw4\">byte</span><span class=\"sy1\">(</span><span class=\"st0\">\"eertree\"</span><span class=\"sy1\">))</span><br/>    fmt<span class=\"sy3\">.</span>Println<span class=\"sy1\">(</span>subPalindromes<span class=\"sy1\">(</span>tree<span class=\"sy1\">))</span><br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"kw1\">type</span> edges <span class=\"kw4\">map</span><span class=\"sy1\">[</span><span class=\"kw4\">byte</span><span class=\"sy1\">]</span><span class=\"kw4\">int</span><br/>\u00a0<br/><span class=\"kw1\">type</span> node <span class=\"kw4\">struct</span> <span class=\"sy1\">{</span><br/>    length <span class=\"kw4\">int</span><br/>    edges<br/>    suffix <span class=\"kw4\">int</span><br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"kw1\">const</span> evenRoot <span class=\"sy2\">=</span> <span class=\"nu0\">0</span><br/><span class=\"kw1\">const</span> oddRoot <span class=\"sy2\">=</span> <span class=\"nu0\">1</span><br/>\u00a0<br/><span class=\"kw4\">func</span> eertree<span class=\"sy1\">(</span>s <span class=\"sy1\">[]</span><span class=\"kw4\">byte</span><span class=\"sy1\">)</span> <span class=\"sy1\">[]</span>node <span class=\"sy1\">{</span><br/>    tree <span class=\"sy2\">:=</span> <span class=\"sy1\">[]</span>node<span class=\"sy1\">{</span><br/>        evenRoot<span class=\"sy1\">:</span> <span class=\"sy1\">{</span>length<span class=\"sy1\">:</span> <span class=\"nu0\">0</span><span class=\"sy1\">,</span> suffix<span class=\"sy1\">:</span> oddRoot<span class=\"sy1\">,</span> edges<span class=\"sy1\">:</span> edges<span class=\"sy1\">{}},</span><br/>        oddRoot<span class=\"sy1\">:</span>  <span class=\"sy1\">{</span>length<span class=\"sy1\">:</span> <span class=\"sy3\">-</span><span class=\"nu0\">1</span><span class=\"sy1\">,</span> suffix<span class=\"sy1\">:</span> oddRoot<span class=\"sy1\">,</span> edges<span class=\"sy1\">:</span> edges<span class=\"sy1\">{}},</span><br/>    <span class=\"sy1\">}</span><br/>    suffix <span class=\"sy2\">:=</span> oddRoot<br/>    <span class=\"kw1\">var</span> n<span class=\"sy1\">,</span> k <span class=\"kw4\">int</span><br/>    <span class=\"kw1\">for</span> <span class=\"nu2\">i</span><span class=\"sy1\">,</span> c <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> s <span class=\"sy1\">{</span><br/>        <span class=\"kw1\">for</span> n <span class=\"sy2\">=</span> suffix<span class=\"sy1\">;</span> <span class=\"sy1\">;</span> n <span class=\"sy2\">=</span> tree<span class=\"sy1\">[</span>n<span class=\"sy1\">]</span><span class=\"sy3\">.</span>suffix <span class=\"sy1\">{</span><br/>            k <span class=\"sy2\">=</span> tree<span class=\"sy1\">[</span>n<span class=\"sy1\">]</span><span class=\"sy3\">.</span>length<br/>            <span class=\"kw1\">if</span> b <span class=\"sy2\">:=</span> <span class=\"nu2\">i</span> <span class=\"sy3\">-</span> k <span class=\"sy3\">-</span> <span class=\"nu0\">1</span><span class=\"sy1\">;</span> b &gt;<span class=\"sy2\">=</span> <span class=\"nu0\">0</span> &amp;&amp; s<span class=\"sy1\">[</span>b<span class=\"sy1\">]</span> <span class=\"sy3\">==</span> c <span class=\"sy1\">{</span><br/>                <span class=\"kw1\">break</span><br/>            <span class=\"sy1\">}</span><br/>        <span class=\"sy1\">}</span><br/>        <span class=\"kw1\">if</span> e<span class=\"sy1\">,</span> ok <span class=\"sy2\">:=</span> tree<span class=\"sy1\">[</span>n<span class=\"sy1\">]</span><span class=\"sy3\">.</span>edges<span class=\"sy1\">[</span>c<span class=\"sy1\">];</span> ok <span class=\"sy1\">{</span><br/>            suffix <span class=\"sy2\">=</span> e<br/>            <span class=\"kw1\">continue</span><br/>        <span class=\"sy1\">}</span><br/>        suffix <span class=\"sy2\">=</span> <span class=\"kw3\">len</span><span class=\"sy1\">(</span>tree<span class=\"sy1\">)</span><br/>        tree <span class=\"sy2\">=</span> append<span class=\"sy1\">(</span>tree<span class=\"sy1\">,</span> node<span class=\"sy1\">{</span>length<span class=\"sy1\">:</span> k <span class=\"sy3\">+</span> <span class=\"nu0\">2</span><span class=\"sy1\">,</span> edges<span class=\"sy1\">:</span> edges<span class=\"sy1\">{}})</span><br/>        tree<span class=\"sy1\">[</span>n<span class=\"sy1\">]</span><span class=\"sy3\">.</span>edges<span class=\"sy1\">[</span>c<span class=\"sy1\">]</span> <span class=\"sy2\">=</span> suffix<br/>        <span class=\"kw1\">if</span> tree<span class=\"sy1\">[</span>suffix<span class=\"sy1\">]</span><span class=\"sy3\">.</span>length <span class=\"sy3\">==</span> <span class=\"nu0\">1</span> <span class=\"sy1\">{</span><br/>            tree<span class=\"sy1\">[</span>suffix<span class=\"sy1\">]</span><span class=\"sy3\">.</span>suffix <span class=\"sy2\">=</span> <span class=\"nu0\">0</span><br/>            <span class=\"kw1\">continue</span><br/>        <span class=\"sy1\">}</span><br/>        <span class=\"kw1\">for</span> <span class=\"sy1\">{</span><br/>            n <span class=\"sy2\">=</span> tree<span class=\"sy1\">[</span>n<span class=\"sy1\">]</span><span class=\"sy3\">.</span>suffix<br/>            <span class=\"kw1\">if</span> b <span class=\"sy2\">:=</span> <span class=\"nu2\">i</span> <span class=\"sy3\">-</span> tree<span class=\"sy1\">[</span>n<span class=\"sy1\">]</span><span class=\"sy3\">.</span>length <span class=\"sy3\">-</span> <span class=\"nu0\">1</span><span class=\"sy1\">;</span> b &gt;<span class=\"sy2\">=</span> <span class=\"nu0\">0</span> &amp;&amp; s<span class=\"sy1\">[</span>b<span class=\"sy1\">]</span> <span class=\"sy3\">==</span> c <span class=\"sy1\">{</span><br/>                <span class=\"kw1\">break</span><br/>            <span class=\"sy1\">}</span><br/>        <span class=\"sy1\">}</span><br/>        tree<span class=\"sy1\">[</span>suffix<span class=\"sy1\">]</span><span class=\"sy3\">.</span>suffix <span class=\"sy2\">=</span> tree<span class=\"sy1\">[</span>n<span class=\"sy1\">]</span><span class=\"sy3\">.</span>edges<span class=\"sy1\">[</span>c<span class=\"sy1\">]</span><br/>    <span class=\"sy1\">}</span><br/>    <span class=\"kw1\">return</span> tree<br/><span class=\"sy1\">}</span><br/>\u00a0<br/><span class=\"kw4\">func</span> subPalindromes<span class=\"sy1\">(</span>tree <span class=\"sy1\">[]</span>node<span class=\"sy1\">)</span> <span class=\"sy1\">(</span>s <span class=\"sy1\">[]</span><span class=\"kw4\">string</span><span class=\"sy1\">)</span> <span class=\"sy1\">{</span><br/>    <span class=\"kw1\">var</span> children <span class=\"kw4\">func</span><span class=\"sy1\">(</span><span class=\"kw4\">int</span><span class=\"sy1\">,</span> <span class=\"kw4\">string</span><span class=\"sy1\">)</span><br/>    children <span class=\"sy2\">=</span> <span class=\"kw4\">func</span><span class=\"sy1\">(</span>n <span class=\"kw4\">int</span><span class=\"sy1\">,</span> p <span class=\"kw4\">string</span><span class=\"sy1\">)</span> <span class=\"sy1\">{</span><br/>        <span class=\"kw1\">for</span> c<span class=\"sy1\">,</span> n <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> tree<span class=\"sy1\">[</span>n<span class=\"sy1\">]</span><span class=\"sy3\">.</span>edges <span class=\"sy1\">{</span><br/>            c <span class=\"sy2\">:=</span> <span class=\"kw4\">string</span><span class=\"sy1\">(</span>c<span class=\"sy1\">)</span><br/>            p <span class=\"sy2\">:=</span> c <span class=\"sy3\">+</span> p <span class=\"sy3\">+</span> c<br/>            s <span class=\"sy2\">=</span> append<span class=\"sy1\">(</span>s<span class=\"sy1\">,</span> p<span class=\"sy1\">)</span><br/>            children<span class=\"sy1\">(</span>n<span class=\"sy1\">,</span> p<span class=\"sy1\">)</span><br/>        <span class=\"sy1\">}</span><br/>    <span class=\"sy1\">}</span><br/>    children<span class=\"sy1\">(</span><span class=\"nu0\">0</span><span class=\"sy1\">,</span> <span class=\"st0\">\"\"</span><span class=\"sy1\">)</span><br/>    <span class=\"kw1\">for</span> c<span class=\"sy1\">,</span> n <span class=\"sy2\">:=</span> <span class=\"kw1\">range</span> tree<span class=\"sy1\">[</span><span class=\"nu0\">1</span><span class=\"sy1\">]</span><span class=\"sy3\">.</span>edges <span class=\"sy1\">{</span><br/>        c <span class=\"sy2\">:=</span> <span class=\"kw4\">string</span><span class=\"sy1\">(</span>c<span class=\"sy1\">)</span><br/>        s <span class=\"sy2\">=</span> append<span class=\"sy1\">(</span>s<span class=\"sy1\">,</span> c<span class=\"sy1\">)</span><br/>        children<span class=\"sy1\">(</span>n<span class=\"sy1\">,</span> c<span class=\"sy1\">)</span><br/>    <span class=\"sy1\">}</span><br/>    <span class=\"kw1\">return</span><br/><span class=\"sy1\">}</span></pre>"}, {"lang": "Java", "loc": 91, "block": "<pre class=\"java highlighted_source\"><span class=\"kw1\">import</span> <span class=\"co2\">java.util.ArrayList</span><span class=\"sy0\">;</span><br/><span class=\"kw1\">import</span> <span class=\"co2\">java.util.HashMap</span><span class=\"sy0\">;</span><br/><span class=\"kw1\">import</span> <span class=\"co2\">java.util.List</span><span class=\"sy0\">;</span><br/><span class=\"kw1\">import</span> <span class=\"co2\">java.util.Map</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"kw1\">public</span> <span class=\"kw1\">class</span> Eertree <span class=\"br0\">{</span><br/>    <span class=\"kw1\">public</span> <span class=\"kw1\">static</span> <span class=\"kw4\">void</span> main<span class=\"br0\">(</span><a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Astring+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">String</span></a><span class=\"br0\">[</span><span class=\"br0\">]</span> args<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        List<span class=\"sy0\">&lt;</span>Node<span class=\"sy0\">&gt;</span> tree <span class=\"sy0\">=</span> eertree<span class=\"br0\">(</span><span class=\"st0\">\"eertree\"</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        List<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span> result <span class=\"sy0\">=</span> subPalindromes<span class=\"br0\">(</span>tree<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Asystem+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">System</span></a>.<span class=\"me1\">out</span>.<span class=\"me1\">println</span><span class=\"br0\">(</span>result<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"kw1\">private</span> <span class=\"kw1\">static</span> <span class=\"kw1\">class</span> Node <span class=\"br0\">{</span><br/>        <span class=\"kw4\">int</span> length<span class=\"sy0\">;</span><br/>        Map<span class=\"sy0\">&lt;</span><a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Acharacter+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">Character</span></a>, Integer<span class=\"sy0\">&gt;</span> edges <span class=\"sy0\">=</span> <span class=\"kw1\">new</span> HashMap<span class=\"sy0\">&lt;&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"kw4\">int</span> suffix<span class=\"sy0\">;</span><br/>\u00a0<br/>        <span class=\"kw1\">public</span> Node<span class=\"br0\">(</span><span class=\"kw4\">int</span> length<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">this</span>.<span class=\"me1\">length</span> <span class=\"sy0\">=</span> length<span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"kw1\">public</span> Node<span class=\"br0\">(</span><span class=\"kw4\">int</span> length, Map<span class=\"sy0\">&lt;</span><a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Acharacter+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">Character</span></a>, Integer<span class=\"sy0\">&gt;</span> edges, <span class=\"kw4\">int</span> suffix<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw1\">this</span>.<span class=\"me1\">length</span> <span class=\"sy0\">=</span> length<span class=\"sy0\">;</span><br/>            <span class=\"kw1\">this</span>.<span class=\"me1\">edges</span> <span class=\"sy0\">=</span> edges <span class=\"sy0\">!=</span> <span class=\"kw2\">null</span> <span class=\"sy0\">?</span> edges <span class=\"sy0\">:</span> <span class=\"kw1\">new</span> HashMap<span class=\"sy0\">&lt;&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">this</span>.<span class=\"me1\">suffix</span> <span class=\"sy0\">=</span> suffix<span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"kw1\">private</span> <span class=\"kw1\">static</span> <span class=\"kw1\">final</span> <span class=\"kw4\">int</span> EVEN_ROOT <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">private</span> <span class=\"kw1\">static</span> <span class=\"kw1\">final</span> <span class=\"kw4\">int</span> ODD_ROOT <span class=\"sy0\">=</span> <span class=\"nu0\">1</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"kw1\">private</span> <span class=\"kw1\">static</span> List<span class=\"sy0\">&lt;</span>Node<span class=\"sy0\">&gt;</span> eertree<span class=\"br0\">(</span><a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Astring+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">String</span></a> s<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        List<span class=\"sy0\">&lt;</span>Node<span class=\"sy0\">&gt;</span> tree <span class=\"sy0\">=</span> <span class=\"kw1\">new</span> ArrayList<span class=\"sy0\">&lt;&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        tree.<span class=\"me1\">add</span><span class=\"br0\">(</span><span class=\"kw1\">new</span> Node<span class=\"br0\">(</span><span class=\"nu0\">0</span>, <span class=\"kw2\">null</span>, ODD_ROOT<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        tree.<span class=\"me1\">add</span><span class=\"br0\">(</span><span class=\"kw1\">new</span> Node<span class=\"br0\">(</span><span class=\"sy0\">-</span><span class=\"nu0\">1</span>, <span class=\"kw2\">null</span>, ODD_ROOT<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"kw4\">int</span> suffix <span class=\"sy0\">=</span> ODD_ROOT<span class=\"sy0\">;</span><br/>        <span class=\"kw4\">int</span> n, k<span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span> <span class=\"br0\">(</span><span class=\"kw4\">int</span> i <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span> i <span class=\"sy0\">&lt;</span> s.<span class=\"me1\">length</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"sy0\">++</span>i<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"kw4\">char</span> c <span class=\"sy0\">=</span> s.<span class=\"me1\">charAt</span><span class=\"br0\">(</span>i<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">for</span> <span class=\"br0\">(</span>n <span class=\"sy0\">=</span> suffix<span class=\"sy0\">;</span> <span class=\"sy0\">;</span> n <span class=\"sy0\">=</span> tree.<span class=\"me1\">get</span><span class=\"br0\">(</span>n<span class=\"br0\">)</span>.<span class=\"me1\">suffix</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                k <span class=\"sy0\">=</span> tree.<span class=\"me1\">get</span><span class=\"br0\">(</span>n<span class=\"br0\">)</span>.<span class=\"me1\">length</span><span class=\"sy0\">;</span><br/>                <span class=\"kw4\">int</span> b <span class=\"sy0\">=</span> i <span class=\"sy0\">-</span> k <span class=\"sy0\">-</span> <span class=\"nu0\">1</span><span class=\"sy0\">;</span><br/>                <span class=\"kw1\">if</span> <span class=\"br0\">(</span>b <span class=\"sy0\">&gt;=</span> <span class=\"nu0\">0</span> <span class=\"sy0\">&amp;&amp;</span> s.<span class=\"me1\">charAt</span><span class=\"br0\">(</span>b<span class=\"br0\">)</span> <span class=\"sy0\">==</span> c<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                    <span class=\"kw1\">break</span><span class=\"sy0\">;</span><br/>                <span class=\"br0\">}</span><br/>            <span class=\"br0\">}</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>tree.<span class=\"me1\">get</span><span class=\"br0\">(</span>n<span class=\"br0\">)</span>.<span class=\"me1\">edges</span>.<span class=\"me1\">containsKey</span><span class=\"br0\">(</span>c<span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                suffix <span class=\"sy0\">=</span> tree.<span class=\"me1\">get</span><span class=\"br0\">(</span>n<span class=\"br0\">)</span>.<span class=\"me1\">edges</span>.<span class=\"me1\">get</span><span class=\"br0\">(</span>c<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>                <span class=\"kw1\">continue</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>            suffix <span class=\"sy0\">=</span> tree.<span class=\"me1\">size</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            tree.<span class=\"me1\">add</span><span class=\"br0\">(</span><span class=\"kw1\">new</span> Node<span class=\"br0\">(</span>k <span class=\"sy0\">+</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            tree.<span class=\"me1\">get</span><span class=\"br0\">(</span>n<span class=\"br0\">)</span>.<span class=\"me1\">edges</span>.<span class=\"me1\">put</span><span class=\"br0\">(</span>c, suffix<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            <span class=\"kw1\">if</span> <span class=\"br0\">(</span>tree.<span class=\"me1\">get</span><span class=\"br0\">(</span>suffix<span class=\"br0\">)</span>.<span class=\"me1\">length</span> <span class=\"sy0\">==</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                tree.<span class=\"me1\">get</span><span class=\"br0\">(</span>suffix<span class=\"br0\">)</span>.<span class=\"me1\">suffix</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/>                <span class=\"kw1\">continue</span><span class=\"sy0\">;</span><br/>            <span class=\"br0\">}</span><br/>            <span class=\"kw1\">while</span> <span class=\"br0\">(</span><span class=\"kw2\">true</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                n <span class=\"sy0\">=</span> tree.<span class=\"me1\">get</span><span class=\"br0\">(</span>n<span class=\"br0\">)</span>.<span class=\"me1\">suffix</span><span class=\"sy0\">;</span><br/>                <span class=\"kw4\">int</span> b <span class=\"sy0\">=</span> i <span class=\"sy0\">-</span> tree.<span class=\"me1\">get</span><span class=\"br0\">(</span>n<span class=\"br0\">)</span>.<span class=\"me1\">length</span> <span class=\"sy0\">-</span> <span class=\"nu0\">1</span><span class=\"sy0\">;</span><br/>                <span class=\"kw1\">if</span> <span class=\"br0\">(</span>b <span class=\"sy0\">&gt;=</span> <span class=\"nu0\">0</span> <span class=\"sy0\">&amp;&amp;</span> s.<span class=\"me1\">charAt</span><span class=\"br0\">(</span>b<span class=\"br0\">)</span> <span class=\"sy0\">==</span> c<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                    <span class=\"kw1\">break</span><span class=\"sy0\">;</span><br/>                <span class=\"br0\">}</span><br/>            <span class=\"br0\">}</span><br/>            tree.<span class=\"me1\">get</span><span class=\"br0\">(</span>suffix<span class=\"br0\">)</span>.<span class=\"me1\">suffix</span> <span class=\"sy0\">=</span> tree.<span class=\"me1\">get</span><span class=\"br0\">(</span>n<span class=\"br0\">)</span>.<span class=\"me1\">edges</span>.<span class=\"me1\">get</span><span class=\"br0\">(</span>c<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>        <span class=\"kw1\">return</span> tree<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"kw1\">private</span> <span class=\"kw1\">static</span> List<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span> subPalindromes<span class=\"br0\">(</span>List<span class=\"sy0\">&lt;</span>Node<span class=\"sy0\">&gt;</span> tree<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        List<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span> s <span class=\"sy0\">=</span> <span class=\"kw1\">new</span> ArrayList<span class=\"sy0\">&lt;&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        subPalindromes_children<span class=\"br0\">(</span><span class=\"nu0\">0</span>, <span class=\"st0\">\"\"</span>, tree, s<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"kw1\">for</span> <span class=\"br0\">(</span><a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Amap+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">Map</span></a>.<span class=\"me1\">Entry</span><span class=\"sy0\">&lt;</span><a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Acharacter+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">Character</span></a>, Integer<span class=\"sy0\">&gt;</span> cm <span class=\"sy0\">:</span> tree.<span class=\"me1\">get</span><span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span>.<span class=\"me1\">edges</span>.<span class=\"me1\">entrySet</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Astring+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">String</span></a> ct <span class=\"sy0\">=</span> <a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Astring+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">String</span></a>.<span class=\"me1\">valueOf</span><span class=\"br0\">(</span>cm.<span class=\"me1\">getKey</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            s.<span class=\"me1\">add</span><span class=\"br0\">(</span>ct<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            subPalindromes_children<span class=\"br0\">(</span>cm.<span class=\"me1\">getValue</span><span class=\"br0\">(</span><span class=\"br0\">)</span>, ct, tree, s<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>        <span class=\"kw1\">return</span> s<span class=\"sy0\">;</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <span class=\"co1\">// nested methods are a pain, even if lambdas make that possible for Java</span><br/>    <span class=\"kw1\">private</span> <span class=\"kw1\">static</span> <span class=\"kw4\">void</span> subPalindromes_children<span class=\"br0\">(</span><span class=\"kw1\">final</span> <span class=\"kw4\">int</span> n, <span class=\"kw1\">final</span> <a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Astring+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">String</span></a> p, <span class=\"kw1\">final</span> List<span class=\"sy0\">&lt;</span>Node<span class=\"sy0\">&gt;</span> tree, List<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span> s<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"kw1\">for</span> <span class=\"br0\">(</span><a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Amap+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">Map</span></a>.<span class=\"me1\">Entry</span><span class=\"sy0\">&lt;</span><a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Acharacter+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">Character</span></a>, Integer<span class=\"sy0\">&gt;</span> cm <span class=\"sy0\">:</span> tree.<span class=\"me1\">get</span><span class=\"br0\">(</span>n<span class=\"br0\">)</span>.<span class=\"me1\">edges</span>.<span class=\"me1\">entrySet</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Acharacter+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">Character</span></a> c <span class=\"sy0\">=</span> cm.<span class=\"me1\">getKey</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            <a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Ainteger+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">Integer</span></a> m <span class=\"sy0\">=</span> cm.<span class=\"me1\">getValue</span><span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            <a href=\"http://www.google.com/search?hl=en&amp;q=allinurl%3Astring+java.sun.com&amp;btnI=I%27m%20Feeling%20Lucky\"><span class=\"kw3\">String</span></a> pl <span class=\"sy0\">=</span> c <span class=\"sy0\">+</span> p <span class=\"sy0\">+</span> c<span class=\"sy0\">;</span><br/>            s.<span class=\"me1\">add</span><span class=\"br0\">(</span>pl<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>            subPalindromes_children<span class=\"br0\">(</span>m, pl, tree, s<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>        <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Kotlin", "loc": 119, "block": "<pre class=\"scala highlighted_source\"><span class=\"co1\">// version 1.1.4</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">class</span></a> Node <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> edges <span class=\"sy0\">=</span> mutableMapOf<span class=\"sy0\">&lt;</span>Char, Node<span class=\"sy0\">&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span>  <span class=\"co1\">// edges (or forward links)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> link<span class=\"sy0\">:</span> Node<span class=\"sy0\">?</span> <span class=\"sy0\">=</span> <a href=\"http://scala-lang.org\"><span class=\"kw1\">null</span></a>                  <span class=\"co1\">// suffix link (backward links)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> len <span class=\"sy0\">=</span> <span class=\"nu0\">0</span>                             <span class=\"co1\">// the length of the node</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">class</span></a> Eertree<span class=\"br0\">(</span>str<span class=\"sy0\">:</span> String<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> nodes <span class=\"sy0\">=</span> mutableListOf<span class=\"sy0\">&lt;</span>Node<span class=\"sy0\">&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">private</span></a> <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> rto <span class=\"sy0\">=</span> Node<span class=\"br0\">(</span><span class=\"br0\">)</span>                <span class=\"co1\">// odd length root node, or node -1</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">private</span></a> <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> rte <span class=\"sy0\">=</span> Node<span class=\"br0\">(</span><span class=\"br0\">)</span>                <span class=\"co1\">// even length root node, or node 0</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">private</span></a> <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> s <span class=\"sy0\">=</span> StringBuilder<span class=\"br0\">(</span><span class=\"st0\">\"0\"</span><span class=\"br0\">)</span>      <span class=\"co1\">// accumulated input string, T = S[1..i]</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">private</span></a> <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> maxSufT <span class=\"sy0\">=</span> rte               <span class=\"co1\">// maximum suffix of tree T</span><br/>\u00a0<br/>    init <span class=\"br0\">{</span><br/>        <span class=\"co1\">// Initialize and build the tree</span><br/>        rte.<span class=\"me1\">link</span> <span class=\"sy0\">=</span> rto<br/>        rto.<span class=\"me1\">link</span> <span class=\"sy0\">=</span> rte<br/>        rto.<span class=\"me1\">len</span>  <span class=\"sy0\">=</span> -<span class=\"nu0\">1</span><br/>        rte.<span class=\"me1\">len</span>  <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span>ch in str<span class=\"br0\">)</span> add<span class=\"br0\">(</span>ch<span class=\"br0\">)</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">private</span></a> fun getMaxSuffixPal<span class=\"br0\">(</span>startNode<span class=\"sy0\">:</span> Node, a<span class=\"sy0\">:</span> Char<span class=\"br0\">)</span><span class=\"sy0\">:</span> Node <span class=\"br0\">{</span><br/>        <span class=\"co1\">// We traverse the suffix-palindromes of T in the order of decreasing length.</span><br/>        <span class=\"co1\">// For each palindrome we read its length k and compare T[i-k] against a</span><br/>        <span class=\"co1\">// until we get an equality or arrive at the -1 node.</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> u <span class=\"sy0\">=</span> startNode<br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> i <span class=\"sy0\">=</span> s.<span class=\"me1\">length</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">var</span></a> k <span class=\"sy0\">=</span> u.<span class=\"me1\">len</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">while</span></a> <span class=\"br0\">(</span>u <span class=\"sy0\">!==</span> rto <span class=\"sy0\">&amp;&amp;</span> s<span class=\"br0\">[</span>i - k - <span class=\"nu0\">1</span><span class=\"br0\">]</span> <span class=\"sy0\">!=</span> a<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>u <span class=\"sy0\">===</span> u.<span class=\"me1\">link</span><span class=\"sy0\">!!</span><span class=\"br0\">)</span> <a href=\"http://scala-lang.org\"><span class=\"kw1\">throw</span></a> RuntimeException<span class=\"br0\">(</span><span class=\"st0\">\"Infinite loop detected\"</span><span class=\"br0\">)</span><br/>            u <span class=\"sy0\">=</span> u.<span class=\"me1\">link</span><span class=\"sy0\">!!</span><br/>            k <span class=\"sy0\">=</span> u.<span class=\"me1\">len</span><br/>        <span class=\"br0\">}</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">return</span></a> u<br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">private</span></a> fun add<span class=\"br0\">(</span>a<span class=\"sy0\">:</span> Char<span class=\"br0\">)</span><span class=\"sy0\">:</span> Boolean <span class=\"br0\">{</span><br/>        <span class=\"co1\">// We need to find the maximum suffix-palindrome P of Ta</span><br/>        <span class=\"co1\">// Start by finding maximum suffix-palindrome Q of T.</span><br/>        <span class=\"co1\">// To do this, we traverse the suffix-palindromes of T</span><br/>        <span class=\"co1\">// in the order of decreasing length, starting with maxSuf(T)</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> q <span class=\"sy0\">=</span> getMaxSuffixPal<span class=\"br0\">(</span>maxSufT, a<span class=\"br0\">)</span><br/>\u00a0<br/>        <span class=\"co1\">// We check Q to see whether it has an outgoing edge labeled by a.</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> createANewNode <span class=\"sy0\">=</span> a <span class=\"sy0\">!</span>in q.<span class=\"me1\">edges</span>.<span class=\"me1\">keys</span><br/>\u00a0<br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>createANewNode<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            <span class=\"co1\">// We create the node P of length Q + 2</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> p <span class=\"sy0\">=</span> Node<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>            nodes.<span class=\"me1\">add</span><span class=\"br0\">(</span>p<span class=\"br0\">)</span><br/>            p.<span class=\"me1\">len</span> <span class=\"sy0\">=</span> q.<span class=\"me1\">len</span> + <span class=\"nu0\">2</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>p.<span class=\"me1\">len</span> <span class=\"sy0\">==</span> <span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>                <span class=\"co1\">// if P = a, create the suffix link (P, 0)</span><br/>                p.<span class=\"me1\">link</span> <span class=\"sy0\">=</span> rte<br/>            <span class=\"br0\">}</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">else</span></a> <span class=\"br0\">{</span><br/>                <span class=\"co1\">// It remains to create the suffix link from P if |P|&gt;1. Just</span><br/>                <span class=\"co1\">// continue traversing suffix-palindromes of T starting with the</span><br/>                <span class=\"co1\">// the suffix link of Q.</span><br/>                p.<span class=\"me1\">link</span> <span class=\"sy0\">=</span> getMaxSuffixPal<span class=\"br0\">(</span>q.<span class=\"me1\">link</span><span class=\"sy0\">!!</span>, a<span class=\"br0\">)</span>.<span class=\"me1\">edges</span><span class=\"br0\">[</span>a<span class=\"br0\">]</span><br/>            <span class=\"br0\">}</span><br/>\u00a0<br/>            <span class=\"co1\">// create the edge (Q, P)</span><br/>            q.<span class=\"me1\">edges</span><span class=\"br0\">[</span>a<span class=\"br0\">]</span> <span class=\"sy0\">=</span> p<br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"co1\">// P becomes the new maxSufT</span><br/>        maxSufT <span class=\"sy0\">=</span> q.<span class=\"me1\">edges</span><span class=\"br0\">[</span>a<span class=\"br0\">]</span><span class=\"sy0\">!!</span><br/>\u00a0<br/>        <span class=\"co1\">// Store accumulated input string</span><br/>        s.<span class=\"me1\">append</span><span class=\"br0\">(</span>a<span class=\"br0\">)</span><br/>\u00a0<br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">return</span></a> createANewNode<br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    fun getSubPalindromes<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">:</span> List<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span> <span class=\"br0\">{</span><br/>        <span class=\"co1\">// Traverse tree to find sub-palindromes</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> result <span class=\"sy0\">=</span> mutableListOf<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>        <span class=\"co1\">// Odd length words</span><br/>        getSubPalindromes<span class=\"br0\">(</span>rto, listOf<span class=\"br0\">(</span>rto<span class=\"br0\">)</span>, <span class=\"st0\">\"\"</span>, result<span class=\"br0\">)</span><br/>        <span class=\"co1\">// Even length words</span><br/>        getSubPalindromes<span class=\"br0\">(</span>rte, listOf<span class=\"br0\">(</span>rte<span class=\"br0\">)</span>, <span class=\"st0\">\"\"</span>, result<span class=\"br0\">)</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">return</span></a> result<br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">private</span></a> fun getSubPalindromes<span class=\"br0\">(</span>nd<span class=\"sy0\">:</span> Node, nodesToHere<span class=\"sy0\">:</span> List<span class=\"sy0\">&lt;</span>Node<span class=\"sy0\">&gt;</span>,<br/>                          charsToHere<span class=\"sy0\">:</span> String, result<span class=\"sy0\">:</span> MutableList<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <span class=\"co1\">// Each node represents a palindrome, which can be reconstructed</span><br/>        <span class=\"co1\">// by the path from the root node to each non-root node.</span><br/>\u00a0<br/>        <span class=\"co1\">// Traverse all edges, since they represent other palindromes</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">for</span></a> <span class=\"br0\">(</span><span class=\"br0\">(</span>lnkName, nd2<span class=\"br0\">)</span> in nd.<span class=\"me1\">edges</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            getSubPalindromes<span class=\"br0\">(</span>nd2, nodesToHere + nd2, charsToHere + lnkName, result<span class=\"br0\">)</span><br/>        <span class=\"br0\">}</span><br/>\u00a0<br/>        <span class=\"co1\">// Reconstruct based on charsToHere characters.</span><br/>        <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>nd <span class=\"sy0\">!==</span> rto <span class=\"sy0\">&amp;&amp;</span> nd <span class=\"sy0\">!==</span> rte<span class=\"br0\">)</span> <span class=\"br0\">{</span> <span class=\"co1\">// Don't print for root nodes</span><br/>            <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> assembled <span class=\"sy0\">=</span> charsToHere.<span class=\"me1\">reversed</span><span class=\"br0\">(</span><span class=\"br0\">)</span> +<br/>                <a href=\"http://scala-lang.org\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span>nodesToHere<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span> <span class=\"sy0\">===</span> rte<span class=\"br0\">)</span>  <span class=\"co1\">// Even string</span><br/>                    charsToHere<br/>                <a href=\"http://scala-lang.org\"><span class=\"kw1\">else</span></a>  <span class=\"co1\">// Odd string</span><br/>                    charsToHere.<span class=\"me1\">drop</span><span class=\"br0\">(</span><span class=\"nu0\">1</span><span class=\"br0\">)</span><br/>            result.<span class=\"me1\">add</span><span class=\"br0\">(</span>assembled<span class=\"br0\">)</span><br/>        <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/>fun main<span class=\"br0\">(</span>args<span class=\"sy0\">:</span> Array<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> str <span class=\"sy0\">=</span> <span class=\"st0\">\"eertree\"</span><br/>    println<span class=\"br0\">(</span><span class=\"st0\">\"Processing string '$str'\"</span><span class=\"br0\">)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> eertree <span class=\"sy0\">=</span> Eertree<span class=\"br0\">(</span>str<span class=\"br0\">)</span><br/>    println<span class=\"br0\">(</span><span class=\"st0\">\"Number of sub-palindromes: ${eertree.nodes.size}\"</span><span class=\"br0\">)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> result <span class=\"sy0\">=</span> eertree.<span class=\"me1\">getSubPalindromes</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>    println<span class=\"br0\">(</span><span class=\"st0\">\"Sub-palindromes: $result\"</span><span class=\"br0\">)</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Phix", "loc": 77, "block": "<pre class=\"text highlighted_source\">enum LEN,SUFF,CHARS,NEXT<br/>\u00a0<br/>function node(integer len, suffix=1, string chars=\"\", sequence next={})<br/>    return {len,suffix,chars,next} -- must match above enum!<br/>end function <br/>\u00a0<br/>function eertree(string s)<br/>sequence tree = {node(-1),  -- odd lengths<br/>                 node(0)}   -- even lengths<br/>integer suff = 2    -- max suffix palindrome<br/>\u00a0<br/>    for i=1 to length(s) do<br/>        integer cur = suff, curlen, ch = s[i], k<br/>        while (true) do<br/>            curlen = tree[cur][LEN]<br/>            k = i-1-curlen<br/>            if k&gt;=1 and s[k]==ch then<br/>                exit<br/>            end if<br/>            cur = tree[cur][SUFF]<br/>        end while<br/>        k = find(ch,tree[cur][CHARS])<br/>        if k then<br/>            suff = tree[cur][NEXT][k]<br/>        else<br/>            tree = append(tree,node(curlen+2))<br/>            suff = length(tree)<br/>            tree[cur][CHARS] &amp;= ch<br/>            tree[cur][NEXT] &amp;= suff<br/>\u00a0<br/>            if tree[suff][LEN]==1 then<br/>                tree[suff][SUFF] = 2<br/>            else<br/>                while (true) do<br/>                    cur = tree[cur][SUFF]<br/>                    curlen = tree[cur][LEN]<br/>                    k = i-1-curlen<br/>                    if k&gt;=0 and s[k]==ch then<br/>                        k = find(ch,tree[cur][CHARS])<br/>                        if k then<br/>                            tree[suff][SUFF] = tree[cur][NEXT][k]<br/>                        end if<br/>                        exit<br/>                    end if<br/>                end while<br/>            end if<br/>        end if<br/>    end for<br/>    return tree<br/>end function<br/>\u00a0<br/>function children(sequence s, tree, integer n, string root=\"\")<br/>    for i=1 to length(tree[n][CHARS]) do<br/>        integer c = tree[n][CHARS][i],<br/>                nxt = tree[n][NEXT][i]<br/>        string p = iff(n=1\u00a0? c&amp;\"\"<br/>                          \u00a0: c&amp;root&amp;c)<br/>        s = append(s, p)<br/>        s = children(s, tree, nxt, p)<br/>    end for<br/>    return s<br/>end function<br/>\u00a0<br/>procedure main()<br/>    sequence tree = eertree(\"eertree\")<br/>    puts(1,\"tree:\\n\")<br/>    for i=1 to length(tree) do<br/>        sequence ti = tree[i]<br/>        ti[NEXT] = sprint(ti[NEXT])<br/>        printf(1,\"[%d]: len:%2d  suffix:%d  chars:%-5s next:%s\\n\",i&amp;ti)<br/>    end for<br/>    puts(1,\"\\n\")<br/>\u00a0<br/>    -- odd then even lengths:<br/>   \u00a0?children(children(s,tree,1), tree, 2)<br/>end procedure<br/>main()</pre>"}, {"lang": "Python", "loc": 105, "block": "<pre class=\"python highlighted_source\"><span class=\"co1\">#!/bin/python</span><br/><span class=\"kw1\">from</span> <span class=\"kw3\">__future__</span> <span class=\"kw1\">import</span> print_function<br/>\u00a0<br/><span class=\"kw1\">class</span> Node<span class=\"br0\">(</span><span class=\"kw2\">object</span><span class=\"br0\">)</span>:<br/>\t<span class=\"kw1\">def</span> <span class=\"kw4\">__init__</span><span class=\"br0\">(</span><span class=\"kw2\">self</span><span class=\"br0\">)</span>:<br/>\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">edges</span> <span class=\"sy0\">=</span> <span class=\"br0\">{</span><span class=\"br0\">}</span> <span class=\"co1\"># edges (or forward links)</span><br/>\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">link</span> <span class=\"sy0\">=</span> <span class=\"kw2\">None</span> <span class=\"co1\"># suffix link (backward links)</span><br/>\t\t<span class=\"kw2\">self</span>.<span class=\"kw2\">len</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span> <span class=\"co1\"># the length of the node</span><br/>\u00a0<br/><span class=\"kw1\">class</span> Eertree<span class=\"br0\">(</span><span class=\"kw2\">object</span><span class=\"br0\">)</span>:<br/>\t<span class=\"kw1\">def</span> <span class=\"kw4\">__init__</span><span class=\"br0\">(</span><span class=\"kw2\">self</span><span class=\"br0\">)</span>:<br/>\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">nodes</span> <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><br/>\t\t<span class=\"co1\"># two initial root nodes</span><br/>\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">rto</span> <span class=\"sy0\">=</span> Node<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"co1\">#odd length root node, or node -1</span><br/>\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">rte</span> <span class=\"sy0\">=</span> Node<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"co1\">#even length root node, or node 0</span><br/>\u00a0<br/>\t\t<span class=\"co1\"># Initialize empty tree</span><br/>\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">rto</span>.<span class=\"me1\">link</span> <span class=\"sy0\">=</span> <span class=\"kw2\">self</span>.<span class=\"me1\">rte</span>.<span class=\"me1\">link</span> <span class=\"sy0\">=</span> <span class=\"kw2\">self</span>.<span class=\"me1\">rto</span><span class=\"sy0\">;</span><br/>\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">rto</span>.<span class=\"kw2\">len</span> <span class=\"sy0\">=</span> -<span class=\"nu0\">1</span><br/>\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">rte</span>.<span class=\"kw2\">len</span> <span class=\"sy0\">=</span> <span class=\"nu0\">0</span><br/>\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">S</span> <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span> <span class=\"co1\"># accumulated input string, T=S[1..i]</span><br/>\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">maxSufT</span> <span class=\"sy0\">=</span> <span class=\"kw2\">self</span>.<span class=\"me1\">rte</span> <span class=\"co1\"># maximum suffix of tree T</span><br/>\u00a0<br/>\t<span class=\"kw1\">def</span> get_max_suffix_pal<span class=\"br0\">(</span><span class=\"kw2\">self</span><span class=\"sy0\">,</span> startNode<span class=\"sy0\">,</span> a<span class=\"br0\">)</span>:<br/>\t\t<span class=\"co1\"># We traverse the suffix-palindromes of T in the order of decreasing length.</span><br/>\t\t<span class=\"co1\"># For each palindrome we read its length k and compare T[i-k] against a</span><br/>\t\t<span class=\"co1\"># until we get an equality or arrive at the -1 node.</span><br/>\t\tu <span class=\"sy0\">=</span> startNode<br/>\t\ti <span class=\"sy0\">=</span> <span class=\"kw2\">len</span><span class=\"br0\">(</span><span class=\"kw2\">self</span>.<span class=\"me1\">S</span><span class=\"br0\">)</span><br/>\t\tk <span class=\"sy0\">=</span> u.<span class=\"kw2\">len</span><br/>\t\t<span class=\"kw1\">while</span> <span class=\"kw2\">id</span><span class=\"br0\">(</span>u<span class=\"br0\">)</span> <span class=\"sy0\">!=</span> <span class=\"kw2\">id</span><span class=\"br0\">(</span><span class=\"kw2\">self</span>.<span class=\"me1\">rto</span><span class=\"br0\">)</span> <span class=\"kw1\">and</span> <span class=\"kw2\">self</span>.<span class=\"me1\">S</span><span class=\"br0\">[</span>i - k - <span class=\"nu0\">1</span><span class=\"br0\">]</span> <span class=\"sy0\">!=</span> a:<br/>\t\t\t<span class=\"kw1\">assert</span> <span class=\"kw2\">id</span><span class=\"br0\">(</span>u<span class=\"br0\">)</span> <span class=\"sy0\">!=</span> <span class=\"kw2\">id</span><span class=\"br0\">(</span>u.<span class=\"me1\">link</span><span class=\"br0\">)</span> <span class=\"co1\">#Prevent infinte loop</span><br/>\t\t\tu <span class=\"sy0\">=</span> u.<span class=\"me1\">link</span><br/>\t\t\tk <span class=\"sy0\">=</span> u.<span class=\"kw2\">len</span><br/>\u00a0<br/>\t\t<span class=\"kw1\">return</span> u<br/>\u00a0<br/>\t<span class=\"kw1\">def</span> add<span class=\"br0\">(</span><span class=\"kw2\">self</span><span class=\"sy0\">,</span> a<span class=\"br0\">)</span>:<br/>\u00a0<br/>\t\t<span class=\"co1\"># We need to find the maximum suffix-palindrome P of Ta</span><br/>\t\t<span class=\"co1\"># Start by finding maximum suffix-palindrome Q of T.</span><br/>\t\t<span class=\"co1\"># To do this, we traverse the suffix-palindromes of T</span><br/>\t\t<span class=\"co1\"># in the order of decreasing length, starting with maxSuf(T)</span><br/>\t\tQ <span class=\"sy0\">=</span> <span class=\"kw2\">self</span>.<span class=\"me1\">get_max_suffix_pal</span><span class=\"br0\">(</span><span class=\"kw2\">self</span>.<span class=\"me1\">maxSufT</span><span class=\"sy0\">,</span> a<span class=\"br0\">)</span><br/>\u00a0<br/>\t\t<span class=\"co1\"># We check Q to see whether it has an outgoing edge labeled by a.</span><br/>\t\tcreateANewNode <span class=\"sy0\">=</span> <span class=\"kw1\">not</span> a <span class=\"kw1\">in</span> Q.<span class=\"me1\">edges</span><br/>\u00a0<br/>\t\t<span class=\"kw1\">if</span> createANewNode:<br/>\t\t\t<span class=\"co1\"># We create the node P of length Q+2</span><br/>\t\t\tP <span class=\"sy0\">=</span> Node<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\t\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">nodes</span>.<span class=\"me1\">append</span><span class=\"br0\">(</span>P<span class=\"br0\">)</span><br/>\t\t\tP.<span class=\"kw2\">len</span> <span class=\"sy0\">=</span> Q.<span class=\"kw2\">len</span> + <span class=\"nu0\">2</span><br/>\t\t\t<span class=\"kw1\">if</span> P.<span class=\"kw2\">len</span> <span class=\"sy0\">==</span> <span class=\"nu0\">1</span>:<br/>\t\t\t\t<span class=\"co1\"># if P = a, create the suffix link (P,0)</span><br/>\t\t\t\tP.<span class=\"me1\">link</span> <span class=\"sy0\">=</span> <span class=\"kw2\">self</span>.<span class=\"me1\">rte</span><br/>\t\t\t<span class=\"kw1\">else</span>:<br/>\t\t\t\t<span class=\"co1\"># It remains to create the suffix link from P if |P|&gt;1. Just</span><br/>\t\t\t\t<span class=\"co1\"># continue traversing suffix-palindromes of T starting with the suffix </span><br/>\t\t\t\t<span class=\"co1\"># link of Q.</span><br/>\t\t\t\tP.<span class=\"me1\">link</span> <span class=\"sy0\">=</span> <span class=\"kw2\">self</span>.<span class=\"me1\">get_max_suffix_pal</span><span class=\"br0\">(</span>Q.<span class=\"me1\">link</span><span class=\"sy0\">,</span> a<span class=\"br0\">)</span>.<span class=\"me1\">edges</span><span class=\"br0\">[</span>a<span class=\"br0\">]</span><br/>\u00a0<br/>\t\t\t<span class=\"co1\"># create the edge (Q,P)</span><br/>\t\t\tQ.<span class=\"me1\">edges</span><span class=\"br0\">[</span>a<span class=\"br0\">]</span> <span class=\"sy0\">=</span> P<br/>\u00a0<br/>\t\t<span class=\"co1\">#P becomes the new maxSufT</span><br/>\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">maxSufT</span> <span class=\"sy0\">=</span> Q.<span class=\"me1\">edges</span><span class=\"br0\">[</span>a<span class=\"br0\">]</span><br/>\u00a0<br/>\t\t<span class=\"co1\">#Store accumulated input string</span><br/>\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">S</span>.<span class=\"me1\">append</span><span class=\"br0\">(</span>a<span class=\"br0\">)</span><br/>\u00a0<br/>\t\t<span class=\"kw1\">return</span> createANewNode<br/>\u00a0<br/>\t<span class=\"kw1\">def</span> get_sub_palindromes<span class=\"br0\">(</span><span class=\"kw2\">self</span><span class=\"sy0\">,</span> nd<span class=\"sy0\">,</span> nodesToHere<span class=\"sy0\">,</span> charsToHere<span class=\"sy0\">,</span> result<span class=\"br0\">)</span>:<br/>\t\t<span class=\"co1\">#Each node represents a palindrome, which can be reconstructed</span><br/>\t\t<span class=\"co1\">#by the path from the root node to each non-root node.</span><br/>\u00a0<br/>\t\t<span class=\"co1\">#Traverse all edges, since they represent other palindromes</span><br/>\t\t<span class=\"kw1\">for</span> lnkName <span class=\"kw1\">in</span> nd.<span class=\"me1\">edges</span>:<br/>\t\t\tnd2 <span class=\"sy0\">=</span> nd.<span class=\"me1\">edges</span><span class=\"br0\">[</span>lnkName<span class=\"br0\">]</span> <span class=\"co1\">#The lnkName is the character used for this edge</span><br/>\t\t\t<span class=\"kw2\">self</span>.<span class=\"me1\">get_sub_palindromes</span><span class=\"br0\">(</span>nd2<span class=\"sy0\">,</span> nodesToHere+<span class=\"br0\">[</span>nd2<span class=\"br0\">]</span><span class=\"sy0\">,</span> charsToHere+<span class=\"br0\">[</span>lnkName<span class=\"br0\">]</span><span class=\"sy0\">,</span> result<span class=\"br0\">)</span><br/>\u00a0<br/>\t\t<span class=\"co1\">#Reconstruct based on charsToHere characters.</span><br/>\t\t<span class=\"kw1\">if</span> <span class=\"kw2\">id</span><span class=\"br0\">(</span>nd<span class=\"br0\">)</span> <span class=\"sy0\">!=</span> <span class=\"kw2\">id</span><span class=\"br0\">(</span><span class=\"kw2\">self</span>.<span class=\"me1\">rto</span><span class=\"br0\">)</span> <span class=\"kw1\">and</span> <span class=\"kw2\">id</span><span class=\"br0\">(</span>nd<span class=\"br0\">)</span> <span class=\"sy0\">!=</span> <span class=\"kw2\">id</span><span class=\"br0\">(</span><span class=\"kw2\">self</span>.<span class=\"me1\">rte</span><span class=\"br0\">)</span>: <span class=\"co1\">#Don't print for root nodes</span><br/>\t\t\ttmp <span class=\"sy0\">=</span> <span class=\"st0\">\"\"</span>.<span class=\"me1\">join</span><span class=\"br0\">(</span>charsToHere<span class=\"br0\">)</span><br/>\t\t\t<span class=\"kw1\">if</span> <span class=\"kw2\">id</span><span class=\"br0\">(</span>nodesToHere<span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"br0\">]</span><span class=\"br0\">)</span> <span class=\"sy0\">==</span> <span class=\"kw2\">id</span><span class=\"br0\">(</span><span class=\"kw2\">self</span>.<span class=\"me1\">rte</span><span class=\"br0\">)</span>: <span class=\"co1\">#Even string</span><br/>\t\t\t\tassembled <span class=\"sy0\">=</span> tmp<span class=\"br0\">[</span>::-<span class=\"nu0\">1</span><span class=\"br0\">]</span> + tmp<br/>\t\t\t<span class=\"kw1\">else</span>: <span class=\"co1\">#Odd string</span><br/>\t\t\t\tassembled <span class=\"sy0\">=</span> tmp<span class=\"br0\">[</span>::-<span class=\"nu0\">1</span><span class=\"br0\">]</span> + tmp<span class=\"br0\">[</span><span class=\"nu0\">1</span>:<span class=\"br0\">]</span><br/>\t\t\tresult.<span class=\"me1\">append</span><span class=\"br0\">(</span>assembled<span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"kw1\">if</span> __name__<span class=\"sy0\">==</span><span class=\"st0\">\"__main__\"</span>:<br/>\tst <span class=\"sy0\">=</span> <span class=\"st0\">\"eertree\"</span><br/>\t<span class=\"kw1\">print</span> <span class=\"br0\">(</span><span class=\"st0\">\"Processing string\"</span><span class=\"sy0\">,</span> st<span class=\"br0\">)</span><br/>\teertree <span class=\"sy0\">=</span> Eertree<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\t<span class=\"kw1\">for</span> ch <span class=\"kw1\">in</span> st:<br/>\t\teertree.<span class=\"me1\">add</span><span class=\"br0\">(</span>ch<span class=\"br0\">)</span><br/>\u00a0<br/>\t<span class=\"kw1\">print</span> <span class=\"br0\">(</span><span class=\"st0\">\"Number of sub-palindromes:\"</span><span class=\"sy0\">,</span> <span class=\"kw2\">len</span><span class=\"br0\">(</span>eertree.<span class=\"me1\">nodes</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/>\t<span class=\"co1\">#Traverse tree to find sub-palindromes</span><br/>\tresult <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><br/>\teertree.<span class=\"me1\">get_sub_palindromes</span><span class=\"br0\">(</span>eertree.<span class=\"me1\">rto</span><span class=\"sy0\">,</span> <span class=\"br0\">[</span>eertree.<span class=\"me1\">rto</span><span class=\"br0\">]</span><span class=\"sy0\">,</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">,</span> result<span class=\"br0\">)</span> <span class=\"co1\">#Odd length words</span><br/>\teertree.<span class=\"me1\">get_sub_palindromes</span><span class=\"br0\">(</span>eertree.<span class=\"me1\">rte</span><span class=\"sy0\">,</span> <span class=\"br0\">[</span>eertree.<span class=\"me1\">rte</span><span class=\"br0\">]</span><span class=\"sy0\">,</span> <span class=\"br0\">[</span><span class=\"br0\">]</span><span class=\"sy0\">,</span> result<span class=\"br0\">)</span> <span class=\"co1\">#Even length words</span><br/>\t<span class=\"kw1\">print</span> <span class=\"br0\">(</span><span class=\"st0\">\"Sub-palindromes:\"</span><span class=\"sy0\">,</span> result<span class=\"br0\">)</span></pre>"}, {"lang": "Racket", "loc": 86, "block": "<pre class=\"text highlighted_source\">#lang racket<br/>(struct node (edges\u00a0; edges (or forward links)<br/>              link\u00a0; suffix link (backward links)<br/>              len)\u00a0; the length of the node <br/>  #:mutable)<br/>\u00a0<br/>(define (new-node link len) (node (make-hash) link len))<br/>\u00a0<br/>(struct eertree (nodes<br/>                 rto\u00a0; odd length root node, or node -1<br/>                 rte\u00a0; even length root node, or node 0<br/>                 S\u00a0; accumulated input string, T=S[1..i]<br/>                 max-suf-t)\u00a0; maximum suffix of tree T<br/>  #:mutable)<br/>\u00a0<br/>(define (new-eertree)<br/>  (let* ((rto (new-node #f -1))<br/>         (rte (new-node rto 0)))<br/>    (eertree null rto rte (list 0) rte)))<br/>\u00a0<br/>(define (eertree-get-max-suffix-pal et start-node a)<br/>  #| We traverse the suffix-palindromes of T in the order of decreasing length.<br/>     For each palindrome we read its length k and compare T[i-k] against a<br/>     until we get an equality or arrive at the -1 node. |#<br/>  (match et<br/>    [(eertree nodes rto rte (and S (app length i)) max-suf-t)<br/>     (let loop ((u start-node))<br/>       (let ((k (node-len u)))<br/>         (if (or (eq? u rto) (= (list-ref S (- i k 1)) a))<br/>             u<br/>             (let ((u\u2192 (node-link u)))<br/>               (when (eq? u u\u2192) (error 'eertree-get-max-suffix-pal \"infinite loop\"))<br/>               (loop u\u2192)))))]))<br/>\u00a0<br/>(define (eertree-add! et a)<br/>  #| We need to find the maximum suffix-palindrome P of Ta<br/>     Start by finding maximum suffix-palindrome Q of T.<br/>     To do this, we traverse the suffix-palindromes of T<br/>     in the order of decreasing length, starting with maxSuf(T) |#<br/>  (match (eertree-get-max-suffix-pal et (eertree-max-suf-t et) a)<br/>    [(node Q.edges Q.\u2192 Q.len) <br/>    \u00a0;; We check Q to see whether it has an outgoing edge labeled by a.<br/>     (define new-node? (not (hash-has-key? Q.edges a)))<br/>     (when new-node?<br/>       (define P (new-node #f (+ Q.len 2)))\u00a0; We create the node P of length Q+2<br/>       (set-eertree-nodes! et (append (eertree-nodes et) (list P)))<br/>       (define P\u2192<br/>         (if (= (node-len P) 1)<br/>             (eertree-rte et)\u00a0; if P = a, create the suffix link (P,0)<br/>            \u00a0;; It remains to c reate the suffix link from P if |P|&gt;1.<br/>            \u00a0;; Just continue traversing suffix-palindromes of T starting with the suffix link of Q.<br/>             (hash-ref (node-edges (eertree-get-max-suffix-pal et Q.\u2192 a)) a)))<br/>       (set-node-link! P P\u2192)<br/>       (hash-set! Q.edges a P))\u00a0; create the edge (Q,P)<br/>\u00a0<br/>     (set-eertree-max-suf-t! et (hash-ref Q.edges a))\u00a0; P becomes the new maxSufT<br/>     (set-eertree-S! et (append (eertree-S et) (list a)))\u00a0; Store accumulated input string<br/>     new-node?]))<br/>\u00a0<br/>(define (eertree-get-sub-palindromes et)<br/>  (define (inr nd (node-path (list nd)) (char-path/rev null))<br/>   \u00a0;; Each node represents a palindrome, which can be reconstructed by the path from the root node to<br/>   \u00a0;; each non-root node.<br/>    (let ((deeper\u00a0; Traverse all edges, since they represent other palindromes     <br/>           (for/fold ((result null)) (([\u2192-name nd2] (in-hash (node-edges nd))))<br/>            \u00a0; The lnk-name is the character used for this edge<br/>             (append result (inr nd2 (append node-path (list nd2)) (cons \u2192-name char-path/rev)))))<br/>          (root-node? (or (eq? (eertree-rto et) nd) (eq? (eertree-rte et) nd))))<br/>      (if root-node?\u00a0; Don't add root nodes<br/>          deeper<br/>          (let ((even-string? (eq? (car node-path) (eertree-rte et)))<br/>                (char-path (reverse char-path/rev)))<br/>            (cons (append char-path/rev (if even-string? char-path (cdr char-path))) deeper)))))<br/>  inr)<br/>\u00a0<br/>(define (eertree-get-palindromes et)<br/>  (define sub (eertree-get-sub-palindromes et))<br/>  (append (sub (eertree-rto et))<br/>          (sub (eertree-rte et))))<br/>\u00a0<br/>(module+ main<br/>  (define et (new-eertree))<br/> \u00a0;; eertree works in integer space, so we'll map to/from char space here<br/>  (for ((c \"eertree\")) (eertree-add! et (char-&gt;integer c)))<br/>  (map (compose list-&gt;string (curry map integer-&gt;char)) (eertree-get-palindromes et)))<br/>\u00a0</pre>"}, {"lang": "REXX", "loc": 25, "block": "<pre class=\"rexx highlighted_source\"><span class=\"coMULTI\">/*REXX program creates a list of (unique) sub\u2500palindromes that exist in an input string.*/</span><br/><span class=\"kw1\">parse</span> <span class=\"kw1\">arg</span> x <span class=\"sy0\">.</span>                                    <span class=\"coMULTI\">/*obtain optional input string from CL.*/</span><br/><span class=\"kw1\">if</span> x==<span class=\"st0\">''</span> <span class=\"sy0\">|</span> x==<span class=\"st0\">\",\"</span>  <span class=\"kw3\">then</span> x= <span class=\"st0\">'eertree'</span>             <span class=\"coMULTI\">/*Not specified?  Then use the default.*/</span><br/>L=<span class=\"kw6\">length</span><span class=\"br0\">(</span>x<span class=\"br0\">)</span>                                      <span class=\"coMULTI\">/*the length (in chars) of input string*/</span><br/>@<span class=\"sy0\">.</span>=<span class=\"sy0\">.</span>                                             <span class=\"coMULTI\">/*@ tree indicates uniqueness of pals. */</span><br/>$=                                               <span class=\"coMULTI\">/*list of unsorted &amp; unique palindromes*/</span><br/>    <span class=\"kw1\">do</span>     j=<span class=\"nu0\">1</span>  <span class=\"kw2\">for</span> L                            <span class=\"coMULTI\">/*start at the left side of the string.*/</span><br/>        <span class=\"kw1\">do</span> k=<span class=\"nu0\">1</span>  <span class=\"kw2\">for</span> L                            <span class=\"coMULTI\">/*traverse from left to right of string*/</span><br/>        <span class=\"kw1\">parse</span> <span class=\"kw2\">var</span>  x   =<span class=\"br0\">(</span>j<span class=\"br0\">)</span>  y   +<span class=\"br0\">(</span>k<span class=\"br0\">)</span>            <span class=\"coMULTI\">/*extract a substring from the string. */</span><br/>        <span class=\"kw1\">if</span> <span class=\"kw6\">reverse</span><span class=\"br0\">(</span>y<span class=\"br0\">)</span><span class=\"sy0\">\\</span>==y  <span class=\"kw3\">then</span> <span class=\"kw1\">iterate</span>          <span class=\"coMULTI\">/*Partial string a palindrome?  Skip it*/</span><br/>        <span class=\"kw1\">if</span> @<span class=\"sy0\">.</span>y<span class=\"sy0\">\\</span>==<span class=\"sy0\">.</span>         <span class=\"kw3\">then</span> <span class=\"kw1\">iterate</span>          <span class=\"coMULTI\">/*Sub\u2500palindrome already exist? Skip it*/</span><br/>        @<span class=\"sy0\">.</span>y=y                                    <span class=\"coMULTI\">/*indicate a sub\u2500palindrome was found. */</span><br/>        $=$<span class=\"st0\">' '</span> y                                 <span class=\"coMULTI\">/*append the sub\u2500palindrome to the list*/</span><br/>        <span class=\"kw3\">end</span>   <span class=\"coMULTI\">/*k*/</span>                              <span class=\"coMULTI\">/* [\u2191]  an extra blank is inserted.    */</span><br/>    <span class=\"kw3\">end</span>       <span class=\"coMULTI\">/*j*/</span><br/>\u00a0<br/>pad=<span class=\"kw6\">copies</span><span class=\"br0\">(</span><span class=\"st0\">'\u2500'</span>, <span class=\"nu0\">8</span><span class=\"br0\">)</span>                               <span class=\"coMULTI\">/*a fence to be used as an eyecatcher. */</span><br/><span class=\"kw1\">say</span> pad  <span class=\"st0\">'Using the input string: '</span>  x           <span class=\"coMULTI\">/*echo the  input string  being parsed.*/</span><br/><span class=\"kw1\">say</span><br/>#=<span class=\"kw6\">words</span><span class=\"br0\">(</span>$<span class=\"br0\">)</span>                                       <span class=\"coMULTI\">/*get the number of palindromes found. */</span><br/>subP= <span class=\"st0\">'sub\u2500palindromes'</span>                          <span class=\"coMULTI\">/*a literal to make SAY texts shorter. */</span><br/><span class=\"kw1\">say</span> pad  <span class=\"st0\">'The number of'</span>    subP    <span class=\"st0\">\"found: \"</span>  #<br/><span class=\"kw1\">say</span><br/><span class=\"kw1\">say</span> pad  <span class=\"st0\">'The list of'</span>      subP    <span class=\"st0\">\"found: \"</span>    <span class=\"coMULTI\">/*display the list of the palindromes. */</span><br/><span class=\"kw1\">say</span> <span class=\"kw6\">strip</span><span class=\"br0\">(</span>$<span class=\"br0\">)</span>                                     <span class=\"coMULTI\">/*stick a fork in it,  we're all done. */</span></pre>"}, {"lang": "Ring", "loc": 27, "block": "<pre class=\"text highlighted_source\">\u00a0<br/># Project\u00a0: Eertree<br/>\u00a0<br/>str = \"eertree\"<br/>pal = []<br/>for n=1 to len(str)<br/>    for m=1 to len(str)<br/>        strrev = \"\"<br/>        strpal = substr(str, n, m)<br/>        if strpal\u00a0!= \"\"<br/>           for p=len(strpal) to 1 step -1<br/>               strrev = strrev + strpal[p]<br/>           next<br/>           if strpal = strrev <br/>              add(pal, strpal)<br/>           ok<br/>        ok<br/>    next<br/>next <br/>sortpal = sort(pal)<br/>for n=len(sortpal) to 2 step -1<br/>    if sortpal[n] = sortpal[n-1]<br/>       del(sortpal, n)<br/>    ok<br/>next<br/>see sortpal + nl<br/>\u00a0</pre>"}, {"lang": "zkl", "loc": 76, "block": "<pre class=\"text highlighted_source\">class Node{<br/>   fcn init(length){<br/>      var edges=Dictionary(),\t# edges (or forward links). (char:Node)<br/>          link=Void,\t\t# suffix link (backward links)<br/>\t  sz  =length;\t\t# node length.<br/>    }<br/>}<br/>class Eertree{<br/>   fcn init(string=Void){<br/>      var nodes=List(),<br/>\t\t# two initial root nodes<br/>\t  rto=Node(-1), # odd  length root node, or node -1<br/>\t  rte=Node(0);  # even length root node, or node  0<br/>\u00a0<br/>      rto.link=rte.link=rto;    # Initialize empty tree<br/>      var S      =Data(Void,0), # accumulated input string, T=S[1..i], byte buffer<br/>          maxSufT=rte;          # maximum suffix of tree T<br/>      if(string) string.pump(addChar);  // go ahead and build the tree<br/>   }<br/>   fcn get_max_suffix_pal(startNode,a){<br/>    # We traverse the suffix-palindromes of T in the order of decreasing length.<br/>    # For each palindrome we read its length k and compare T[i-k] against a<br/>    # until we get an equality or arrive at the -1 node.<br/>      u,i,k\u00a0:= startNode, S.len(), u.sz;<br/>      while(u.id!=rto.id and S.charAt(i - k - 1)!=a){<br/>\t _assert_(u.id!=u.link.id);    # Prevent infinte loop<br/>\t u,k = u.link,u.sz;<br/>      }<br/>      return(u);<br/>   }<br/>   fcn addChar(a){<br/>\t# We need to find the maximum suffix-palindrome P of Ta<br/>\t# Start by finding maximum suffix-palindrome Q of T.<br/>\t# To do this, we traverse the suffix-palindromes of T<br/>\t# in the order of decreasing length, starting with maxSuf(T)<br/>      Q:=get_max_suffix_pal(maxSufT,a);<br/>        # We check Q to see whether it has an outgoing edge labeled by a.<br/>      createANewNode:=(not Q.edges.holds(a));<br/>      if(createANewNode){<br/>\t P:=Node(Q.sz + 2); nodes.append(P);<br/>\t if(P.sz==1) P.link=rte;  # if P = a, create the suffix link (P,0)<br/>\t else # It remains to create the suffix link from P if |P|&gt;1. Just<br/>\t      # continue traversing suffix-palindromes of T starting with the suffix <br/>\t      # link of Q.<br/>\t    P.link=get_max_suffix_pal(Q.link,a).edges[a];<br/>\t Q.edges[a]=P;    # create the edge (Q,P)<br/>      }<br/>      maxSufT=Q.edges[a]; # P becomes the new maxSufT<br/>      S.append(a);\t  # Store accumulated input string<br/>      return(createANewNode);  // in case anyone wants to know a is new edge<br/>   }<br/>   fcn get_sub_palindromes{<br/>      result:=List();<br/>      sub_palindromes(rto, T(rto),\"\", result); # Odd length words<br/>      sub_palindromes(rte, T(rte),\"\", result); # Even length words<br/>      result<br/>   }<br/>   fcn [private] sub_palindromes(nd, nodesToHere, charsToHere, result){<br/>        // nodesToHere needs to be read only<br/>\t# Each node represents a palindrome, which can be reconstructed<br/>\t# by the path from the root node to each non-root node.<br/>\u00a0<br/>\t# Traverse all edges, since they represent other palindromes<br/>      nd.edges.pump(Void,'wrap([(lnkName,nd2)]){<br/>\t sub_palindromes(nd2, nodesToHere+nd2, charsToHere+lnkName, result);<br/>      });<br/>\u00a0<br/>      # Reconstruct based on charsToHere characters.<br/>      if(nd.id!=rto.id and nd.id!=rte.id){ # Don't print for root nodes<br/>\t if(nodesToHere[0].id==rte.id) # Even string<br/>\t    assembled:=charsToHere.reverse() + charsToHere;<br/>\t else assembled:=charsToHere.reverse() + charsToHere[1,*]; # Odd string<br/>\t result.append(assembled);<br/>      }<br/>   }<br/>}</pre>"}]}