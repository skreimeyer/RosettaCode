{"task": "Machine_code", "blocks": [{"lang": "AutoHotkey", "loc": 11, "block": "<pre class=\"autohotkey highlighted_source\">MCode<span class=\"br0\">(</span>Var<span class=\"sy0\">,</span> <span class=\"st0\">\"8B44240403442408C3\"</span><span class=\"br0\">)</span><br/><a href=\"http://www.autohotkey.com/docs/commands/MsgBox.htm\"><span class=\"kw3\">MsgBox</span></a><span class=\"sy0\">,</span>\u00a0% <a href=\"http://www.autohotkey.com/docs/commands/DllCall.htm\"><span class=\"kw3\">DllCall</span></a><span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>Var<span class=\"sy0\">,</span> <span class=\"st0\">\"Char\"</span><span class=\"sy0\">,</span><span class=\"nu0\">7</span><span class=\"sy0\">,</span> <span class=\"st0\">\"Char\"</span><span class=\"sy0\">,</span><span class=\"nu0\">12</span><span class=\"br0\">)</span><br/>Var <span class=\"sy0\">:=</span> <span class=\"st0\">\"\"</span><br/><span class=\"kw1\">return</span><br/>\u00a0<br/><span class=\"co1\">; http://www.autohotkey.com/board/topic/19483-machine-code-functions-bit-wizardry/</span><br/>MCode<span class=\"br0\">(</span>ByRef code<span class=\"sy0\">,</span> hex<span class=\"br0\">)</span> <span class=\"br0\">{</span> <span class=\"co1\">; allocate memory and write Machine Code there</span><br/>   <a href=\"http://www.autohotkey.com/docs/commands/VarSetCapacity.htm\"><span class=\"kw3\">VarSetCapacity</span></a><span class=\"br0\">(</span>code<span class=\"sy0\">,</span> <a href=\"http://www.autohotkey.com/docs/Functions.htm#BuiltIn\"><span class=\"kw4\">StrLen</span></a><span class=\"br0\">(</span>hex<span class=\"br0\">)</span> <span class=\"sy0\">//</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><br/>   <a href=\"http://www.autohotkey.com/docs/commands/Loop.htm\"><span class=\"kw3\">Loop</span></a>\u00a0% <a href=\"http://www.autohotkey.com/docs/Functions.htm#BuiltIn\"><span class=\"kw4\">StrLen</span></a><span class=\"br0\">(</span>hex<span class=\"br0\">)</span> <span class=\"sy0\">//</span> <span class=\"nu0\">2</span><br/>      <a href=\"http://www.autohotkey.com/docs/Functions.htm#BuiltIn\"><span class=\"kw4\">NumPut</span></a><span class=\"br0\">(</span><span class=\"st0\">\"0x\"</span> <span class=\"sy0\">.</span> <a href=\"http://www.autohotkey.com/docs/Functions.htm#BuiltIn\"><span class=\"kw4\">SubStr</span></a><span class=\"br0\">(</span>hex<span class=\"sy0\">,</span> <span class=\"nu0\">2</span> <span class=\"sy0\">*</span> <a href=\"http://www.autohotkey.com/docs/Variables.htm#A_Index\"><span class=\"kw2\">A_Index</span></a> <span class=\"sy0\">-</span> <span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"nu0\">2</span><span class=\"br0\">)</span><span class=\"sy0\">,</span> code<span class=\"sy0\">,</span> <a href=\"http://www.autohotkey.com/docs/Variables.htm#A_Index\"><span class=\"kw2\">A_Index</span></a> <span class=\"sy0\">-</span> <span class=\"nu0\">1</span><span class=\"sy0\">,</span> <span class=\"st0\">\"Char\"</span><span class=\"br0\">)</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "BBC BASIC", "loc": 18, "block": "<pre class=\"text highlighted_source\">      REM Claim 9 bytes of memory<br/>      SYS \"GlobalAlloc\",0,9 TO code%<br/>\u00a0<br/>      REM Poke machine code into it<br/>      P%=code%<br/>      [OPT 0<br/>      mov EAX, [ESP+4]<br/>      add EAX, [ESP+8]<br/>      ret<br/>      ]<br/>\u00a0<br/>      REM Run code<br/>      SYS code%,7,12 TO result%<br/>      PRINT result%<br/>\u00a0<br/>      REM Free memory<br/>      SYS \"GlobalFree\",code%<br/>      END</pre>"}, {"lang": "C", "loc": 31, "block": "<pre class=\"c highlighted_source\"><span class=\"co2\">#include &lt;stdio.h&gt;</span><br/><span class=\"co2\">#include &lt;sys/mman.h&gt;</span><br/><span class=\"co2\">#include &lt;string.h&gt;</span><br/>\u00a0<br/><span class=\"kw4\">int</span> test <span class=\"br0\">(</span><span class=\"kw4\">int</span> a<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> b<span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>  <span class=\"coMULTI\">/*<br/>       mov EAX, [ESP+4]<br/>       add EAX, [ESP+8]<br/>       ret<br/>  */</span><br/>  <span class=\"kw4\">char</span> code<span class=\"br0\">[</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"br0\">{</span><span class=\"nu12\">0x8B</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x44</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x24</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x4</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x3</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x44</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x24</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x8</span><span class=\"sy0\">,</span> <span class=\"nu12\">0xC3</span><span class=\"br0\">}</span><span class=\"sy0\">;</span><br/>  <span class=\"kw4\">void</span> <span class=\"sy0\">*</span>buf<span class=\"sy0\">;</span><br/>  <span class=\"kw4\">int</span> c<span class=\"sy0\">;</span><br/>  <span class=\"coMULTI\">/* copy code to executable buffer */</span><br/>  buf <span class=\"sy0\">=</span> mmap <span class=\"br0\">(</span><span class=\"nu0\">0</span><span class=\"sy0\">,</span><span class=\"kw4\">sizeof</span><span class=\"br0\">(</span>code<span class=\"br0\">)</span><span class=\"sy0\">,</span>PROT_READ<span class=\"sy0\">|</span>PROT_WRITE<span class=\"sy0\">|</span>PROT_EXEC<span class=\"sy0\">,</span><br/>             MAP_PRIVATE<span class=\"sy0\">|</span>MAP_ANON<span class=\"sy0\">,-</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span><span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>  <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/memcpy.html\"><span class=\"kw3\">memcpy</span></a> <span class=\"br0\">(</span>buf<span class=\"sy0\">,</span> code<span class=\"sy0\">,</span> <span class=\"kw4\">sizeof</span><span class=\"br0\">(</span>code<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>  <span class=\"coMULTI\">/* run code */</span><br/>  c <span class=\"sy0\">=</span> <span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"kw4\">int</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw4\">int</span><span class=\"sy0\">,</span> <span class=\"kw4\">int</span><span class=\"br0\">)</span><span class=\"br0\">)</span>buf<span class=\"br0\">)</span><span class=\"br0\">(</span>a<span class=\"sy0\">,</span> b<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>  <span class=\"coMULTI\">/* free buffer */</span><br/>  munmap <span class=\"br0\">(</span>buf<span class=\"sy0\">,</span> <span class=\"kw4\">sizeof</span><span class=\"br0\">(</span>code<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>  <span class=\"kw1\">return</span> c<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw4\">int</span> main <span class=\"br0\">(</span><span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>  <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/printf.html\"><span class=\"kw3\">printf</span></a><span class=\"br0\">(</span><span class=\"st0\">\"%d<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span> test<span class=\"br0\">(</span><span class=\"nu0\">7</span><span class=\"sy0\">,</span><span class=\"nu0\">12</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>  <span class=\"kw1\">return</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Common Lisp", "loc": 57, "block": "<pre class=\"lisp highlighted_source\"><span class=\"co1\">;;Note that by using the 'CFFI' library, one can apply this procedure portably in any lisp implementation; </span><br/><span class=\"co1\">;; in this code however I chose to demonstrate only the implementation-dependent programs.</span><br/>\u00a0<br/><span class=\"co1\">;;CCL</span><br/><span class=\"co1\">;; Allocate a memory pointer and poke the opcode into it</span><br/><span class=\"br0\">(</span>defparameter ptr <span class=\"br0\">(</span>ccl<span class=\"sy0\">::</span><span class=\"me0\">malloc</span> <span class=\"nu0\">9</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>loop for i in '<span class=\"br0\">(</span><span class=\"nu0\">139</span> <span class=\"nu0\">68</span> <span class=\"nu0\">36</span> <span class=\"nu0\">4</span> <span class=\"nu0\">3</span> <span class=\"nu0\">68</span> <span class=\"nu0\">36</span> <span class=\"nu0\">8</span> <span class=\"nu0\">195</span><span class=\"br0\">)</span> <br/>   for j from <span class=\"nu0\">0</span> <span class=\"kw1\">do</span><br/>   <span class=\"br0\">(</span><span class=\"kw1\">setf</span> <span class=\"br0\">(</span>ccl<span class=\"sy0\">::%</span>get-unsigned-byte ptr j<span class=\"br0\">)</span> i<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;; Execute with the required arguments and return the result as an unsigned-byte</span><br/><span class=\"br0\">(</span>ccl<span class=\"sy0\">::</span><span class=\"me0\">ff-call</span> ptr <span class=\"sy0\">:</span><span class=\"me1\">UNSIGNED-BYTE</span> <span class=\"nu0\">7</span> <span class=\"sy0\">:</span><span class=\"me1\">UNSIGNED-BYTE</span> <span class=\"nu0\">12</span> <span class=\"sy0\">:</span><span class=\"me1\">UNSIGNED-BYTE</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;; Output = 19</span><br/>\u00a0<br/><span class=\"co1\">;; Free the pointer</span><br/><span class=\"br0\">(</span>ccl<span class=\"sy0\">::</span><span class=\"me0\">free</span> ptr<span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br/><span class=\"co1\">;;SBCL</span><br/><span class=\"br0\">(</span>defparameter mmap <span class=\"br0\">(</span><span class=\"kw1\">list</span> <span class=\"nu0\">139</span> <span class=\"nu0\">68</span> <span class=\"nu0\">36</span> <span class=\"nu0\">4</span> <span class=\"nu0\">3</span> <span class=\"nu0\">68</span> <span class=\"nu0\">36</span> <span class=\"nu0\">8</span> <span class=\"nu0\">195</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>defparameter pointer <span class=\"br0\">(</span>sb-alien<span class=\"sy0\">:</span><span class=\"me1\">make-alien</span> sb-alien<span class=\"sy0\">:</span><span class=\"me1\">unsigned-char</span> <span class=\"br0\">(</span><span class=\"kw1\">length</span> mmap<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>defparameter callp <span class=\"br0\">(</span>loop for byte in mmap<br/>                          for i from <span class=\"nu0\">0</span><br/>\t\t       <span class=\"kw1\">do</span><br/>\t\t       <span class=\"br0\">(</span><span class=\"kw1\">setf</span> <span class=\"br0\">(</span>sb-alien<span class=\"sy0\">:</span><span class=\"me1\">deref</span> pointer i<span class=\"br0\">)</span> byte<span class=\"br0\">)</span><br/>\t\t       finally<br/>\t\t       <span class=\"br0\">(</span><span class=\"kw1\">return</span> <span class=\"br0\">(</span>sb-alien<span class=\"sy0\">:</span><span class=\"me1\">cast</span> pointer <span class=\"br0\">(</span><span class=\"kw1\">function</span> <span class=\"kw1\">integer</span> <span class=\"kw1\">integer</span> <span class=\"kw1\">integer</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>sb-alien<span class=\"sy0\">:</span><span class=\"me1\">alien-</span><span class=\"kw1\">funcall</span> callp <span class=\"nu0\">7</span> <span class=\"nu0\">12</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>loop for i from <span class=\"nu0\">0</span> below <span class=\"nu0\">18</span> collect <span class=\"br0\">(</span>sb-alien<span class=\"sy0\">:</span><span class=\"me1\">deref</span> ptr i<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>sb-alien<span class=\"sy0\">:</span><span class=\"me1\">free-alien</span> pointer<span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"co1\">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;</span><br/><span class=\"co1\">;;CLISP</span><br/><span class=\"br0\">(</span>defparameter mmap <span class=\"br0\">(</span><span class=\"kw1\">list</span> <span class=\"nu0\">139</span> <span class=\"nu0\">68</span> <span class=\"nu0\">36</span> <span class=\"nu0\">4</span> <span class=\"nu0\">3</span> <span class=\"nu0\">68</span> <span class=\"nu0\">36</span> <span class=\"nu0\">8</span> <span class=\"nu0\">195</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>defparameter POINTER <span class=\"br0\">(</span>FFI<span class=\"sy0\">:</span><span class=\"me1\">FOREIGN-ADDRESS</span>  <span class=\"br0\">(</span>FFI<span class=\"sy0\">:</span><span class=\"me1\">FOREIGN-ALLOCATE</span> 'FFI<span class=\"sy0\">:</span><span class=\"me1\">UINT8</span> <span class=\"sy0\">:</span><span class=\"me1\">COUNT</span> <span class=\"nu0\">9</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>loop for i in mmap<br/>   for j from <span class=\"nu0\">0</span> <span class=\"kw1\">do</span><br/>   <span class=\"br0\">(</span><span class=\"kw1\">FUNCALL</span> #'<span class=\"br0\">(</span><span class=\"kw1\">SETF</span> FFI<span class=\"sy0\">:</span><span class=\"me1\">MEMORY-AS</span><span class=\"br0\">)</span> i POINTER 'FFI<span class=\"sy0\">:</span><span class=\"me1\">INT</span> j<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span><span class=\"kw1\">FUNCALL</span><br/> <span class=\"br0\">(</span>FFI<span class=\"sy0\">:</span><span class=\"me1\">FOREIGN-</span><span class=\"kw1\">FUNCTION</span> POINTER<br/>\t\t       <span class=\"br0\">(</span>LOAD-TIME-<span class=\"kw1\">VALUE</span><br/>\t\t\t<span class=\"br0\">(</span>FFI<span class=\"sy0\">:</span><span class=\"me1\">PARSE-C-TYPE</span><br/>\t\t\t '<span class=\"br0\">(</span>FFI<span class=\"sy0\">:</span><span class=\"me1\">C-</span><span class=\"kw1\">FUNCTION</span> <span class=\"br0\">(</span><span class=\"sy0\">:</span><span class=\"me1\">ARGUMENTS</span> 'FFI<span class=\"sy0\">:</span><span class=\"me1\">INT</span> 'FFI<span class=\"sy0\">:</span><span class=\"me1\">INT</span><span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"sy0\">:</span><span class=\"me1\">RETURN-TYPE</span> FFI<span class=\"sy0\">:</span><span class=\"me1\">INT</span><span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"sy0\">:</span><span class=\"me1\">LANGUAGE</span> <span class=\"sy0\">:</span><span class=\"me1\">STDC</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/> <span class=\"nu0\">7</span> <span class=\"nu0\">12</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>FFI<span class=\"sy0\">:</span><span class=\"me1\">FOREIGN-FREE</span> POINTER<span class=\"br0\">)</span><br/>\u00a0</pre>"}, {"lang": "D", "loc": 17, "block": "<pre class=\"d highlighted_source\"><span class=\"kw4\">int</span> test<span class=\"br0\">(</span><span class=\"kw2\">in</span> <span class=\"kw4\">int</span> a<span class=\"sy0\">,</span> <span class=\"kw2\">in</span> <span class=\"kw4\">int</span> b<span class=\"br0\">)</span> <span class=\"kw4\">pure</span> <span class=\"kw4\">nothrow</span> @nogc <span class=\"br0\">{</span><br/>    <span class=\"coMULTI\">/*<br/>    mov EAX, [ESP+4]<br/>    add EAX, [ESP+8]<br/>    ret<br/>    */</span><br/>    <span class=\"kw4\">immutable</span> <span class=\"kw4\">ubyte</span><span class=\"br0\">[</span><span class=\"nu0\">9</span><span class=\"br0\">]</span> code <span class=\"sy0\">=</span> <span class=\"br0\">[</span><span class=\"nu12\">0x8B</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x44</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x24</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x4</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x3</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x44</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x24</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x8</span><span class=\"sy0\">,</span> <span class=\"nu12\">0xC3</span><span class=\"br0\">]</span><span class=\"sy0\">;</span><br/>    <span class=\"kw2\">alias</span> F <span class=\"sy0\">=</span> <span class=\"kw2\">extern</span><span class=\"br0\">(</span>C<span class=\"br0\">)</span> <span class=\"kw4\">int</span> <span class=\"kw2\">function</span><span class=\"br0\">(</span><span class=\"kw4\">int</span><span class=\"sy0\">,</span> <span class=\"kw4\">int</span><span class=\"br0\">)</span> <span class=\"kw4\">pure</span> <span class=\"kw4\">nothrow</span> @nogc<span class=\"sy0\">;</span><br/>    <span class=\"kw4\">immutable</span> f <span class=\"sy0\">=</span> <span class=\"kw2\">cast</span><span class=\"br0\">(</span>F<span class=\"br0\">)</span>code.<span class=\"me1\">ptr</span><span class=\"sy0\">;</span><br/>    <span class=\"kw1\">return</span> f<span class=\"br0\">(</span>a<span class=\"sy0\">,</span> b<span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"co1\">// Run code.</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw4\">void</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <span class=\"kw2\">import</span> std.<span class=\"me1\">stdio</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    test<span class=\"br0\">(</span><span class=\"nu0\">7</span><span class=\"sy0\">,</span> <span class=\"nu0\">12</span><span class=\"br0\">)</span>.<span class=\"me1\">writeln</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Kotlin", "loc": 6, "block": "<pre class=\"c highlighted_source\"><span class=\"co1\">// mcode.def</span><br/><span class=\"sy0\">---</span><br/>\u00a0<br/><span class=\"kw4\">static</span> <span class=\"kw2\">inline</span> <span class=\"kw4\">unsigned</span> <span class=\"kw4\">char</span> runMachineCode<span class=\"br0\">(</span><span class=\"kw4\">void</span> <span class=\"sy0\">*</span>code<span class=\"sy0\">,</span> <span class=\"kw4\">unsigned</span> <span class=\"kw4\">char</span> a<span class=\"sy0\">,</span> <span class=\"kw4\">unsigned</span> <span class=\"kw4\">char</span> b<span class=\"br0\">)</span> <span class=\"br0\">{</span>      <br/>    <span class=\"kw1\">return</span> <span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"kw4\">unsigned</span> <span class=\"kw4\">char</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw4\">unsigned</span> <span class=\"kw4\">char</span><span class=\"sy0\">,</span> <span class=\"kw4\">unsigned</span> <span class=\"kw4\">char</span><span class=\"br0\">)</span><span class=\"br0\">)</span>code<span class=\"br0\">)</span><span class=\"br0\">(</span>a<span class=\"sy0\">,</span> b<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "M2000 Interpreter", "loc": 53, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>Module Checkit {<br/>      Buffer DataMem as Long*10<br/>      Return DataMem, 1:=500    ' second Long<br/>      Print Eval(DataMem, 1)+5100+5=5605<br/>      \\\\ Now we do math executing machine code<br/>      Buffer Code ExecMem as byte*1024<br/>      Address=0<br/>      EmbLong(0xb8, 5100) ' mov eax,5100<br/>      EmbByteByte(0x83, 0xC0, 5) ' add  eax,0x5<br/>      EmbByteLong(0x3,0x5, DataMem(1)) ' add eax, [DataMem(1)] <br/>      EmbLong(0xa3, DataMem(0)) ' mov [DataMem(0)], eax<br/>      \\\\ split rem to execute xor eax eax (eax=0)<br/>      Rem\u00a0: EmbByte(0x31, 0xC0) ' xor eax, eax <br/>      Ret() ' Return<br/>      \\\\  <br/>      Try ok {<br/>            Execute Code ExecMem, 0<br/>      }<br/>      \\\\If  Eax &lt;&gt;0 then we get error, so we read error as Uint()<br/>      \\\\ Error read once then change to zero<br/>      m=Uint(Error)<br/>      \\\\ Hex is Print Hexadecimal for unsigned numbers<br/>      Hex m<br/>      Print m=5605<br/>      Print Error=0, ok=False<br/>\u00a0<br/>      Print Eval(DataMem, 0)=5605,  Eval(DataMem, 0)<br/>      \\\\ sub used as Exit here<br/>      Sub Ret()<br/>            Return ExecMem, Address:=0xC3<br/>            Address++<br/>      End Sub<br/>      Sub EmbByteByte()<br/>            Return ExecMem, Address:=Number, Address+1:=Number, Address+2:=Number<br/>            Address+=3<br/>      End Sub<br/>      Sub EmbByte()<br/>            Return ExecMem, Address:=Number, Address+1:=Number<br/>            Address+=2<br/>      End Sub<br/>      Sub EmbLong()<br/>            Return ExecMem, Address:=Number, Address+1:=Number as Long<br/>            Address+=5<br/>      End Sub<br/>      Sub EmbByteLong()<br/>            Return ExecMem, Address:=Number, Address+1:=Number, Address+2:=Number as Long<br/>            Address+=6<br/>      End Sub<br/>\u00a0<br/>}<br/>CheckIt<br/>\u00a0</pre>"}, {"lang": "Nim", "loc": 29, "block": "<pre class=\"text highlighted_source\">import posix<br/>\u00a0<br/>when defined(macosx) or defined(bsd):<br/>  const MAP_ANONYMOUS = 0x1000<br/>elif defined(solaris): <br/>  const MAP_ANONYMOUS = 0x100<br/>else:<br/>  var<br/>    MAP_ANONYMOUS {.importc: \"MAP_ANONYMOUS\", header: \"&lt;sys/mman.h&gt;\".}: cint<br/>\u00a0<br/>proc test(a, b: cint): cint =<br/>  # mov EAX, [ESP+4]<br/>  # add EAX, [ESP+8]<br/>  var code = [0x8B'u8, 0x44, 0x24, 0x4, 0x3, 0x44, 0x24, 0x8, 0xC3]<br/>\u00a0<br/>  # create executable buffer<br/>  var buf = mmap(nil, sizeof(code), PROT_READ or PROT_WRITE or PROT_EXEC,<br/>    MAP_PRIVATE or MAP_ANONYMOUS, -1, 0)<br/>\u00a0<br/>  # copy code to buffer<br/>  copyMem(addr buf, addr code[0], sizeof(code))<br/>\u00a0<br/>  # run code<br/>  {.emit: \"`result` = ((int (*) (int, int))&amp;`buf`)(`a`,`b`);\".}<br/>\u00a0<br/>  # free buffer<br/>  discard munmap(buf, sizeof(code))<br/>\u00a0<br/>echo test(7, 12)</pre>"}, {"lang": "PARI/GP", "loc": 29, "block": "<pre class=\"c highlighted_source\"><span class=\"co2\">#include &lt;stdio.h&gt;</span><br/><span class=\"co2\">#include &lt;sys/mman.h&gt;</span><br/><span class=\"co2\">#include &lt;string.h&gt;</span><br/><span class=\"co2\">#include &lt;pari/pari.h&gt;</span><br/>\u00a0<br/><span class=\"kw4\">int</span><br/>test<span class=\"br0\">(</span><span class=\"kw4\">int</span> a<span class=\"sy0\">,</span> <span class=\"kw4\">int</span> b<span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>  <span class=\"kw4\">char</span> code<span class=\"br0\">[</span><span class=\"br0\">]</span> <span class=\"sy0\">=</span> <span class=\"br0\">{</span><span class=\"nu12\">0x8B</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x44</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x24</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x4</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x3</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x44</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x24</span><span class=\"sy0\">,</span> <span class=\"nu12\">0x8</span><span class=\"sy0\">,</span> <span class=\"nu12\">0xC3</span><span class=\"br0\">}</span><span class=\"sy0\">;</span><br/>  <span class=\"kw4\">void</span> <span class=\"sy0\">*</span>buf<span class=\"sy0\">;</span><br/>  <span class=\"kw4\">int</span> c<span class=\"sy0\">;</span><br/>  <span class=\"coMULTI\">/* copy code to executable buffer */</span><br/>  buf <span class=\"sy0\">=</span> mmap <span class=\"br0\">(</span><span class=\"nu0\">0</span><span class=\"sy0\">,</span><span class=\"kw4\">sizeof</span><span class=\"br0\">(</span>code<span class=\"br0\">)</span><span class=\"sy0\">,</span>PROT_READ<span class=\"sy0\">|</span>PROT_WRITE<span class=\"sy0\">|</span>PROT_EXEC<span class=\"sy0\">,</span><br/>             MAP_PRIVATE<span class=\"sy0\">|</span>MAP_ANON<span class=\"sy0\">,-</span><span class=\"nu0\">1</span><span class=\"sy0\">,</span><span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>  <a href=\"http://www.opengroup.org/onlinepubs/009695399/functions/memcpy.html\"><span class=\"kw3\">memcpy</span></a> <span class=\"br0\">(</span>buf<span class=\"sy0\">,</span> code<span class=\"sy0\">,</span> <span class=\"kw4\">sizeof</span><span class=\"br0\">(</span>code<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>  <span class=\"coMULTI\">/* run code */</span><br/>  c <span class=\"sy0\">=</span> <span class=\"br0\">(</span><span class=\"br0\">(</span><span class=\"kw4\">int</span> <span class=\"br0\">(</span><span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"kw4\">int</span><span class=\"sy0\">,</span> <span class=\"kw4\">int</span><span class=\"br0\">)</span><span class=\"br0\">)</span>buf<span class=\"br0\">)</span><span class=\"br0\">(</span>a<span class=\"sy0\">,</span> b<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>  <span class=\"coMULTI\">/* free buffer */</span><br/>  munmap <span class=\"br0\">(</span>buf<span class=\"sy0\">,</span> <span class=\"kw4\">sizeof</span><span class=\"br0\">(</span>code<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>  <span class=\"kw1\">return</span> c<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw4\">void</span><br/>init_auto<span class=\"br0\">(</span><span class=\"kw4\">void</span><span class=\"br0\">)</span><br/><span class=\"br0\">{</span><br/>  pari_printf<span class=\"br0\">(</span><span class=\"st0\">\"%d<span class=\"es1\">\\n</span>\"</span><span class=\"sy0\">,</span> test<span class=\"br0\">(</span><span class=\"nu0\">7</span><span class=\"sy0\">,</span><span class=\"nu0\">12</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>  <span class=\"kw1\">return</span> <span class=\"nu0\">0</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Pascal", "loc": 35, "block": "<pre class=\"pascal highlighted_source\"><span class=\"kw1\">Program</span> Example66<span class=\"sy1\">;</span><br/><span class=\"coMULTI\">{Inspired... program to demonstrate the MMap function. Freepascal docs }</span><br/><span class=\"kw1\">Uses</span><br/>  BaseUnix<span class=\"sy1\">,</span>Unix<span class=\"sy1\">;</span><br/>\u00a0<br/><span class=\"kw1\">const</span><br/>  code <span class=\"sy1\">:</span> <span class=\"kw4\">array</span><span class=\"br0\">[</span><span class=\"nu0\">0</span><span class=\"sy1\">..</span><span class=\"nu0\">9</span><span class=\"br0\">]</span> <span class=\"kw1\">of</span> <span class=\"kw4\">byte</span> <span class=\"sy3\">=</span> <span class=\"br0\">(</span><span class=\"re0\">$8B</span><span class=\"sy1\">,</span> <span class=\"re0\">$44</span><span class=\"sy1\">,</span> <span class=\"re0\">$24</span><span class=\"sy1\">,</span> <span class=\"re0\">$4</span><span class=\"sy1\">,</span> <span class=\"re0\">$3</span><span class=\"sy1\">,</span> <span class=\"re0\">$44</span><span class=\"sy1\">,</span> <span class=\"re0\">$24</span><span class=\"sy1\">,</span> <span class=\"re0\">$8</span><span class=\"sy1\">,</span> <span class=\"re0\">$C3</span><span class=\"sy1\">,</span> <span class=\"re0\">$00</span><span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>  a <span class=\"sy1\">:</span><span class=\"kw4\">longInt</span><span class=\"sy3\">=</span> <span class=\"nu0\">12</span><span class=\"sy1\">;</span> <br/>  b <span class=\"sy1\">:</span><span class=\"kw4\">longInt</span><span class=\"sy3\">=</span>  <span class=\"nu0\">7</span><span class=\"sy1\">;</span>  <br/><span class=\"kw1\">type</span><br/>  tDummyFunc <span class=\"sy3\">=</span> <span class=\"kw1\">function</span><span class=\"br0\">(</span>a<span class=\"sy1\">,</span>b<span class=\"sy1\">:</span><span class=\"kw4\">LongInt</span><span class=\"br0\">)</span><span class=\"sy1\">:</span><span class=\"kw4\">LongInt</span><span class=\"sy1\">;</span><span class=\"kw1\">cdecl</span><span class=\"sy1\">;</span><br/><span class=\"kw1\">Var</span><br/>    Len<span class=\"sy1\">,</span>k  <span class=\"sy1\">:</span> cint<span class=\"sy1\">;</span><br/>    P    <span class=\"sy1\">:</span> <span class=\"kw4\">Pointer</span><span class=\"sy1\">;</span><br/>\u00a0<br/><span class=\"kw1\">begin</span><br/>  len <span class=\"sy1\">:</span><span class=\"sy3\">=</span> sizeof<span class=\"br0\">(</span>code<span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>  P<span class=\"sy1\">:</span><span class=\"sy3\">=</span> fpmmap<span class=\"br0\">(</span><span class=\"kw2\">nil</span><span class=\"sy1\">,</span><br/>             len<span class=\"sy3\">+</span><span class=\"nu0\">1</span> <span class=\"sy1\">,</span><br/>             PROT_READ <span class=\"kw1\">OR</span> PROT_WRITE <span class=\"kw1\">OR</span> PROT_EXEC<span class=\"sy1\">,</span><br/>             MAP_ANONYMOUS <span class=\"kw1\">OR</span> MAP_PRIVATE<span class=\"sy1\">,</span><br/>             <span class=\"sy3\">-</span><span class=\"nu0\">1</span><span class=\"sy1\">,</span> <span class=\"co1\">// for MAP_ANONYMOUS</span><br/>             <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>  <span class=\"kw1\">If</span> P <span class=\"sy3\">=</span>  <span class=\"kw4\">Pointer</span><span class=\"br0\">(</span><span class=\"sy3\">-</span><span class=\"nu0\">1</span><span class=\"br0\">)</span> <span class=\"kw1\">then</span><br/>    Halt<span class=\"br0\">(</span><span class=\"nu0\">4</span><span class=\"br0\">)</span><span class=\"sy1\">;</span>                  <br/>\u00a0<br/>  <span class=\"kw1\">for</span> k <span class=\"sy1\">:</span><span class=\"sy3\">=</span> <span class=\"nu0\">0</span> <span class=\"kw1\">to</span> len<span class=\"sy3\">-</span><span class=\"nu0\">1</span> <span class=\"kw1\">do</span><br/>    pChar<span class=\"br0\">(</span>p<span class=\"br0\">)</span><span class=\"br0\">[</span>k<span class=\"br0\">]</span> <span class=\"sy1\">:</span><span class=\"sy3\">=</span> <span class=\"kw4\">char</span><span class=\"br0\">(</span>code<span class=\"br0\">[</span>k<span class=\"br0\">]</span><span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>\u00a0<br/>  k <span class=\"sy1\">:</span><span class=\"sy3\">=</span> tDummyFunc<span class=\"br0\">(</span>P<span class=\"br0\">)</span><span class=\"br0\">(</span>a<span class=\"sy1\">,</span>b<span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>\u00a0<br/>  <span class=\"kw3\">Writeln</span><span class=\"br0\">(</span>a<span class=\"sy1\">,</span><span class=\"st0\">'+'</span><span class=\"sy1\">,</span>b<span class=\"sy1\">,</span><span class=\"st0\">' = '</span><span class=\"sy1\">,</span>k<span class=\"br0\">)</span><span class=\"sy1\">;</span><br/>  <span class=\"kw1\">if</span> fpMUnMap<span class=\"br0\">(</span>P<span class=\"sy1\">,</span>Len<span class=\"br0\">)</span>&lt;&gt;<span class=\"nu0\">0</span> <span class=\"kw1\">Then</span><br/>    Halt<span class=\"br0\">(</span>fpgeterrno<span class=\"br0\">)</span><span class=\"sy1\">;</span><br/><span class=\"kw1\">end</span><span class=\"sy1\">.</span></pre>"}, {"lang": "Phix", "loc": 5, "block": "<pre class=\"text highlighted_source\">atom mem = allocate(9)<br/>poke(mem,{#8B,#44,#24,#04,#03,#44,#24,#08,#C3})<br/>constant mfunc = define_c_func({},mem,{C_INT,C_INT},C_INT)<br/>?c_func(mfunc,{12,7})<br/>free(mem)</pre>"}, {"lang": "PicoLisp", "loc": 33, "block": "<pre class=\"text highlighted_source\">(setq P<br/>   (struct (native \"@\" \"malloc\" 'N 39) 'N<br/>      # Align<br/>      144                  # nop<br/>      144                  # nop<br/>\u00a0<br/>      # Prepare stack<br/>      106 12               # pushq $12<br/>      184 7 0 0 0          # mov $7,\u00a0%eax<br/>      72 193 224 32        # shl $32,\u00a0%rax<br/>      80                   # pushq\u00a0%rax<br/>\u00a0<br/>      # Rosetta task code<br/>      139 68 36 4 3 68 36 8<br/>\u00a0<br/>      # Get result<br/>      76 137 227           # mov\u00a0%r12,\u00a0%rbx<br/>      137 195              # mov\u00a0%eax,\u00a0%ebx<br/>      72 193 227 4         # shl $4,\u00a0%rbx<br/>      128 203 2            # orb $2,\u00a0%bl<br/>\u00a0<br/>      # Clean up stack<br/>      72 131 196 16        # add $16,\u00a0%rsp<br/>\u00a0<br/>      # Return <br/>      195 )                # ret<br/>   foo (&gt;&gt; 4 P) )<br/>\u00a0<br/># Execute<br/>(println (foo))<br/>\u00a0<br/># Free memory<br/>(native \"@\" \"free\" NIL P)</pre>"}, {"lang": "Python", "loc": 38, "block": "<pre class=\"python highlighted_source\"><span class=\"kw1\">import</span> ctypes<br/><span class=\"kw1\">import</span> <span class=\"kw3\">os</span><br/><span class=\"kw1\">from</span> ctypes <span class=\"kw1\">import</span> c_ubyte<span class=\"sy0\">,</span> c_int<br/>\u00a0<br/><span class=\"kw3\">code</span> <span class=\"sy0\">=</span> <span class=\"kw3\">bytes</span><span class=\"br0\">(</span><span class=\"br0\">[</span><span class=\"nu0\">0x8b</span><span class=\"sy0\">,</span> <span class=\"nu0\">0x44</span><span class=\"sy0\">,</span> <span class=\"nu0\">0x24</span><span class=\"sy0\">,</span> <span class=\"nu0\">0x04</span><span class=\"sy0\">,</span> <span class=\"nu0\">0x03</span><span class=\"sy0\">,</span> <span class=\"nu0\">0x44</span><span class=\"sy0\">,</span> <span class=\"nu0\">0x24</span><span class=\"sy0\">,</span> <span class=\"nu0\">0x08</span><span class=\"sy0\">,</span> <span class=\"nu0\">0xc3</span><span class=\"br0\">]</span><span class=\"br0\">)</span><br/>\u00a0<br/>code_size <span class=\"sy0\">=</span> <span class=\"kw2\">len</span><span class=\"br0\">(</span><span class=\"kw3\">code</span><span class=\"br0\">)</span><br/><span class=\"co1\"># copy code into an executable buffer</span><br/><span class=\"kw1\">if</span> <span class=\"br0\">(</span><span class=\"kw3\">os</span>.<span class=\"me1\">name</span> <span class=\"sy0\">==</span> <span class=\"st0\">'posix'</span><span class=\"br0\">)</span>:<br/>    <span class=\"kw1\">import</span> <span class=\"kw3\">mmap</span><br/>    executable_map <span class=\"sy0\">=</span> <span class=\"kw3\">mmap</span>.<span class=\"kw3\">mmap</span><span class=\"br0\">(</span>-<span class=\"nu0\">1</span><span class=\"sy0\">,</span> code_size<span class=\"sy0\">,</span> <span class=\"kw3\">mmap</span>.<span class=\"me1\">MAP_PRIVATE</span> | <span class=\"kw3\">mmap</span>.<span class=\"me1\">MAP_ANON</span><span class=\"sy0\">,</span> <span class=\"kw3\">mmap</span>.<span class=\"me1\">PROT_READ</span> | <span class=\"kw3\">mmap</span>.<span class=\"me1\">PROT_WRITE</span> | <span class=\"kw3\">mmap</span>.<span class=\"me1\">PROT_EXEC</span><span class=\"br0\">)</span><br/>    <span class=\"co1\"># we must keep a reference to executable_map until the call, to avoid freeing the mapped memory</span><br/>    executable_map.<span class=\"me1\">write</span><span class=\"br0\">(</span><span class=\"kw3\">code</span><span class=\"br0\">)</span><br/>    <span class=\"co1\"># the mmap object won't tell us the actual address of the mapping, but we can fish it out by allocating</span><br/>    <span class=\"co1\"># some ctypes object over its buffer, then asking the address of that</span><br/>    func_address <span class=\"sy0\">=</span> ctypes.<span class=\"me1\">addressof</span><span class=\"br0\">(</span>c_ubyte.<span class=\"me1\">from_buffer</span><span class=\"br0\">(</span>executable_map<span class=\"br0\">)</span><span class=\"br0\">)</span><br/><span class=\"kw1\">elif</span> <span class=\"br0\">(</span><span class=\"kw3\">os</span>.<span class=\"me1\">name</span> <span class=\"sy0\">==</span> <span class=\"st0\">'nt'</span><span class=\"br0\">)</span>:<br/>    <span class=\"co1\"># the mmap module doesn't support protection flags on Windows, so execute VirtualAlloc instead</span><br/>    code_buffer <span class=\"sy0\">=</span> ctypes.<span class=\"me1\">create_string_buffer</span><span class=\"br0\">(</span><span class=\"kw3\">code</span><span class=\"br0\">)</span><br/>    PAGE_EXECUTE_READWRITE <span class=\"sy0\">=</span> <span class=\"nu0\">0x40</span>  <span class=\"co1\"># Windows constants that would usually come from header files</span><br/>    MEM_COMMIT <span class=\"sy0\">=</span> <span class=\"nu0\">0x1000</span><br/>    executable_buffer_address <span class=\"sy0\">=</span> ctypes.<span class=\"me1\">windll</span>.<span class=\"me1\">kernel32</span>.<span class=\"me1\">VirtualAlloc</span><span class=\"br0\">(</span><span class=\"nu0\">0</span><span class=\"sy0\">,</span> code_size<span class=\"sy0\">,</span> MEM_COMMIT<span class=\"sy0\">,</span> PAGE_EXECUTE_READWRITE<span class=\"br0\">)</span><br/>    <span class=\"kw1\">if</span> <span class=\"br0\">(</span>executable_buffer_address <span class=\"sy0\">==</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span>:<br/>        <span class=\"kw1\">print</span><span class=\"br0\">(</span><span class=\"st0\">'Warning: Failed to enable code execution, call will likely cause a protection fault.'</span><span class=\"br0\">)</span><br/>        func_address <span class=\"sy0\">=</span> ctypes.<span class=\"me1\">addressof</span><span class=\"br0\">(</span>code_buffer<span class=\"br0\">)</span><br/>    <span class=\"kw1\">else</span>:<br/>        ctypes.<span class=\"me1\">memmove</span><span class=\"br0\">(</span>executable_buffer_address<span class=\"sy0\">,</span> code_buffer<span class=\"sy0\">,</span> code_size<span class=\"br0\">)</span><br/>        func_address <span class=\"sy0\">=</span> executable_buffer_address<br/><span class=\"kw1\">else</span>:<br/>    <span class=\"co1\"># for other platforms, we just hope DEP isn't enabled</span><br/>    code_buffer <span class=\"sy0\">=</span> ctypes.<span class=\"me1\">create_string_buffer</span><span class=\"br0\">(</span><span class=\"kw3\">code</span><span class=\"br0\">)</span><br/>    func_address <span class=\"sy0\">=</span> ctypes.<span class=\"me1\">addressof</span><span class=\"br0\">(</span>code_buffer<span class=\"br0\">)</span><br/>\u00a0<br/>prototype <span class=\"sy0\">=</span> ctypes.<span class=\"me1\">CFUNCTYPE</span><span class=\"br0\">(</span>c_int<span class=\"sy0\">,</span> c_ubyte<span class=\"sy0\">,</span> c_ubyte<span class=\"br0\">)</span> <span class=\"co1\"># build a function prototype from return type and argument types</span><br/>func <span class=\"sy0\">=</span> prototype<span class=\"br0\">(</span>func_address<span class=\"br0\">)</span>                        <span class=\"co1\"># build an actual function from the prototype by specifying the address</span><br/>res <span class=\"sy0\">=</span> func<span class=\"br0\">(</span><span class=\"nu0\">7</span><span class=\"sy0\">,</span><span class=\"nu0\">12</span><span class=\"br0\">)</span><br/><span class=\"kw1\">print</span><span class=\"br0\">(</span>res<span class=\"br0\">)</span><br/>\u00a0</pre>"}, {"lang": "PureBasic", "loc": 45, "block": "<pre class=\"purebasic highlighted_source\"><span class=\"kw1\">CompilerIf</span> #PB_Compiler_Processor <span class=\"sy0\">&lt;&gt;</span> #PB_Processor_x86<br/>  <span class=\"kw1\">CompilerError</span> <span class=\"st0\">\"Code requires a 32-bit processor.\"</span><br/><span class=\"kw1\">CompilerEndIf</span><br/>\u00a0<br/>\u00a0<br/><span class=\"co1\">; Machine code using the Windows API</span><br/>\u00a0<br/><span class=\"kw1\">Procedure</span> MachineCodeVirtualAlloc<span class=\"br0\">(</span>a,b<span class=\"br0\">)</span><br/><span class=\"sy0\">*</span>vm <span class=\"sy0\">=</span> VirtualAlloc_<span class=\"br0\">(</span>#Null,?ecode<span class=\"sy0\">-</span>?scode,#MEM_COMMIT,#PAGE_EXECUTE_READWRITE<span class=\"br0\">)</span><br/>    <span class=\"kw1\">If</span><span class=\"br0\">(</span><span class=\"sy0\">*</span>vm<span class=\"br0\">)</span><br/>        <span class=\"kw2\">CopyMemory</span><span class=\"br0\">(</span>?scode, <span class=\"sy0\">*</span>vm,\u00a0?ecode<span class=\"sy0\">-</span>?scode<span class=\"br0\">)</span><br/>        eax_result<span class=\"sy0\">=</span><span class=\"kw2\">CallFunctionFast</span><span class=\"br0\">(</span><span class=\"sy0\">*</span>vm,a,b<span class=\"br0\">)</span><br/>        VirtualFree_<span class=\"br0\">(</span><span class=\"sy0\">*</span>vm,<span class=\"nu0\">0</span>,#MEM_RELEASE<span class=\"br0\">)</span><br/>        <span class=\"kw1\">ProcedureReturn</span> eax_result<br/>    <span class=\"kw1\">EndIf</span><br/><span class=\"kw1\">EndProcedure</span><br/>\u00a0<br/>rv<span class=\"sy0\">=</span>MachineCodeVirtualAlloc<span class=\"br0\">(</span> <span class=\"nu0\">7</span>, <span class=\"nu0\">12</span><span class=\"br0\">)</span><br/><span class=\"kw2\">MessageRequester</span><span class=\"br0\">(</span><span class=\"st0\">\"MachineCodeVirtualAlloc\"</span>,<span class=\"kw2\">Str</span><span class=\"br0\">(</span>rv<span class=\"br0\">)</span><span class=\"sy0\">+</span><span class=\"kw2\">Space</span><span class=\"br0\">(</span><span class=\"nu0\">50</span><span class=\"br0\">)</span>,#PB_MessageRequester_Ok<span class=\"br0\">)</span><br/>\u00a0<br/>#HEAP_CREATE_ENABLE_EXECUTE<span class=\"sy0\">=</span>$00040000 <br/>\u00a0<br/><span class=\"kw1\">Procedure</span> MachineCodeHeapCreate<span class=\"br0\">(</span>a,b<span class=\"br0\">)</span><br/>hHeap<span class=\"sy0\">=</span>HeapCreate_<span class=\"br0\">(</span>#HEAP_CREATE_ENABLE_EXECUTE,?ecode<span class=\"sy0\">-</span>?scode,?ecode<span class=\"sy0\">-</span>?scode<span class=\"br0\">)</span><br/>    <span class=\"kw1\">If</span><span class=\"br0\">(</span>hHeap<span class=\"br0\">)</span><br/>        <span class=\"kw2\">CopyMemory</span><span class=\"br0\">(</span>?scode, hHeap,\u00a0?ecode<span class=\"sy0\">-</span>?scode<span class=\"br0\">)</span><br/>        eax_result<span class=\"sy0\">=</span><span class=\"kw2\">CallFunctionFast</span><span class=\"br0\">(</span>hHeap,a,b<span class=\"br0\">)</span><br/>        HeapDestroy_<span class=\"br0\">(</span>hHeap<span class=\"br0\">)</span><br/>        <span class=\"kw1\">ProcedureReturn</span> eax_result<br/>    <span class=\"kw1\">EndIf</span><br/><span class=\"kw1\">EndProcedure</span><br/>\u00a0<br/>rv<span class=\"sy0\">=</span>MachineCodeHeapCreate<span class=\"br0\">(</span><span class=\"nu0\">7</span>,<span class=\"nu0\">12</span><span class=\"br0\">)</span><br/><span class=\"kw2\">MessageRequester</span><span class=\"br0\">(</span><span class=\"st0\">\"MachineCodeHeapCreate\"</span>,<span class=\"kw2\">Str</span><span class=\"br0\">(</span>rv<span class=\"br0\">)</span><span class=\"sy0\">+</span><span class=\"kw2\">Space</span><span class=\"br0\">(</span><span class=\"nu0\">50</span><span class=\"br0\">)</span>,#PB_MessageRequester_Ok<span class=\"br0\">)</span><br/><span class=\"kw1\">End</span><br/>\u00a0<br/><span class=\"co1\">; 8B442404               mov     eax,[esp+4]</span><br/><span class=\"co1\">; 03442408               add     eax,[esp+8]</span><br/><span class=\"co1\">; C20800                 ret     8</span><br/>\u00a0<br/><span class=\"kw1\">DataSection</span><br/>scode:<br/><span class=\"kw1\">Data</span>.a $8B,$44,$24,$04,$03,$44,$24,$08,$C2,$08,$00<br/>ecode:<br/><span class=\"kw1\">EndDataSection</span></pre>"}, {"lang": "Racket", "loc": 23, "block": "<pre class=\"text highlighted_source\">#lang racket/base<br/>\u00a0<br/>(require ffi/unsafe)<br/>\u00a0<br/>; set up access to racket internals<br/>(define scheme-malloc-code<br/>  (get-ffi-obj 'scheme_malloc_code #f (_fun (len\u00a0: _intptr) -&gt; _pointer)))<br/>(define scheme-free-code<br/>  (get-ffi-obj 'scheme_free_code #f (_fun _pointer -&gt; _void)))<br/>\u00a0<br/>(define opcodes '(139 68 36 4 3 68 36 8 195))<br/>\u00a0<br/>(define code (scheme-malloc-code 64))<br/>\u00a0<br/>(for ([byte opcodes]<br/>      [i (in-naturals)])<br/>  (ptr-set! code _ubyte i byte))<br/>\u00a0<br/>(define function (cast code _pointer (_fun _ubyte _ubyte -&gt; _ubyte)))<br/>\u00a0<br/>(function 7 12)<br/>\u00a0<br/>(scheme-free-code code)</pre>"}, {"lang": "Scala", "loc": 30, "block": "<pre class=\"tcl highlighted_source\"><span class=\"kw2\">package</span> require critcl<br/>\u00a0<br/>critcl::<span class=\"me1\">ccode</span> <span class=\"br0\">{</span><br/>    <span class=\"co1\">#include &lt;sys/mman.h&gt;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"co1\"># Define a command using C. The C is embedded in Tcl, and will be</span><br/><span class=\"co1\"># built into a shared library at runtime. Note that Tcl does not</span><br/><span class=\"co1\"># provide a native way of doing this sort of thing; this thunk is</span><br/><span class=\"co1\"># mandatory.</span><br/>critcl::<span class=\"me1\">cproc</span> runMachineCode <span class=\"br0\">{</span>Tcl_Obj<span class=\"sy0\">*</span> codeObj int a int b<span class=\"br0\">}</span> int <span class=\"br0\">{</span><br/>    int size, result<span class=\"sy0\">;</span><br/>    unsigned char <span class=\"sy0\">*</span>code = Tcl_GetByteArrayFromObj<span class=\"br0\">(</span>codeObj, <span class=\"sy0\">&amp;</span>size<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    void <span class=\"sy0\">*</span>buf<span class=\"sy0\">;</span><br/>\u00a0<br/>    /<span class=\"sy0\">*</span> copy code to executable buffer <span class=\"sy0\">*</span>/<br/>    buf = mmap<span class=\"br0\">(</span><span class=\"nu0\">0</span>, <span class=\"br0\">(</span>size_t<span class=\"br0\">)</span> size, PROT_READ|PROT_WRITE|PROT_EXEC,<br/>            MAP_PRIVATE|MAP_ANON, -<span class=\"nu0\">1</span>, <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <br/>    memcpy<span class=\"br0\">(</span>buf, code, <span class=\"br0\">(</span>size_t<span class=\"br0\">)</span> size<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    /<span class=\"sy0\">*</span> run code <span class=\"sy0\">*</span>/<br/>    result = <span class=\"br0\">(</span><span class=\"br0\">(</span>int <span class=\"br0\">(</span><span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>int, int<span class=\"br0\">)</span><span class=\"br0\">)</span> buf<span class=\"br0\">)</span><span class=\"br0\">(</span>a, b<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    /<span class=\"sy0\">*</span> dispose buffer <span class=\"sy0\">*</span>/<br/>    munmap<span class=\"br0\">(</span>buf, <span class=\"br0\">(</span>size_t<span class=\"br0\">)</span> size<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"kw1\">return</span> result<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"co1\"># But now we have our thunk, we can execute arbitrary binary blobs</span><br/><span class=\"kw1\">set</span> code <span class=\"br0\">[</span><span class=\"kw2\">binary</span> <span class=\"kw2\">format</span> c<span class=\"sy0\">*</span> <span class=\"br0\">{</span>0x8B 0x44 0x24 0x4 0x3 0x44 0x24 0x8 0xC3<span class=\"br0\">}</span><span class=\"br0\">]</span><br/><span class=\"kw2\">puts</span> <span class=\"br0\">[</span>runMachineCode <span class=\"re0\">$code</span> <span class=\"nu0\">7</span> <span class=\"nu0\">12</span><span class=\"br0\">]</span></pre>"}, {"lang": "Tcl", "loc": 30, "block": "<pre class=\"tcl highlighted_source\"><span class=\"kw2\">package</span> require critcl<br/>\u00a0<br/>critcl::<span class=\"me1\">ccode</span> <span class=\"br0\">{</span><br/>    <span class=\"co1\">#include &lt;sys/mman.h&gt;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"co1\"># Define a command using C. The C is embedded in Tcl, and will be</span><br/><span class=\"co1\"># built into a shared library at runtime. Note that Tcl does not</span><br/><span class=\"co1\"># provide a native way of doing this sort of thing; this thunk is</span><br/><span class=\"co1\"># mandatory.</span><br/>critcl::<span class=\"me1\">cproc</span> runMachineCode <span class=\"br0\">{</span>Tcl_Obj<span class=\"sy0\">*</span> codeObj int a int b<span class=\"br0\">}</span> int <span class=\"br0\">{</span><br/>    int size, result<span class=\"sy0\">;</span><br/>    unsigned char <span class=\"sy0\">*</span>code = Tcl_GetByteArrayFromObj<span class=\"br0\">(</span>codeObj, <span class=\"sy0\">&amp;</span>size<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    void <span class=\"sy0\">*</span>buf<span class=\"sy0\">;</span><br/>\u00a0<br/>    /<span class=\"sy0\">*</span> copy code to executable buffer <span class=\"sy0\">*</span>/<br/>    buf = mmap<span class=\"br0\">(</span><span class=\"nu0\">0</span>, <span class=\"br0\">(</span>size_t<span class=\"br0\">)</span> size, PROT_READ|PROT_WRITE|PROT_EXEC,<br/>            MAP_PRIVATE|MAP_ANON, -<span class=\"nu0\">1</span>, <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <br/>    memcpy<span class=\"br0\">(</span>buf, code, <span class=\"br0\">(</span>size_t<span class=\"br0\">)</span> size<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    /<span class=\"sy0\">*</span> run code <span class=\"sy0\">*</span>/<br/>    result = <span class=\"br0\">(</span><span class=\"br0\">(</span>int <span class=\"br0\">(</span><span class=\"sy0\">*</span><span class=\"br0\">)</span> <span class=\"br0\">(</span>int, int<span class=\"br0\">)</span><span class=\"br0\">)</span> buf<span class=\"br0\">)</span><span class=\"br0\">(</span>a, b<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>    /<span class=\"sy0\">*</span> dispose buffer <span class=\"sy0\">*</span>/<br/>    munmap<span class=\"br0\">(</span>buf, <span class=\"br0\">(</span>size_t<span class=\"br0\">)</span> size<span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/>    <span class=\"kw1\">return</span> result<span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"co1\"># But now we have our thunk, we can execute arbitrary binary blobs</span><br/><span class=\"kw1\">set</span> code <span class=\"br0\">[</span><span class=\"kw2\">binary</span> <span class=\"kw2\">format</span> c<span class=\"sy0\">*</span> <span class=\"br0\">{</span>0x8B 0x44 0x24 0x4 0x3 0x44 0x24 0x8 0xC3<span class=\"br0\">}</span><span class=\"br0\">]</span><br/><span class=\"kw2\">puts</span> <span class=\"br0\">[</span>runMachineCode <span class=\"re0\">$code</span> <span class=\"nu0\">7</span> <span class=\"nu0\">12</span><span class=\"br0\">]</span></pre>"}]}