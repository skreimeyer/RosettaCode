{"task": "Constrained_genericity", "blocks": [{"lang": "Ada", "loc": 24, "block": "<pre class=\"ada highlighted_source\"><span class=\"kw3\">with</span> Ada.<span class=\"me1\">Containers</span>.<span class=\"me1\">Indefinite_Vectors</span>;<br/>\u00a0<br/><span class=\"kw3\">package</span> Nutrition <span class=\"kw1\">is</span><br/>   <span class=\"kw3\">type</span> Food <span class=\"kw1\">is</span> <span class=\"kw3\">interface</span>;<br/>   <span class=\"kw3\">procedure</span> Eat <span class=\"br0\">(</span>Object\u00a0: <span class=\"kw3\">in</span> <span class=\"kw3\">out</span> Food<span class=\"br0\">)</span> <span class=\"kw1\">is</span> <span class=\"kw3\">abstract</span>;<br/>\u00a0<br/><span class=\"kw1\">end</span> Nutrition;<br/>\u00a0<br/><span class=\"kw3\">with</span> Ada.<span class=\"me1\">Containers</span>;<br/><span class=\"kw3\">with</span> Nutrition;<br/>\u00a0<br/><span class=\"kw3\">generic</span><br/>   <span class=\"kw3\">type</span> New_Food <span class=\"kw1\">is</span> <span class=\"kw3\">new</span> Nutrition.<span class=\"me1\">Food</span>;<br/><span class=\"kw3\">package</span> Food_Boxes <span class=\"kw1\">is</span><br/>\u00a0<br/>  <span class=\"kw3\">package</span> Food_Vectors <span class=\"kw1\">is</span><br/>      <span class=\"kw3\">new</span> Ada.<span class=\"me1\">Containers</span>.<span class=\"me1\">Indefinite_Vectors</span><br/>          <span class=\"br0\">(</span>  Index_Type   =&gt; Positive,<br/>             Element_Type =&gt; New_Food<br/>          <span class=\"br0\">)</span>;<br/>\u00a0<br/>   <span class=\"kw3\">subtype</span> Food_Box <span class=\"kw1\">is</span> Food_Vectors.<span class=\"me1\">Vector</span>;<br/>\u00a0<br/><span class=\"kw1\">end</span> Food_Boxes;</pre>"}, {"lang": "C++", "loc": 34, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>template&lt;typename T&gt; //Detection helper struct<br/>struct can_eat       //Detects presence of non-const member function void eat()<br/>{<br/>  private:<br/>    template&lt;typename U, void (U::*)()&gt; struct SFINAE {};<br/>    template&lt;typename U&gt; static char Test(SFINAE&lt;U, &amp;U::eat&gt;*);<br/>    template&lt;typename U&gt; static int Test(...);<br/>  public:<br/>    static constexpr bool value = sizeof(Test&lt;T&gt;(0)) == sizeof(char);<br/>};<br/>\u00a0<br/>struct potato<br/>{ void eat(); };<br/>\u00a0<br/>struct brick<br/>{};<br/>\u00a0<br/>template&lt;typename T&gt;<br/>class FoodBox<br/>{<br/>    //Using static assertion to prohibit non-edible types<br/>    static_assert(can_eat&lt;T&gt;::value, \"Only edible items are allowed in foodbox\");<br/>\u00a0<br/>    //Rest of class definition<br/>};<br/>\u00a0<br/>int main()<br/>{<br/>    FoodBox&lt;potato&gt; lunch;<br/>\u00a0<br/>    //Following leads to compile-time error<br/>    //FoodBox&lt;brick&gt; practical_joke;<br/>}</pre>"}, {"lang": "C#", "loc": 4, "block": "<pre class=\"csharp highlighted_source\"><span class=\"kw4\">interface</span> IEatable<br/><span class=\"br0\">{</span><br/>    <span class=\"kw4\">void</span> Eat<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Common Lisp", "loc": 34, "block": "<pre class=\"lisp highlighted_source\"><span class=\"br0\">(</span>defclass food <span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>defclass inedible-food <span class=\"br0\">(</span>food<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>defclass edible-food <span class=\"br0\">(</span>food<span class=\"br0\">)</span> <span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>defgeneric eat <span class=\"br0\">(</span>foodstuff<span class=\"br0\">)</span><br/>  <span class=\"br0\">(</span><span class=\"sy0\">:</span><span class=\"me1\">documentation</span> <span class=\"st0\">\"Eat the foodstuff.\"</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>defmethod eat <span class=\"br0\">(</span><span class=\"br0\">(</span>foodstuff edible-food<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>  <span class=\"st0\">\"A specialized method for eating edible-food.\"</span><br/>  <span class=\"br0\">(</span>format <span class=\"kw1\">nil</span> <span class=\"st0\">\"Eating ~w.\"</span> foodstuff<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span><span class=\"kw1\">defun</span> eatable-p <span class=\"br0\">(</span>thing<span class=\"br0\">)</span><br/>  <span class=\"st0\">\"Returns true if there are eat methods defined for thing.\"</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">not</span> <span class=\"br0\">(</span>endp <span class=\"br0\">(</span>compute-applicable-methods #'eat <span class=\"br0\">(</span><span class=\"kw1\">list</span> thing<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span>deftype eatable <span class=\"br0\">(</span><span class=\"br0\">)</span><br/>  <span class=\"st0\">\"Eatable objects are those satisfying eatable-p.\"</span><br/>  '<span class=\"br0\">(</span>satisfies eatable-p<span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span><span class=\"kw1\">defun</span> make-food-box <span class=\"br0\">(</span>extra-type <span class=\"sy0\">&amp;</span>rest array-args<span class=\"br0\">)</span><br/>  <span class=\"st0\">\"Returns an array whose element-type is (and extra-type food).<br/>array-args should be suitable for MAKE-ARRAY, and any provided<br/>element-type keyword argument is ignored.\"</span><br/>  <span class=\"br0\">(</span>destructuring-bind <span class=\"br0\">(</span>dimensions <span class=\"sy0\">&amp;</span>rest array-args<span class=\"br0\">)</span> array-args<br/>    <span class=\"br0\">(</span><span class=\"kw1\">apply</span> 'make-<span class=\"kw1\">array</span> dimensions<br/>           <span class=\"sy0\">:</span><span class=\"me1\">element-type</span> `<span class=\"br0\">(</span><span class=\"kw1\">and</span> <span class=\"sy0\">,</span>extra-type food<span class=\"br0\">)</span><br/>           array-args<span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"br0\">(</span><span class=\"kw1\">defun</span> make-eatable-food-box <span class=\"br0\">(</span><span class=\"sy0\">&amp;</span>rest array-args<span class=\"br0\">)</span><br/>  <span class=\"st0\">\"Return an array whose elements are declared to be of type (and<br/>eatable food).\"</span><br/>  <span class=\"br0\">(</span><span class=\"kw1\">apply</span> 'make-food-box 'eatable array-args<span class=\"br0\">)</span><span class=\"br0\">)</span></pre>"}, {"lang": "D", "loc": 19, "block": "<pre class=\"d highlighted_source\"><span class=\"kw4\">enum</span> IsEdible<span class=\"br0\">(</span>T<span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"kw2\">is</span><span class=\"br0\">(</span><span class=\"kw2\">typeof</span><span class=\"br0\">(</span>T.<span class=\"me1\">eat</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"kw4\">struct</span> FoodBox<span class=\"br0\">(</span>T<span class=\"br0\">)</span> <span class=\"kw1\">if</span> <span class=\"br0\">(</span>IsEdible<span class=\"sy0\">!</span>T<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    T<span class=\"br0\">[</span><span class=\"br0\">]</span> food<span class=\"sy0\">;</span><br/>    <span class=\"kw2\">alias</span> food <span class=\"kw2\">this</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw4\">struct</span> Carrot <span class=\"br0\">{</span><br/>    <span class=\"kw4\">void</span> eat<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><span class=\"br0\">}</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw4\">static</span> <span class=\"kw4\">struct</span> Car <span class=\"br0\">{</span><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw4\">void</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    FoodBox<span class=\"sy0\">!</span>Carrot carrotsBox<span class=\"sy0\">;</span> <span class=\"co1\">// OK</span><br/>    carrotsBox <span class=\"sy0\">~=</span> Carrot<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span>    <span class=\"co1\">// Adds a carrot</span><br/>\u00a0<br/>    <span class=\"co1\">//FoodBox!Car carsBox;     // Not allowed</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "E", "loc": 14, "block": "<pre class=\"e highlighted_source\"><span class=\"coMULTI\">/** Guard accepting only objects with an 'eat' method */</span><br/><a href=\"http://wiki.erights.org/wiki/def\"><span class=\"kw4\">def</span></a> Eatable <span class=\"br0\">{</span><br/>    <a href=\"http://wiki.erights.org/wiki/to\"><span class=\"kw5\">to</span></a> coerce<span class=\"br0\">(</span>specimen<span class=\"sy0\">,</span> ejector<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        <a href=\"http://wiki.erights.org/wiki/if\"><span class=\"kw1\">if</span></a> <span class=\"br0\">(</span><a href=\"http://wiki.erights.org/wiki/Ref\"><span class=\"kw6\">Ref</span></a>.<span class=\"me1\">isNear</span><span class=\"br0\">(</span>specimen<span class=\"br0\">)</span> <span class=\"sy0\">&amp;&amp;</span> specimen.__respondsTo<span class=\"br0\">(</span><span class=\"st0\">\"eat\"</span><span class=\"sy0\">,</span> <span class=\"nu0\">0</span><span class=\"br0\">)</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>            return specimen<br/>        <span class=\"br0\">}</span> <a href=\"http://wiki.erights.org/wiki/else\"><span class=\"kw2\">else</span></a> <span class=\"br0\">{</span><br/>            <a href=\"http://wiki.erights.org/wiki/throw\"><span class=\"kw6\">throw</span></a>.<span class=\"me1\">eject</span><span class=\"br0\">(</span>ejector<span class=\"sy0\">,</span> <span class=\"st0\">`inedible: $specimen`</span><span class=\"br0\">)</span><br/>        <span class=\"br0\">}</span><br/>    <span class=\"br0\">}</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><a href=\"http://wiki.erights.org/wiki/def\"><span class=\"kw4\">def</span></a> makeFoodBox<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    return <span class=\"br0\">[</span><span class=\"br0\">]</span>.<span class=\"me1\">diverge</span><span class=\"br0\">(</span>Eatable<span class=\"br0\">)</span> <span class=\"co1\"># A guard-constrained list</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Eiffel", "loc": 12, "block": "<pre class=\"eiffel highlighted_source\">\u00a0<br/><span class=\"kw1\">deferred</span> <span class=\"kw1\">class</span><br/>    EATABLE<br/>\u00a0<br/><span class=\"kw1\">feature</span> <span class=\"co1\">-- Basic operations</span><br/>\u00a0<br/>    eat<br/>            <span class=\"co1\">-- Eat this eatable substance</span><br/>        <span class=\"kw1\">deferred</span><br/>        <span class=\"kw2\">end</span><br/><span class=\"kw2\">end</span><br/>\u00a0</pre>"}, {"lang": "F#", "loc": 11, "block": "<pre class=\"fsharp highlighted_source\"><span class=\"kw1\">type</span> ^a FoodBox                         <span class=\"co1\">// a generic type FoodBox</span><br/>  <span class=\"kw1\">when</span> ^a: <span class=\"br0\">(</span><span class=\"kw1\">member</span> eat: <span class=\"kw4\">unit</span> <span class=\"sy0\">-&gt;</span> <span class=\"kw4\">string</span><span class=\"br0\">)</span> <span class=\"co1\">// with an explicit member constraint on ^a,</span><br/>  <span class=\"br0\">(</span>items:^a list<span class=\"br0\">)</span> <span class=\"sy0\">=</span>                     <span class=\"co1\">// a one-argument constructor</span><br/>  <span class=\"kw1\">member</span> <span class=\"kw1\">inline</span> x.<span class=\"me1\">foodItems</span> <span class=\"sy0\">=</span> items     <span class=\"co1\">// and a public read-only property</span><br/>\u00a0<br/><span class=\"co1\">// a class type that fullfills the member constraint</span><br/><span class=\"kw1\">type</span> Banana<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span><br/>  <span class=\"kw1\">member</span> x.<span class=\"me1\">eat</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> <span class=\"st0\">\"I'm eating a banana.\"</span><br/>\u00a0<br/><span class=\"co1\">// an instance of a Banana FoodBox</span><br/><span class=\"kw1\">let</span> someBananas <span class=\"sy0\">=</span> FoodBox <span class=\"br0\">[</span>Banana<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> Banana<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">]</span></pre>"}, {"lang": "Forth", "loc": 40, "block": "<pre class=\"text highlighted_source\">include FMS-SI.f<br/>include FMS-SILib.f<br/>:class Eatable<br/>  \u00a0:m eat .\" successful eat \"\u00a0;m<br/>;class<br/>\u00a0<br/>\\ FoodBox is defined without inspecting for the eat message<br/>:class FoodBox<br/>  object-list eatable-types<br/> \u00a0:m init: eatable-types init:\u00a0;m<br/> \u00a0:m add: ( obj -- )<br/>     dup is-kindOf Eatable <br/>     if   eatable-types add:<br/>     else drop .\" not an eatable type \" <br/>     then\u00a0;m<br/> \u00a0:m test <br/>     begin eatable-types each:<br/>     while eat<br/>     repeat\u00a0;m<br/>;class<br/>\u00a0<br/>FoodBox aFoodBox <br/>Eatable aEatable <br/>aEatable aFoodBox add:  \\ add the e1 object to the object-list<br/>aFoodBox test  \\ =&gt; successful eat<br/>\u00a0<br/>:class brick<br/>\u00a0:m eat cr .\" successful eat \"\u00a0;m <br/>;class<br/>\u00a0<br/>brick abrick  \\ create an object that is not eatable <br/>abrick aFoodBox add: \\ =&gt; not an eatable type <br/>\u00a0<br/>:class apple &lt;super Eatable<br/>;class <br/>\u00a0<br/>apple anapple  <br/>anapple aFoodBox add: <br/>aFoodBox test  \\ =&gt; successful eat successful eat<br/>\u00a0</pre>"}, {"lang": "Fortran", "loc": 45, "block": "<pre class=\"fortran highlighted_source\">\u00a0<br/><span class=\"kw1\">module</span> cg<br/>    <span class=\"kw3\">implicit</span> <span class=\"kw3\">none</span><br/>\u00a0<br/>    <span class=\"kw3\">type</span>, abstract <span class=\"sy0\">::</span> <span class=\"me2\">eatable</span><br/>    <span class=\"kw1\">end</span> <span class=\"kw3\">type</span> eatable<br/>\u00a0<br/>    <span class=\"kw3\">type</span>, extends<span class=\"br0\">(</span>eatable<span class=\"br0\">)</span> <span class=\"sy0\">::</span> <span class=\"me2\">carrot_t</span><br/>    <span class=\"kw1\">end</span> <span class=\"kw3\">type</span> carrot_t<br/>\u00a0<br/>    <span class=\"kw3\">type</span> <span class=\"sy0\">::</span> <span class=\"me2\">brick_t</span>; <span class=\"kw1\">end</span> <span class=\"kw3\">type</span> brick_t<br/>\u00a0<br/>    <span class=\"kw3\">type</span> <span class=\"sy0\">::</span> <span class=\"me2\">foodbox</span><br/>\tclass<span class=\"br0\">(</span>eatable<span class=\"br0\">)</span>, <span class=\"kw3\">allocatable</span> <span class=\"sy0\">::</span> <span class=\"me2\">food</span><br/>    <span class=\"kw1\">contains</span><br/>        <span class=\"kw1\">procedure</span>, <span class=\"kw3\">public</span> <span class=\"sy0\">::</span> <span class=\"me2\">add_item</span> <span class=\"sy0\">=</span>&gt; add_item_fb<br/>    <span class=\"kw1\">end</span> <span class=\"kw3\">type</span> foodbox<br/>\u00a0<br/><span class=\"co1\">contains</span><br/>\u00a0<br/>    <span class=\"kw1\">subroutine</span> add_item_fb<span class=\"br0\">(</span>this, f<span class=\"br0\">)</span><br/>        class<span class=\"br0\">(</span>foodbox<span class=\"br0\">)</span>, <span class=\"kw3\">intent</span><span class=\"br0\">(</span><span class=\"kw3\">inout</span><span class=\"br0\">)</span> <span class=\"sy0\">::</span> <span class=\"me2\">this</span><br/>        class<span class=\"br0\">(</span>eatable<span class=\"br0\">)</span>, <span class=\"kw3\">intent</span><span class=\"br0\">(</span><span class=\"kw3\">in</span><span class=\"br0\">)</span>    <span class=\"sy0\">::</span> <span class=\"me2\">f</span><br/>        <span class=\"kw1\">allocate</span><span class=\"br0\">(</span>this<span class=\"sy0\">%</span>food, source<span class=\"sy0\">=</span>f<span class=\"br0\">)</span><br/>    <span class=\"kw1\">end</span> <span class=\"kw1\">subroutine</span> add_item_fb<br/><span class=\"kw1\">end</span> <span class=\"kw1\">module</span> cg<br/>\u00a0<br/>\u00a0<br/><span class=\"kw1\">program</span> con_gen<br/>    <span class=\"kw3\">use</span> cg<br/>    <span class=\"kw3\">implicit</span> <span class=\"kw3\">none</span><br/>\u00a0<br/>    <span class=\"kw3\">type</span><span class=\"br0\">(</span>carrot_t<span class=\"br0\">)</span> <span class=\"sy0\">::</span> <span class=\"me2\">carrot</span><br/>    <span class=\"kw3\">type</span><span class=\"br0\">(</span>brick_t<span class=\"br0\">)</span>  <span class=\"sy0\">::</span> <span class=\"me2\">brick</span><br/>    <span class=\"kw3\">type</span><span class=\"br0\">(</span>foodbox<span class=\"br0\">)</span>  <span class=\"sy0\">::</span> <span class=\"me2\">fbox</span><br/>\u00a0<br/>    <span class=\"co1\">! Put a carrot into the foodbox</span><br/>    <span class=\"kw1\">call</span> fbox<span class=\"sy0\">%</span>add_item<span class=\"br0\">(</span>carrot<span class=\"br0\">)</span><br/>\u00a0<br/>    <span class=\"co1\">! Try to put a brick in - results in a compiler error</span><br/>    <span class=\"kw1\">call</span> fbox<span class=\"sy0\">%</span>add_item<span class=\"br0\">(</span>brick<span class=\"br0\">)</span><br/>\u00a0<br/><span class=\"kw1\">end</span> <span class=\"kw1\">program</span> con_gen<br/>\u00a0<br/>\u00a0</pre>"}, {"lang": "Go", "loc": 3, "block": "<pre class=\"go highlighted_source\"><span class=\"kw1\">type</span> eatable <span class=\"kw4\">interface</span> <span class=\"sy1\">{</span><br/>    eat<span class=\"sy1\">()</span><br/><span class=\"sy1\">}</span></pre>"}, {"lang": "Haskell", "loc": 2, "block": "<pre class=\"haskell highlighted_source\"><span class=\"kw1\">class</span> Eatable a <span class=\"kw1\">where</span><br/>  eat <span class=\"sy0\">::</span> a <span class=\"sy0\">-&gt;</span> <a href=\"http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html#t:String\"><span class=\"kw4\">String</span></a></pre>"}, {"lang": "Icon and Unicon", "loc": 23, "block": "<pre class=\"unicon highlighted_source\"><span class=\"kw1\">import</span> Utils        <span class=\"co1\"># From the UniLib package to get the Class class.</span><br/>\u00a0<br/><span class=\"kw1\">class</span> Eatable<span class=\"sy0\">:</span>Class<span class=\"br0\">(</span><span class=\"br0\">)</span><br/><span class=\"kw1\">end</span><br/>\u00a0<br/><span class=\"kw1\">class</span> Fish<span class=\"sy0\">:</span>Eatable<span class=\"br0\">(</span><span class=\"kw4\">name</span><span class=\"br0\">)</span><br/>    <span class=\"kw1\">method</span> eat<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"kw4\">write</span><span class=\"br0\">(</span><span class=\"st0\">\"Eating \"</span><span class=\"sy0\">+</span><span class=\"kw4\">name</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"kw1\">end</span><br/><span class=\"kw1\">end</span><br/>\u00a0<br/><span class=\"kw1\">class</span> Rock<span class=\"sy0\">:</span>Class<span class=\"br0\">(</span><span class=\"kw4\">name</span><span class=\"br0\">)</span><br/>    <span class=\"kw1\">method</span> eat<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"kw4\">write</span><span class=\"br0\">(</span><span class=\"st0\">\"Eating \"</span><span class=\"sy0\">+</span><span class=\"kw4\">name</span><span class=\"br0\">)</span><span class=\"sy0\">;</span> <span class=\"kw1\">end</span><br/><span class=\"kw1\">end</span><br/>\u00a0<br/><span class=\"kw1\">class</span> FoodBox<span class=\"br0\">(</span>A<span class=\"br0\">)</span><br/><span class=\"kw1\">initially</span><br/>    <span class=\"kw1\">every</span> item <span class=\"sy0\">:=</span> <span class=\"sy0\">!</span>A <span class=\"kw1\">do</span> <span class=\"kw1\">if</span> <span class=\"st0\">\"Eatable\"</span> <span class=\"sy0\">==</span> item<span class=\"sy0\">.</span><span class=\"me1\">Type</span><span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"kw1\">then</span> <span class=\"kw1\">next</span> <span class=\"kw1\">else</span> bad <span class=\"sy0\">:=</span> <span class=\"st0\">\"yes\"</span> <br/>    <span class=\"kw1\">return</span> <span class=\"sy0\">/</span>bad<br/><span class=\"kw1\">end</span><br/>\u00a0<br/><span class=\"kw1\">procedure</span> main<span class=\"br0\">(</span><span class=\"br0\">)</span><br/>    <span class=\"kw1\">if</span> FoodBox<span class=\"br0\">(</span><span class=\"br0\">[</span>Fish<span class=\"br0\">(</span><span class=\"st0\">\"salmon\"</span><span class=\"br0\">)</span><span class=\"br0\">]</span><span class=\"br0\">)</span> <span class=\"kw1\">then</span> <span class=\"kw4\">write</span><span class=\"br0\">(</span><span class=\"st0\">\"Edible\"</span><span class=\"br0\">)</span> <span class=\"kw1\">else</span> <span class=\"kw4\">write</span><span class=\"br0\">(</span><span class=\"st0\">\"Inedible\"</span><span class=\"br0\">)</span><br/>    <span class=\"kw1\">if</span> FoodBox<span class=\"br0\">(</span><span class=\"br0\">[</span>Rock<span class=\"br0\">(</span><span class=\"st0\">\"granite\"</span><span class=\"br0\">)</span><span class=\"br0\">]</span><span class=\"br0\">)</span> <span class=\"kw1\">then</span> <span class=\"kw4\">write</span><span class=\"br0\">(</span><span class=\"st0\">\"Edible\"</span><span class=\"br0\">)</span> <span class=\"kw1\">else</span> <span class=\"kw4\">write</span><span class=\"br0\">(</span><span class=\"st0\">\"Inedible\"</span><span class=\"br0\">)</span><br/><span class=\"kw1\">end</span></pre>"}, {"lang": "J", "loc": 14, "block": "<pre class=\"j highlighted_source\">coclass<span class=\"st_h\">'Connoisseur'</span><br/>isEdible=:<span class=\"nu0\">3</span>\u00a0:<span class=\"nu0\">0</span><br/>  <span class=\"nu0\">0</span>&lt;nc&lt;<span class=\"st_h\">'eat__y'</span><br/><span class=\"sy0\">)</span><br/>\u00a0<br/>coclass<span class=\"st_h\">'FoodBox'</span><br/>create=:<span class=\"nu0\">3</span>\u00a0:<span class=\"nu0\">0</span><br/>  collection=: <span class=\"nu0\">0</span>#<span class=\"kw2\">y</span><br/><span class=\"sy0\">)</span><br/>add=:<span class=\"nu0\">3</span>\u00a0:<span class=\"nu0\">0</span>\"<span class=\"nu0\">0</span><br/>  <span class=\"st_h\">'inedible'</span> assert isEdible_Connoisseur_ <span class=\"kw2\">y</span><br/>  collection=: collection, <span class=\"kw2\">y</span><br/>  EMPTY<br/><span class=\"sy0\">)</span></pre>"}, {"lang": "Java", "loc": 4, "block": "<pre class=\"java5 highlighted_source\"><span class=\"kw2\">interface</span> Eatable<br/><span class=\"br0\">{</span><br/>    <span class=\"kw3\">void</span> eat<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Julia", "loc": 19, "block": "<pre class=\"text highlighted_source\">abstract type Edible end<br/>eat(::Edible) = \"Yum!\"<br/>\u00a0<br/>mutable struct FoodBox{T&lt;:Edible}<br/>    food::Vector{T}<br/>end<br/>\u00a0<br/>struct Carrot &lt;: Edible<br/>    variety::AbstractString<br/>end<br/>\u00a0<br/>struct Brick<br/>    volume::Float64<br/>end<br/>\u00a0<br/>c = Carrot(\"Baby\")<br/>b = Brick(125.0)<br/>eat(c)<br/>eat(b)</pre>"}, {"lang": "Kotlin", "loc": 51, "block": "<pre class=\"scala highlighted_source\"><span class=\"co1\">// version 1.0.6</span><br/>\u00a0<br/>interface Eatable <span class=\"br0\">{</span><br/>    fun eat<span class=\"br0\">(</span><span class=\"br0\">)</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">class</span></a> Cheese<span class=\"br0\">(</span><a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> name<span class=\"sy0\">:</span> String<span class=\"br0\">)</span> <span class=\"sy0\">:</span> Eatable <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">override</span></a> fun eat<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>       println<span class=\"br0\">(</span><span class=\"st0\">\"Eating $name\"</span><span class=\"br0\">)</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">override</span></a> fun toString<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> name<br/><span class=\"br0\">}</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">class</span></a> Meat<span class=\"br0\">(</span><a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> name<span class=\"sy0\">:</span> String<span class=\"br0\">)</span> <span class=\"sy0\">:</span> Eatable <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">override</span></a> fun eat<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>       println<span class=\"br0\">(</span><span class=\"st0\">\"Eating $name\"</span><span class=\"br0\">)</span><br/>    <span class=\"br0\">}</span><br/>\u00a0<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">override</span></a> fun toString<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> name<br/><span class=\"br0\">}</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">class</span></a> FoodBox<span class=\"sy0\">&lt;</span>T<span class=\"sy0\">:</span> Eatable<span class=\"sy0\">&gt;</span> <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">private</span></a> <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> foodList <span class=\"sy0\">=</span>  mutableListOf<span class=\"sy0\">&lt;</span>T<span class=\"sy0\">&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>\u00a0<br/>    fun add<span class=\"br0\">(</span>food<span class=\"sy0\">:</span> T<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>        foodList.<span class=\"me1\">add</span><span class=\"br0\">(</span>food<span class=\"br0\">)</span><br/>    <span class=\"br0\">}</span> <br/>\u00a0<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">override</span></a> fun toString<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"sy0\">=</span> foodList.<span class=\"me1\">toString</span><span class=\"br0\">(</span><span class=\"br0\">)</span>   <br/><span class=\"br0\">}</span><br/>\u00a0<br/>fun main<span class=\"br0\">(</span>args<span class=\"sy0\">:</span> Array<span class=\"sy0\">&lt;</span>String<span class=\"sy0\">&gt;</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> cheddar <span class=\"sy0\">=</span>  Cheese<span class=\"br0\">(</span><span class=\"st0\">\"cheddar\"</span><span class=\"br0\">)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> feta <span class=\"sy0\">=</span> Cheese<span class=\"br0\">(</span><span class=\"st0\">\"feta\"</span><span class=\"br0\">)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> cheeseBox <span class=\"sy0\">=</span> FoodBox<span class=\"sy0\">&lt;</span>Cheese<span class=\"sy0\">&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>    cheeseBox.<span class=\"me1\">add</span><span class=\"br0\">(</span>cheddar<span class=\"br0\">)</span><br/>    cheeseBox.<span class=\"me1\">add</span><span class=\"br0\">(</span>feta<span class=\"br0\">)</span><br/>    println<span class=\"br0\">(</span><span class=\"st0\">\"CheeseBox contains\u00a0: $cheeseBox\"</span><span class=\"br0\">)</span><br/>\u00a0<br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> beef <span class=\"sy0\">=</span> Meat<span class=\"br0\">(</span><span class=\"st0\">\"beef\"</span><span class=\"br0\">)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> ham <span class=\"sy0\">=</span> Meat<span class=\"br0\">(</span><span class=\"st0\">\"ham\"</span><span class=\"br0\">)</span><br/>    <a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> meatBox <span class=\"sy0\">=</span> FoodBox<span class=\"sy0\">&lt;</span>Meat<span class=\"sy0\">&gt;</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>    meatBox.<span class=\"me1\">add</span><span class=\"br0\">(</span>beef<span class=\"br0\">)</span><br/>    meatBox.<span class=\"me1\">add</span><span class=\"br0\">(</span>ham<span class=\"br0\">)</span><br/>    println<span class=\"br0\">(</span><span class=\"st0\">\"MeatBox contains\u00a0: $meatBox\"</span><span class=\"br0\">)</span><br/>\u00a0<br/>    cheddar.<span class=\"me1\">eat</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>    beef.<span class=\"me1\">eat</span><span class=\"br0\">(</span><span class=\"br0\">)</span><br/>    println<span class=\"br0\">(</span><span class=\"st0\">\"Full now!\"</span><span class=\"br0\">)</span><br/><span class=\"br0\">}</span></pre>"}, {"lang": "Morfa", "loc": 27, "block": "<pre class=\"text highlighted_source\">import morfa.type.traits;<br/>\u00a0<br/>template &lt; T &gt;<br/>alias IsEdible = HasMember&lt; T, \"eat\" &gt;;<br/>\u00a0<br/>template &lt; T &gt;<br/>if (IsEdible&lt; T &gt;)<br/>struct FoodBox<br/>{<br/>    var food: T[];<br/>}<br/>\u00a0<br/>struct Carrot <br/>{<br/>    func eat(): void {}<br/>}<br/>\u00a0<br/>struct Car {}<br/>\u00a0<br/>func main(): void <br/>{<br/>    var carrotBox: FoodBox&lt; Carrot &gt;;   // OK<br/>    carrotBox.food ~= Carrot();        // Adds a carrot<br/>\u00a0<br/>    // var carBox: FoodBox&lt; Car &gt;;      // Not allowed<br/>    static assert( not trait(compiles, func() { var carBox: FoodBox&lt; Car &gt;; } ));<br/>}</pre>"}, {"lang": "Nemerle", "loc": 46, "block": "<pre class=\"text highlighted_source\">using System.Collections.Generic;<br/>\u00a0<br/>interface IEatable<br/>{<br/>    Eat()\u00a0: void;<br/>}<br/>\u00a0<br/>class FoodBox[T]\u00a0: IEnumerable[T]<br/>  where T\u00a0: IEatable<br/>{<br/>    private _foods\u00a0: list[T] = [];<br/>\u00a0<br/>    public this() {}<br/>\u00a0<br/>    public this(items\u00a0: IEnumerable[T])<br/>    {<br/>        this._foods = $[food | food in items];<br/>    }<br/>\u00a0<br/>    public Add(food\u00a0: T)\u00a0: FoodBox[T]<br/>    {<br/>        FoodBox(food::_foods);<br/>    }<br/>\u00a0<br/>    public GetEnumerator()\u00a0: IEnumerator[T]<br/>    {<br/>        _foods.GetEnumerator();<br/>    }<br/>}<br/>\u00a0<br/>class Apple\u00a0: IEatable<br/>{<br/>    public this() {}<br/>\u00a0<br/>    public Eat()\u00a0: void<br/>    {<br/>        System.Console.WriteLine(\"nom..nom..nom\");<br/>    }<br/>}<br/>\u00a0<br/>mutable appleBox = FoodBox();<br/>repeat(3) {<br/>    appleBox = appleBox.Add(Apple());<br/>}<br/>\u00a0<br/>foreach (apple in appleBox) apple.Eat();</pre>"}, {"lang": "Nim", "loc": 21, "block": "<pre class=\"text highlighted_source\">type<br/>  Eatable = concept e<br/>    eat(e)<br/>\u00a0<br/>  FoodBox[e: Eatable] = seq[e]<br/>\u00a0<br/>  Food = object<br/>    name: string<br/>    count: int<br/>\u00a0<br/>proc eat(x: int) = echo \"Eating the int: \", x<br/>proc eat(x: Food) = echo \"Eating \", x.count, \" \", x.name, \"s\"<br/>\u00a0<br/>var ints = FoodBox[int](@[1,2,3,4,5])<br/>var fs = FoodBox[Food](@[])<br/>\u00a0<br/>fs.add Food(name: \"Hamburger\", count: 3)<br/>fs.add Food(name: \"Cheeseburger\", count: 5)<br/>\u00a0<br/>for f in fs:<br/>  eat(f)</pre>"}, {"lang": "Objective-C", "loc": 3, "block": "<pre class=\"objc highlighted_source\"><span class=\"kw1\">@protocol</span> Eatable<br/><span class=\"sy0\">-</span> <span class=\"br0\">(</span><span class=\"kw4\">void</span><span class=\"br0\">)</span>eat;<br/><span class=\"kw1\">@end</span></pre>"}, {"lang": "OCaml", "loc": 4, "block": "<pre class=\"ocaml highlighted_source\"><span class=\"kw1\">module</span> <span class=\"kw1\">type</span> Eatable <span class=\"sy0\">=</span> <span class=\"kw1\">sig</span><br/>  <span class=\"kw1\">type</span> t<br/>  <span class=\"kw1\">val</span> eat <span class=\"sy0\">:</span> t <span class=\"sy0\">-&gt;</span> <a href=\"http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html#TYPEunit\"><span class=\"kw4\">unit</span></a><br/><span class=\"kw1\">end</span></pre>"}, {"lang": "ooRexx", "loc": 29, "block": "<pre class=\"oorexx highlighted_source\"><span class=\"kw1\">call</span> dinnerTime <span class=\"st0\">\"yogurt\"</span><br/><span class=\"kw1\">call</span> dinnerTime <span class=\"sy0\">.</span>pizza~new<br/><span class=\"kw1\">call</span> dinnerTime <span class=\"sy0\">.</span>broccoli~new<br/>\u00a0<br/>\u00a0<br/><span class=\"co1\">-- a mixin class that defines the interface for being \"food\", and</span><br/><span class=\"co1\">-- thus expected to implement an \"eat\" method</span><br/>::class food mixinclass object<br/>::method eat abstract<br/>\u00a0<br/>::class pizza subclass food<br/>::method eat<br/>  <span class=\"kw1\">Say</span> <span class=\"st0\">\"mmmmmmmm, pizza\"</span><span class=\"sy0\">.</span><br/>\u00a0<br/><span class=\"co1\">-- mixin classes can also be used for multiple inheritance</span><br/>::class broccoli inherit food<br/>::method eat<br/>  <span class=\"kw1\">Say</span> <span class=\"st0\">\"ugh, do I have to?\"</span><span class=\"sy0\">.</span><br/>\u00a0<br/>::routine dinnerTime<br/>  <span class=\"kw1\">use</span> <span class=\"kw1\">arg</span> dish<br/>  <span class=\"co1\">-- ooRexx arguments are typeless, so tests for constrained</span><br/>  <span class=\"co1\">-- types must be peformed at run time.  The isA method will</span><br/>  <span class=\"co1\">-- check if an object is of the required type</span><br/>  <span class=\"kw1\">if</span> <span class=\"sy0\">\\</span>dish~isA<span class=\"br0\">(</span><span class=\"sy0\">.</span>food<span class=\"br0\">)</span> <span class=\"kw3\">then</span> <span class=\"kw1\">do</span><br/>     <span class=\"kw1\">say</span> <span class=\"st0\">\"I can't eat that!\"</span><br/>     <span class=\"kw1\">return</span><br/>  <span class=\"kw3\">end</span><br/>  <span class=\"kw3\">else</span> dish~eat</pre>"}, {"lang": "OxygenBasic", "loc": 87, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>macro Gluttony(vartype, capacity, foodlist)<br/>'==========================================<br/>\u00a0<br/>typedef vartype physical<br/>\u00a0<br/>enum food foodlist<br/>\u00a0<br/>type ActualFood<br/>  sys      name<br/>  physical size<br/>  physical quantity<br/>end type<br/>\u00a0<br/>Class foodbox<br/>'============<br/>has ActualFood Item[capacity]<br/>sys max<br/>\u00a0<br/>method put(sys f, physical s,q)<br/>  max++<br/>  Item[max]&lt;=f,s,q<br/>end method<br/>\u00a0<br/>method GetNext(ActualFood *Stuff)<br/>  if max then<br/>    copy @stuff,@Item[max], sizeof Item<br/>    max--<br/>  end if<br/>end method<br/>\u00a0<br/>end class<br/>\u00a0<br/>Class Gourmand<br/>'=============<br/>physical WeightGain, SleepTime<br/>\u00a0<br/>method eats(ActualFood *stuff)<br/>  WeightGain+=stuff.size*stuff.quantity*0.75<br/>  stuff.size=0<br/>  stuff.quantity=0<br/>end method<br/>\u00a0<br/>end class<br/>\u00a0<br/>end macro<br/>\u00a0<br/>\u00a0<br/>'IMPLEMENTATION<br/>'==============<br/>\u00a0<br/>\u00a0<br/>Gluttony (<br/>double,100,{<br/>oyster,trout,bloater,<br/>chocolate,truffles,<br/>cheesecake,cream,pudding,pie<br/>})<br/>\u00a0<br/>% small  1<br/>% medium 2<br/>% large  3<br/>% huge   7<br/>\u00a0<br/>% none    0<br/>% single  1<br/>% few     3<br/>% several 7<br/>% many    12<br/>\u00a0<br/>'INSTANCE<br/>'========<br/>\u00a0<br/>FoodBox  Hamper<br/>Gourmand MrG<br/>\u00a0<br/>'TEST<br/>'====<br/>\u00a0<br/>Hamper.put food.pudding,large,several<br/>Hamper.put food.pie,huge,few<br/>ActualFood Course<br/>Hamper.GetNext Course<br/>MrG.eats Course<br/>\u00a0<br/>print MrG.WeightGain 'result 15.75<br/>\u00a0</pre>"}, {"lang": "Perl 6", "loc": 13, "block": "<pre class=\"perl6 highlighted_source\"><span class=\"kw1\">subset</span> Eatable <span class=\"kw1\">of</span> Any <span class=\"kw1\">where</span> <span class=\"br0\">{</span> <span class=\"sy0\">.^</span>can<span class=\"br0\">(</span><span class=\"st_h\">'eat'</span><span class=\"br0\">)</span> <span class=\"br0\">}</span><span class=\"sy0\">;</span><br/>\u00a0<br/><span class=\"kw2\">class</span> Cake <span class=\"br0\">{</span> <span class=\"kw2\">method</span> eat<span class=\"br0\">(</span><span class=\"br0\">)</span> <span class=\"br0\">{</span><span class=\"sy0\">...</span><span class=\"br0\">}</span> <span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw2\">role</span> FoodBox<span class=\"br0\">[</span>Eatable<span class=\"br0\">]</span> <span class=\"br0\">{</span><br/>    <span class=\"kw1\">has</span> <span class=\"re0\">%</span><span class=\"sy0\">.</span><span class=\"me1\">foodbox</span><span class=\"sy0\">;</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw2\">class</span> Yummy <span class=\"kw1\">does</span> FoodBox<span class=\"br0\">[</span>Cake<span class=\"br0\">]</span> <span class=\"br0\">{</span> <span class=\"br0\">}</span>      <span class=\"co1\"># composes correctly</span><br/><span class=\"co1\"># class Yucky does FoodBox[Int] { }     # fails to compose</span><br/>\u00a0<br/><span class=\"kw1\">my</span> Yummy <span class=\"re0\">$foodbox</span> <span class=\"sy0\">.=</span> <span class=\"kw2\">new</span><span class=\"sy0\">;</span><br/><span class=\"kw3\">say</span> <span class=\"re0\">$foodbox</span><span class=\"sy0\">.</span><span class=\"me1\">perl</span><span class=\"sy0\">;</span></pre>"}, {"lang": "PicoLisp", "loc": 18, "block": "<pre class=\"text highlighted_source\">(class +Eatable)<br/>\u00a0<br/>(dm eat&gt; ()<br/>   (prinl \"I'm eatable\") )<br/>\u00a0<br/>\u00a0<br/>(class +FoodBox)<br/># obj<br/>\u00a0<br/>(dm set&gt; (Obj)<br/>   (unless (method 'eat&gt; Obj)                # Check if the object is eatable<br/>      (quit \"Object is not eatable\" Obj) )<br/>   (=: obj Obj) )                            # If so, set the object<br/>\u00a0<br/>\u00a0<br/>(let (Box (new '(+FoodBox))  Eat (new '(+Eatable))  NoEat (new '(+Bla)))<br/>   (set&gt; Box Eat)       # Works<br/>   (set&gt; Box NoEat) )   # Gives an error</pre>"}, {"lang": "Racket", "loc": 86, "block": "<pre class=\"text highlighted_source\">#lang racket<br/>(module+ test (require tests/eli-tester))<br/>\u00a0<br/>;; This is all that an object should need to properly implement.<br/>(define edible&lt;%&gt;<br/>  (interface () [eat (-&gt;m void?)]))<br/>\u00a0<br/>(define (generic-container&lt;%&gt; containee/c)<br/>  (interface ()<br/>    [contents  (-&gt;m (listof containee/c))]<br/>    [insert    (-&gt;m containee/c void?)]<br/>    [remove-at (-&gt;m exact-nonnegative-integer? containee/c)]<br/>    [count     (-&gt;m exact-nonnegative-integer?)]))<br/>\u00a0<br/>(define ((generic-box-mixin containee/c)\u00a0%)<br/>  (-&gt;i ([containee/c contract?])<br/>       (rv (containee/c) (implementation?/c (generic-container&lt;%&gt; containee/c))))<br/>  (class*\u00a0% ((generic-container&lt;%&gt; containee/c))<br/>    (super-new)<br/>    (define l empty)<br/>    (define/public (contents) l)<br/>    (define/public (insert o) (set! l (cons o l)))<br/>    (define/public (remove-at i)<br/>      (begin0 (list-ref l i)<br/>              (append (take l i) (drop l (add1 i)))))<br/>    (define/public (count) (length l))))<br/>\u00a0<br/>;; As I understand it, a \"Food Box\" from the task is still a generic... i.e.<br/>;; you will specify it down\u00a0;; to an \"apple-box%\" so: food-box%-generic is still<br/>;; generic. food-box% will take any kind of food.<br/>(define/contract (food-box-mixin T%)<br/>  (-&gt; (or/c (\u03bb (i) (eq? edible&lt;%&gt; i)) (implementation?/c edible&lt;%&gt;))<br/>   (make-mixin-contract))<br/>  (generic-box-mixin (and/c (is-a?/c edible&lt;%&gt;) (is-a?/c T%))))<br/>\u00a0<br/>(module+ test<br/>\u00a0<br/>  (define integer-box% ((generic-box-mixin integer?) object%))<br/>  (define integer-box  (new integer-box%))<br/>\u00a0<br/>  (define apple%<br/>    (class* object% (edible&lt;%&gt;)<br/>      (super-new)<br/>      (define/public (eat)<br/>        (displayln \"nom!\"))))<br/>\u00a0<br/>  (define banana%<br/>    (class* object% (edible&lt;%&gt;)<br/>      (super-new)<br/>      (define/public (eat)<br/>        (displayln \"peel.. peel... nom... nom!\"))))<br/>\u00a0<br/>  (define semolina%<br/>    (class* object% ()\u00a0; &lt;-- empty interfaces clause<br/>      (super-new)<br/>     \u00a0;; you can call eat on it... but it's not explicitly (or even vaguely)<br/>     \u00a0;; edible&lt;%&gt;<br/>      (define/public (eat) (displayln \"blech!\"))))<br/>\u00a0<br/> \u00a0;; this will take any object that is edible&lt;%&gt; and edible&lt;%&gt; (therefore all<br/> \u00a0;; edible&lt;%&gt; objects)<br/>  (define any-food-box (new ((food-box-mixin edible&lt;%&gt;) object%)))<br/>\u00a0<br/> \u00a0;; this will take any object that is edible and an apple&lt;%&gt;<br/> \u00a0;; (therefore only apple&lt;%&gt;s)<br/>  (define apple-food-box (new ((food-box-mixin apple%) object%)))<br/>\u00a0<br/>  (test<br/>  \u00a0;; Test generic boxes<br/>   (send integer-box insert 22)<br/>   (send integer-box insert \"a string\") =error&gt; exn:fail:contract?<br/>\u00a0<br/>  \u00a0;; Test the food box that takes any edible&lt;%&gt;<br/>   (send any-food-box insert (new apple%))<br/>   (send any-food-box insert (new banana%))<br/>   (send any-food-box insert (new semolina%)) =error&gt; exn:fail:contract?<br/>\u00a0<br/>  \u00a0;; Test the food box that takes any apple%<br/>   (send apple-food-box insert (new apple%))<br/>   (send apple-food-box insert (new banana%)) =error&gt; exn:fail:contract?<br/>   (send apple-food-box insert (new semolina%)) =error&gt; exn:fail:contract?<br/>   (send apple-food-box count) =&gt; 1<br/>\u00a0<br/>  \u00a0;; Show that you cannot make a food-box from the non-edible&lt;%&gt; semolina cannot<br/>   (implementation? semolina% edible&lt;%&gt;) =&gt; #f<br/>   (new ((food-box-mixin semolina%) object%)) =error&gt; exn:fail:contract?))</pre>"}, {"lang": "Ruby", "loc": 19, "block": "<pre class=\"ruby highlighted_source\"><span class=\"kw1\">class</span> Foodbox<br/>  <span class=\"kw1\">def</span> initialize <span class=\"br0\">(</span><span class=\"sy0\">*</span>food<span class=\"br0\">)</span><br/>    <span class=\"kw3\">raise</span> <span class=\"kw4\">ArgumentError</span>, <span class=\"st0\">\"food must be eadible\"</span> <span class=\"kw1\">unless</span>  food.<span class=\"me1\">all</span>?<span class=\"br0\">{</span><span class=\"sy0\">|</span>f<span class=\"sy0\">|</span> f.<span class=\"me1\">respond_to</span>?<span class=\"br0\">(</span><span class=\"re3\">:eat</span><span class=\"br0\">)</span><span class=\"br0\">}</span><br/>    <span class=\"re1\">@box</span> = food<br/>  <span class=\"kw1\">end</span><br/><span class=\"kw1\">end</span><br/>\u00a0<br/><span class=\"kw1\">class</span> Fruit<br/>  <span class=\"kw1\">def</span> eat; <span class=\"kw1\">end</span><br/><span class=\"kw1\">end</span><br/>\u00a0<br/><span class=\"kw1\">class</span> Apple <span class=\"sy0\">&lt;</span> Fruit; <span class=\"kw1\">end</span><br/>\u00a0<br/><span class=\"kw3\">p</span> Foodbox.<span class=\"me1\">new</span><span class=\"br0\">(</span>Fruit.<span class=\"me1\">new</span>, Apple.<span class=\"me1\">new</span><span class=\"br0\">)</span><br/><span class=\"co1\"># =&gt; #&lt;Foodbox:0x00000001420c88 @box=[#&lt;Fruit:0x00000001420cd8&gt;, #&lt;Apple:0x00000001420cb0&gt;]&gt;</span><br/>\u00a0<br/><span class=\"kw3\">p</span> Foodbox.<span class=\"me1\">new</span><span class=\"br0\">(</span>Apple.<span class=\"me1\">new</span>, <span class=\"st0\">\"string can't eat\"</span><span class=\"br0\">)</span><br/><span class=\"co1\"># =&gt; test1.rb:3:in `initialize': food must be eadible (ArgumentError)</span><br/>\u00a0</pre>"}, {"lang": "Rust", "loc": 51, "block": "<pre class=\"text highlighted_source\">\u00a0<br/>// This declares the \"Eatable\" constraint. It could contain no function.<br/>trait Eatable {<br/>    fn eat();<br/>}<br/>\u00a0<br/>// This declares the generic \"FoodBox\" type,<br/>// whose parameter must satisfy the \"Eatable\" constraint.<br/>// The objects of this type contain a vector of eatable objects.<br/>struct FoodBox&lt;T: Eatable&gt; {<br/>    _data: Vec&lt;T&gt;,<br/>}<br/>\u00a0<br/>// This implements the functions associated with the \"FoodBox\" type.<br/>// This statement is not required, but here it is used<br/>// to declare a handy \"new\" constructor.<br/>impl&lt;T: Eatable&gt; FoodBox&lt;T&gt; {<br/>    fn new() -&gt; FoodBox&lt;T&gt; {<br/>        FoodBox::&lt;T&gt; { _data: Vec::&lt;T&gt;::new() }<br/>    }<br/>}<br/>\u00a0<br/>// This declares a simple type.<br/>struct Banana {}<br/>\u00a0<br/>// This makes the \"Banana\" type satisfy the \"Eatable\" constraint.<br/>// For that, every declaration inside the declaration of \"Eatable\"<br/>// must be implemented here.<br/>impl Eatable for Banana {<br/>    fn eat() {}<br/>}<br/>\u00a0<br/>// This makes also the primitive \"char\" type satisfy the \"Eatable\" constraint.<br/>impl Eatable for char {<br/>    fn eat() {}<br/>}<br/>\u00a0<br/>fn main() {<br/>    // This instantiate a \"FoodBox\" parameterized by the \"Banana\" type.<br/>    // It is allowed as \"Banana\" implements \"Eatable\".<br/>    let _fb1 = FoodBox::&lt;Banana&gt;::new();<br/>\u00a0<br/>    // This instantiate a \"FoodBox\" parameterized by the \"char\" type.<br/>    // It is allowed, as \"char\" implements \"Eatable\".<br/>    let _fb2 = FoodBox::&lt;char&gt;::new();<br/>\u00a0<br/>    // This instantiate a \"FoodBox\" parameterized by the \"bool\" type.<br/>    // It is NOT allowed, as \"bool\" does not implement \"Eatable\".<br/>    //let _fb3 = FoodBox::&lt;bool&gt;::new();<br/>}<br/>\u00a0</pre>"}, {"lang": "Sather", "loc": 51, "block": "<pre class=\"text highlighted_source\">abstract class $EDIBLE is<br/>  eat;<br/>end;<br/>\u00a0<br/>class FOOD &lt; $EDIBLE is<br/>  readonly attr name:STR;<br/>  eat is<br/>    #OUT + \"eating \" + self.name + \"\\n\";<br/>  end;<br/>  create(name:STR):SAME is<br/>    res\u00a0::= new;<br/>    res.name\u00a0:= name;<br/>    return res;<br/>  end;<br/>end;<br/>\u00a0<br/>class CAR is<br/>  readonly attr name:STR;<br/>  create(name:STR):SAME is<br/>    res\u00a0::= new;<br/>    res.name\u00a0:= name;<br/>    return res;<br/>  end;<br/>end;<br/>\u00a0<br/>class FOODBOX{T &lt; $EDIBLE} is<br/>  private attr list:LLIST{T};<br/>  create:SAME is<br/>    res\u00a0::= new;<br/>    res.list\u00a0:= #;<br/>    return res;<br/>  end;<br/>  add(c\u00a0:T) is<br/>    self.list.insert_back(c);<br/>  end;<br/>  elt!:T is loop yield self.list.elt!; end; end;<br/>end;<br/>\u00a0<br/>class MAIN is<br/>  main is<br/>    box \u00a0::= #FOODBOX{FOOD}; -- ok<br/>    box.add(#FOOD(\"Banana\"));<br/>    box.add(#FOOD(\"Amanita Muscaria\"));<br/>\u00a0<br/>    box2\u00a0::= #FOODBOX{CAR};  -- not ok<br/>    box2.add(#CAR(\"Punto\")); -- but compiler let it pass!<br/>\u00a0<br/>    -- eat everything<br/>    loop box.elt!.eat; end;<br/>  end;<br/>end;</pre>"}, {"lang": "Scala", "loc": 11, "block": "<pre class=\"scala highlighted_source\"><a href=\"http://scala-lang.org\"><span class=\"kw1\">type</span></a> Eatable <span class=\"sy0\">=</span> <span class=\"br0\">{</span> <a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> eat<span class=\"sy0\">:</span> Unit <span class=\"br0\">}</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">class</span></a> FoodBox<span class=\"br0\">(</span>coll<span class=\"sy0\">:</span> List<span class=\"br0\">[</span>Eatable<span class=\"br0\">]</span><span class=\"br0\">)</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">case</span></a> <a href=\"http://scala-lang.org\"><span class=\"kw1\">class</span></a> Fish<span class=\"br0\">(</span>name<span class=\"sy0\">:</span> String<span class=\"br0\">)</span> <span class=\"br0\">{</span><br/>  <a href=\"http://scala-lang.org\"><span class=\"kw1\">def</span></a> eat <span class=\"br0\">{</span><br/>    println<span class=\"br0\">(</span><span class=\"st0\">\"Eating \"</span>+name<span class=\"br0\">)</span><br/>  <span class=\"br0\">}</span><br/><span class=\"br0\">}</span><br/>\u00a0<br/><a href=\"http://scala-lang.org\"><span class=\"kw1\">val</span></a> foodBox <span class=\"sy0\">=</span> <a href=\"http://scala-lang.org\"><span class=\"kw1\">new</span></a> FoodBox<span class=\"br0\">(</span>List<span class=\"br0\">(</span><a href=\"http://scala-lang.org\"><span class=\"kw1\">new</span></a> Fish<span class=\"br0\">(</span><span class=\"st0\">\"salmon\"</span><span class=\"br0\">)</span><span class=\"br0\">)</span><span class=\"br0\">)</span></pre>"}, {"lang": "Sidef", "loc": 7, "block": "<pre class=\"ruby highlighted_source\"><span class=\"kw1\">class</span> FoodBox<span class=\"br0\">(</span><span class=\"sy0\">*</span>food <span class=\"br0\">{</span> .<span class=\"me1\">all</span> <span class=\"br0\">{</span> .<span class=\"me1\">respond_to</span><span class=\"br0\">(</span><span class=\"re3\">:eat</span><span class=\"br0\">)</span> <span class=\"br0\">}</span> <span class=\"br0\">}</span><span class=\"br0\">)</span> <span class=\"br0\">{</span> <span class=\"br0\">}</span><br/>\u00a0<br/><span class=\"kw1\">class</span> Fruit <span class=\"br0\">{</span> method eat <span class=\"br0\">{</span> ... <span class=\"br0\">}</span> <span class=\"br0\">}</span><br/><span class=\"kw1\">class</span> Apple <span class=\"sy0\">&lt;</span> Fruit <span class=\"br0\">{</span>  <span class=\"br0\">}</span><br/>\u00a0<br/>say FoodBox<span class=\"br0\">(</span>Fruit<span class=\"br0\">(</span><span class=\"br0\">)</span>, Apple<span class=\"br0\">(</span><span class=\"br0\">)</span><span class=\"br0\">)</span>.<span class=\"me1\">dump</span>  <span class=\"co1\">#=&gt; FoodBox(food: [Fruit(), Apple()])</span><br/>say FoodBox<span class=\"br0\">(</span>Apple<span class=\"br0\">(</span><span class=\"br0\">)</span>, <span class=\"st0\">\"foo\"</span><span class=\"br0\">)</span>         <span class=\"co1\">#!&gt; ERROR: class `FoodBox`\u00a0!~ (Apple, String)</span></pre>"}, {"lang": "Swift", "loc": 3, "block": "<pre class=\"text highlighted_source\">protocol Eatable {<br/>    func eat()<br/>}</pre>"}, {"lang": "zkl", "loc": 10, "block": "<pre class=\"text highlighted_source\">class Eatable{ var v;<br/>   fcn eat{ println(\"munching \",self.topdog.name); }<br/>}<br/>class FoodBox{<br/>   fcn init(food1,food2,etc){<br/>      editable,garbage:=vm.arglist.filter22(\"isChildOf\",Eatable);<br/>      var contents=editable;<br/>      if(garbage) println(\"Rejecting: \",garbage);<br/>   }<br/>}</pre>"}]}